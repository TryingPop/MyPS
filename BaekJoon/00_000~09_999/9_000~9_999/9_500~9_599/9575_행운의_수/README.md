# C#

## 난이도 : 실버 4

## 알고리즘 분류
  - 자료 구조
  - 브루트포스 알고리즘
  - 해시를 사용한 집합과 맵

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
한슬이는 5와 8이 행운의 수라고 생각한다. 그래서 한슬이는 각 자리가 5와 8로만 이뤄져 있는 수를 행운의 수라고 한다.<br/>
정수 수열 A, B, C가 주어졌을 때 세 수열에서 각각 하나의 정수를 골라서 만들 수 있는 서로 다른 행운의 수의 개수를 구해보자.<br/>
예를 들어 A = [1, 10, 100], B = [3, 53], C = [4, 54]라고 한다면, 행운의 수를 만드는 방법은 8 = 1 + 3 + 4, 58 = 1 + 3 + 54, 58 = 1 + 53 + 4와 같이 총 3가지가 있다. 58은 2가지 방법으로 만들 수 있으니, 서로 다른 행운의 수의 개수는 8과 58, 총 2개이다.<br/>


## 입력
첫째 줄에 테스트 케이스의 수가 주어진다.<br/>
각 테스트 케이스의 첫째 줄에 A의 크기 N이 주어지고, 둘째 줄에 수열 A의 원소가 주어진다. 수열 A의 원소는 공백으로 구분되어 있다.<br/>
다음 셋째 줄에는 B의 크기 M, 넷째 줄에는 수열 B의 원소, 다섯째 줄에는 C의 크기 K, 여섯째 줄에는 C의 원소가 주어지며, 수열 A의 정보와 같은 형식으로 되어 있다.<br/>
수열의 크기는 50을 넘지 않는 양의 정수이고, 수열의 원소는 30,000보다 작거나 같은 양의 정수이다.<br/>


## 출력
각각의 테스트 케이스마다 입력으로 주어진 수열을 이용해 만들 수 있는 서로 다른 행운의 수의 개수를 한 줄에 하나씩 출력한다.<br/>


## 예제 입력
2<br/>
6<br/>
100 1 10 100 1 1<br/>
7<br/>
3 53 53 53 53 53 53<br/>
6<br/>
4 54 4 54 4 54<br/>
1<br/>
47<br/>
1<br/>
500<br/>
1<br/>
33<br/>


## 예제 출력
2<br/>
0<br/>


## 풀이
수열 A, B, C에서 가능한 합을 모두 찾아도 50^3 = 125_000이다.<br/>


각 수열의 값은 3만 이하인 자연수이다.<br/>
그래서 만들어지는 값은 10만을 넘지 못한다.<br/>


5와 8로 이뤄져 있는지 찾는 것은 각 자릿수를 조사하면 되고 5자리 조사를 하면 된다.<br/>
그래서 브루트포스로 접근했다.<br/>


결과에서 중복은 제외해야 하기에 HashSet 자료구조를 이용해 중복을 확인했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/9575