# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 구현
  - 해 구성하기

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
n개의 정수로 된 순서 S= (s1, s2, ..., sn)가 있다. 여기서 si ≠ sj이고, 1 ≤ si ≤ n이다. S로부터 새로운 순서 R = (r1, r2, ..., rn)을 얻을 수 있는데, 여기서 ri는 S의 부분 순서 {s1, s2, ..., si-2, si-1} 중에서 si보다 작은 수의 개수이다.<br/>
n = 10인 경우의 예를 보자. S = (6, 4, 3, 5, 1, 2, 7, 8, 9, 10)이라면 R = (0, 0, 0, 2, 0, 1, 6, 7, 8, 9)이 된다. 어떤 순서 R이 주어질 때, 여러분은 R을 이용하여 S를 찾는 프로그램을 작성하어야 한다. 경우에 따라서는 R로부터 S를 찾는 것이 불가능할 수 있다. 예를 들어, 만약 n = 5이고, R = (0, 2, 2, 0, 1)이라면 이런 R에 대응하는 S는 존재하지 않는다.<br/>


## 입력
입력 데이터는 표준입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 S에 있는 정수의 개수 n (1 ≤ n ≤ 100)이 주어진다. 그 다음 줄에는 n개의 정수로 된 R이 주어진다.<br/>


## 출력
출력은 표준출력을 사용한다. 주어진 각 순서 R 에 대해, 대응하는 순서 S 를 찾아 한 줄에 출력하여야 한다. 만약 R로부터 S를 찾는 것이 불가능할 경우에 “IMPOSSIBLE”을 출력한다.<br/>


## 예제 입력
3<br/>
10<br/>
0 0 0 2 0 1 6 7 6 9<br/>
10<br/>
0 0 0 0 0 0 0 0 0 0<br/>
12<br/>
0 3 4 5 0 1 2 3 4 5 6 7<br/>


## 예제 출력
6 4 3 5 1 2 8 9 7 10<br/>
10 9 8 7 6 5 4 3 2 1<br/>
IMPOSSIBLE<br/>


## 풀이
현재 i번째에 대해 i번보다 다 작은것의 갯수는 비교 대상이 i - 1개 뿐이므로 i - 1이하여야 한다.<br/>
그래서 i 번째에 i이상인 경우 불가능하다고 판단한다.<br/>


이제 이외의 경우는 끝에서부터 ri의 값을 확인하는데 남은 수 중에서 ri + 1번째를 반환하게 했다.<br/>
그러면 앞에 1, 2, ..., ri가 남아있으므로 ri 조건을 만족한다.<br/>
그리고 이는 n이 100으로 매번 100개의 모든 원소를 확인하면 ri번째를 찾았다.<br/>
이렇게 수열을 만드니 이상없이 통과한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/9011