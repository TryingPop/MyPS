# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 그래프 이론
  - 그래프 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 256 MB

## 문제
세 개의 단어가 주어졌을때, 꿍은 첫 번째 단어와 두 번째 단어를 섞어서 세 번째 단어를 만들 수 있는지 궁금해졌다. 첫 번째와 두 번째 단어는 마음대로 섞어도 되지만 원래의 순서는 섞여서는 안 된다. 다음과 같은 경우를 생각해보자.<br/>

  - 첫 번째 단어 : cat
  - 두 번째 단어 : tree
  - 세 번째 단어 : tcraete

보면 알 수 있듯이, 첫 번째 단어와 두 번째 단어를 서로 섞어서 세 번째 단어를 만들 수 있다. 아래와 같이 두 번째 예를 들어보자.<br/>

  - 첫 번째 단어 : cat
  - 두 번째 단어 : tree
  - 세 번째 단어 : catrtee

이 경우 역시 가능하다. 그렇다면 "cat"과 "tree"로 "cttaree"를 형성하는건 불가능하다는걸 눈치챘을 것이다.<br/>


## 입력
입력의 첫 번째 줄에는 1부터 1000까지의 양의 정수 하나가 주어지며 데이터 집합의 개수를 뜻한다. 각 데이터집합의 처리과정은 동일하다고 하자. 각 데이터집합에 대해, 세 개의 단어로 이루어져 있으며 공백으로 구분된다. 모든 단어는 대문자 또는 소문자로만 구성되어 있다. 세 번째 단어의 길이는 항상 첫 번째 단어와 두 번째 단어의 길이의 합이며 첫 번째 단어와 두 번째 단어의 길이는 1~200이다.<br/>


## 출력
각 데이터집합에 대해 다음과 같이 출력하라.<br/>
만약 첫 번째 단어와 두 번째 단어로 세 번째 단어를 형성할 수 있다면<br/>

	Data set n: yes

과 같이 출력하고 만약 아니라면<br/>

	Data set n: no

과 같이 출력하라. 물론 n은 데이터집합의 순번으로 바뀌어야 한다. 아래의 예제 출력을 참고하라.<br/>


## 예제 입력
3<br/>
cat tree tcraete<br/>
cat tree catrtee<br/>
cat tree cttaree<br/>


## 예제 출력
Data set 1: yes<br/>
Data set 2: yes<br/>
Data set 3: no<br/>


## 풀이
기존 문자열 순서를 유지하며 해당 문자열을 만들 수 있는지 판별해야 한다.<br/>
예제 2의 경우 cat은 'c' 'a' t r 't' e e 와 같이 사용되었다.<br/>
나머지는 tree이다.<br/>


첫 문자열을 first, 두 번째 문자열을 second, 세 번째 문자열을 third라 할 때,<br/>
dp[f][s] = val를 third[f + s] = first[f]이거나 third[f + s] = second[s]인 경우 val = 1로 이외는 val = 0으로 했다.<br/>
만약 third[f + s] = first[f]을 만족하면 다음으로 dp[f + 1][s]가 되는지 확인한다.<br/>
반면 third[f + s] = second[s]인 경우는 dp[f][s + 1]을 확인했다.<br/>
이렇게 문자열 마지막까지 되는 경우를 확인하면 된다.<br/>
해당 방법은 첫 문자열의 길이를 F, 두 번째 문자열의 길이를 M이라하면 O(N x M)의 시간이 걸린다.<br/>
첫 번째 문자열과 두 번째 문자열 길이가 최대 200이므로 시도해볼만하다 생각했다.<br/>
이러한 아이디어를 DFS 형식으로 구현했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/9177