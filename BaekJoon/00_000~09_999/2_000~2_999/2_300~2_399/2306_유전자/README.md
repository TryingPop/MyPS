# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
DNA 서열은 4개의 문자 {a,c,g,t} 로 이루어진 문자열이다. DNA 서열에는 생명의 신비를 풀 수 있는 많은 정보가 들어 있다. 특히 KOI 유전자의 길이는 사람의 키와 깊은 상관 관계가 있다는 것이 알려져 있다. 이러한 KOI 유전자는 다음의 조건을 만족한다.<br/>

  1. at 와 gc 는 가장 짧은 길이의 KOI 유전자이다.
  2. 어떤 X가 KOI 유전자라면, aXt와 gXc도 KOI 유전자이다. 예를 들어, agct 와 gaattc는 KOI 유전자이나, tgca 와 cgattc는 KOI 유전자가 아니다.
  3. 어떤 X와 Y가 KOI 유전자라면, 이 둘을 연결한 XY도 KOI 유전자이다. 예를 들면, aattgc 또는 atat는 KOI 유전자이나 atcg 또는 tata는 KOI 유전자가 아니다.

KOI 유전자는 DNA 서열 중에서 부분 서열로 구성되어 있다. 부분 서열이란 주어진 서열에서 임의의 위치에 있는 0개 이상의 문자들을 삭제해서 얻어지는 서열이다. 예를 들면, DNA 서열 acattgatcg에서 두 번째 문자 c와 마지막 문자 g를 삭제하여 생긴 부분 서열 aattgatc는 길이가 8인 KOI 유전자이다. 그러나 마지막 문자 g를 삭제하여 만들어진 부분 서열 acattgatc는 KOI 유전자가 아니다.<br/>
문제는 주어진 DNA 서열의 부분 서열들 중에서 길이가 최대가 되는 KOI 유전자를 찾아 그 길이를 출력하는 것이다.<br/>


## 입력
첫째 줄에는 분석하고자 하는 DNA 서열이 주어진다. DNA 서열의 길이는 최대 500이다.<br/>


## 출력
입력 DNA 서열로부터 계산된 가장 긴 KOI 유전자의 길이를 첫 번째 줄에 출력한다. 단, KOI 유전자가 없는 경우에는 0을 출력한다.<br/>


## 예제 입력
acattgagtc<br/>


## 예제 출력
8<br/>


## 풀이
문제에서 KOI 유전자가 만들어지는 조건은 다음 세 가지로 주어진다.<br/>

  1. at 와 gc 는 가장 짧은 길이의 KOI 유전자이다.
  2. 어떤 X가 KOI 유전자라면, aXt와 gXc도 KOI 유전자이다.
  3. 어떤 X와 Y가 KOI 유전자라면, 이 둘을 연결한 XY도 KOI 유전자이다.


이로 KOI 유전자는 이전 KOI 유전자를 이용해 만들어짐을 알 수 있고 반복이 많을거 같아 dp로 접근했다.<br/>


dp[i][j] = val를 기존 유전자의 i번째 유전자부터 j번째 유전자까지의 부분 유전자에 대해 가장 긴 KOI 유전자의 길이 val가 되게 dp를 설정했다.<br/>
KOI 유전자가 만들어지는 2번과 3번 조건을 보면 KOI 유전자에 의해 만들어지므로 길이가 짧은 것부터 채워가고 다음과 같은 점화식을 얻는다.<br/>


KOI 유전자를 만드는 2번 조건을 이용하면,<br/>
기존 유전자를 str이라 할 때, str[i]와 str[j]를 이어 붙여 만든 유전자가 at, gc인 경우 최댓값 함수 Max를 이용하면 dp[i][j] = Max(2 + dp[i + 1][j - 1], dp[i][j])가 된다.<br/>


KOI 유전자를 만드는 3번 조건을 이용하면,<br/>
i ≤ k < j인 k에 대해 dp[i][j] = Max(dp[i][j], dp[i][k] + dp[k + 1][j])를 얻을 수 있다.<br/>


이렇게 각 길이 2부터 시작해 str의 길이까지 dp의 값을 채워갔다.<br/>
그러면 dp[1][str의 길이]에 우리가 찾는 가장 긴 KOI 문자열의 길이가 담긴다.<br/>


먼저 각 dp[i][j]에 대해 i ≤ k < j를 조사하므로 O(str의 길이)만큼 걸린다.<br/>
그리고 길이 len에 대해 모든 i를 조사하므로 O(str의 길이^2)이 된다.<br/>
그리고 모든 길이를 조사하므로 시간 복잡도는 O(str의 길이^3)이 된다.<br/>
str의 길이가 최대 500이므로 500^3 = 1.25억이고 제한 시간이 2초이므로 유효하다.<br/>


초기에는 for문이 아닌 재귀를 이용한 DFS로 탐색을 했다.<br/>


dp[i][j] = val는 str의 i번째에서 j번째 부분 유전자에 대해 가장 긴 KOI 유전자 val가 담기게 했다.<br/>
즉, dp는 위와 같이 선언했다.<br/>


해당 방법 역시 유전자의 길이가 낮은 것을 먼저 채워나가게 한다.<br/>
KOI 유전자의 2번 조건을 먼저 검사한다.<br/>


dp[i][j]에 대해 str[i]와 str[j]를 합친 유전자가 at, gc인지 확인한다.<br/>
해당 경우 dp[i][j] = Max(dp[i][j], 2 + dp[i + 1][j - 1])을 한다.<br/>
반면 at, gc가 아닌 경우 dp[i][j] = Max(dp[i + 1][j], dp[i][j - 1])를 조사하며 길이가 작은 것을 먼저 채워 갔다.<br/>


이후 3번 조건을 확인한다.<br/>
i ≤ k < j인 k에 대해 dp[i][j] = Max(dp[i][j], dp[i][k] + dp[k + 1][j])로 확인했다.<br/>
이렇게 찾으면 잦은 재귀함수 호출로 for문을 이용한 방법보다 40%가까이 시간이 더 걸렸다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2306