# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
0과 1로 이루어진 수열 S가 있다. S의 첫 수는 s1이고, 마지막 수는 sn이다. S의 인접한 비트의 개수는 다음과 같이 구할 수 있다.<br/>
s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn<br/>
위의 식을 이용하면 수열 S에서 인접한 1의 개수를 구할 수 있다. 예를들어, 011101101의 인접한 비트의 개수는 3이 되고, 111101101은 4, 010101010은 0이 된다.<br/>
수열 S의 크기 n과 k가 주어졌을 때, 인접한 비트의 개수가 k인 수열 S의 개수를 구하는 프로그램을 작성하시오.<br/>
예를 들어, n이 5이고, k가 2이면, 수열 S가 될 수 있는 수열은 다음과 같이 6가지가 있다.<br/>
11100, 01110, 00111, 10111, 11101, 11011<br/>


## 입력
첫째 줄에 테스트 케이스의 수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 수 2개가 공백으로 구분되어 이루어져 있다. 첫 번째 수는 n이고, 두 번째 수는 k이다. n과 k는 100을 넘지 않는 자연수이다.<br/>


## 출력
각 테스트 케이스에 대해 인접한 비트의 개수가 k인 수열 S의 개수를 한 줄에 하나씩 출력한다. 이 값은 2,147,483,647보다 작거나 같다.<br/>


## 예제 입력
10<br/>
5 2<br/>
20 8<br/>
30 17<br/>
40 24<br/>
50 37<br/>
60 52<br/>
70 59<br/>
80 73<br/>
90 84<br/>
100 90<br/>


## 예제 출력
6<br/>
63426<br/>
1861225<br/>
168212501<br/>
44874764<br/>
160916<br/>
22937308<br/>
99167<br/>
15476<br/>
23076518<br/>


## 풀이
dp[i][j][k] = val를 길이가 i이고 인접한 갯수가 j이고 끝에 값이 k인 갯수를 val로 dp를 선언한다.<br/>
그러면 오른쪽 끝에 0 또는 1을 추가하는 식으로 나가면 다음과 같은 점화식을 얻을 수 있다.<br/>
끝에 0을 이어 붙이는 경우 길이 i + 1이되고 인접한 j개인 dp[i + 1][j][0] += dp[i][j][0] + dp[i][j][1]이 된다.<br/>
반면 끝에 1을 이어붙이는 경우 마지막이 1인 경우는 인접한 갯수가 1개 증가한다.<br/>
그래서 dp[i + 1][j + 1][1] += dp[i][j][1]이다. 반면 끝이 0인 경우에 이어붙인다면 갯수에는 영향이 없으므로 dp[i + 1][j][1] += dp[i][j][0]이 된다.<br/>
길이가 100을 넘지 않고 정답은 int 범위를 벗어나지 않는다고 했으므로 int 형태로 선언했다.<br/>
그리고 먼저 해당 범위의 값들을 모두 찾고 n, k가 주어지면 dp[n][k][0] + dp[n][k][1]을 반환했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2698