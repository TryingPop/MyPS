# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
N(1 ≤ n ≤ 32767)명의 사람들이 잔치에서 춤을 추게 되었다. 처음에는 1번부터 N번까지의 사람들이 차례대로, 둥글게 손을 잡고 서 있다. 그리고 춤이 끝날 때에는 이 순서가 반대(거꾸로, 뒤집힌)가 되어야 한다. 물론 사람들이 모두 손을 놓고 다시 자리를 잡으면 되겠지만, 그렇게 하면 둥그런 모양이 깨지게 된다. 따라서 자리를 바꿀 때에는, 서로 손을 잡고 있는 두 명의 사람만 자리를 바꿀 수 있다.<br/>
예를 들어 n=6인 경우를 보자. 맨 처음의 순서는 (1, 2, 3, 4, 5, 6)이 된다. 둥글게 서 있기 때문에 1번과 6번도 손을 잡고 있다. 이제 (1, 2, 3, 4, 5, 6) → (6, 2, 3, 4, 5, 1) → (2, 6, 3, 4, 5, 1) → (1, 6, 3, 4, 5, 2) → (1, 6, 3, 5, 4, 2) → (1, 6, 5, 3, 4, 2) → (1, 6, 5, 4, 3, 2)의 순서대로 바꾸면 자리가 반대가 된다. (6, 5, 4, 3, 2, 1)이 되는 게 맞겠지만, 어차피 둥글게 서 있기 때문에 (1, 6, 5, 4, 3, 2)와 같은 경우도 순서는 반대가 되는 게 맞다.<br/>
가급적이면 자리를 최소로 바꾸려고 한다. 최소로 자리를 바꾸려면 어떻게 해야 할까?<br/>


## 입력
첫째 줄에 n이 주어진다.<br/>


## 출력
첫째 줄에 최소 자리바꿈 회수를 출력한다.<br/>


## 예제 입력
6<br/>


## 예제 출력
6<br/>


## 풀이
먼저 n이 올 위치를 1 ~ n중에 잡는다.<br/>
n이 올 위치를 i라하면, 1 ~ i - 1번째는 i - 1, i - 2, ..., 3, 2, 1형태로 와야 한다.<br/>
i ~ n은 n, n - 1, n - 2, ..., i + 1, i형태로 와야 한다.<br/>
그래서 1 ~ i - 1번째인 왼쪽 구간과 i ~ n인 오른쪽 구간으로 나눌 수 있다.<br/>
각 구간을 역순으로 만드는 최솟값은 버블 정렬 형태로 정렬하는게 그리디로 최소가 됨을 알 수 있다.<br/>
그래서 n을 i번째 자리에 옮겨서 역순으로 만드는 최소 경우의 수는 (i) * (i - 1) / 2 + (n - i) * (n - i - 1) / 2가 된다.<br/>


이제 각 i에 대해 경우의 수를 찾고 해당 값의 최솟값이 정답이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2117