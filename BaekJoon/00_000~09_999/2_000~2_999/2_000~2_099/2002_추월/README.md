# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 구현
  - 자료 구조
  - 문자열
  - 해시를 사용한 집합과 맵
  - 집합과 맵

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
대한민국을 비롯한 대부분의 나라에서는 터널 내에서의 차선 변경을 법률로 금하고 있다. 조금만 관찰력이 있는 학생이라면 터널 내부에서는 차선이 파선이 아닌 실선으로 되어 있다는 것을 알고 있을 것이다. 이는 차선을 변경할 수 없음을 말하는 것이고, 따라서 터널 내부에서의 추월은 불가능하다.<br/>
소문난 명콤비 경찰 대근이와 영식이가 추월하는 차량을 잡기 위해 한 터널에 투입되었다. 대근이는 터널의 입구에, 영식이는 터널의 출구에 각각 잠복하고, 대근이는 차가 터널에 들어가는 순서대로, 영식이는 차가 터널에서 나오는 순서대로 각각 차량 번호를 적어 두었다.<br/>
N개의 차량이 지나간 후, 대근이와 영식이는 자신들이 적어 둔 차량 번호의 목록을 보고, 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차들이 몇 대 있다는 것을 알게 되었다. 대근이와 영식이를 도와 이를 구하는 프로그램을 작성해 보자.<br/>


## 입력
입력은 총 2N+1개의 줄로 이루어져 있다. 첫 줄에는 차의 대수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 대근이가 적은 차량 번호 목록이 주어지고, N+2째 줄부터 N개의 줄에는 영식이가 적은 차량 번호 목록이 주어진다. 각 차량 번호는 6글자 이상 8글자 이하의 문자열로, 영어 대문자('A'-'Z')와 숫자('0'-'9')로만 이루어져 있다.<br/>
같은 차량 번호가 두 번 이상 주어지는 경우는 없다.<br/>


## 출력
첫째 줄에 터널 내부에서 반드시 추월을 했을 것으로 여겨지는 차가 몇 대인지 출력한다.<br/>


## 예제 입력
4<br/>
ZG431SN<br/>
ZG5080K<br/>
ST123D<br/>
ZG206A<br/>
ZG206A<br/>
ZG431SN<br/>
ZG5080K<br/>
ST123D<br/>


## 예제 출력
1<br/>


## 풀이
두 차 A, B가 나란히 있다고 하자. 이때 A는 상대적으로 앞에 있는 차, B는 뒤에 있는 차이다.<br/>
차량 B가 차량 A를 추월했다는 의미는, 입장(들어올 때)에서는 B가 A보다 뒤였지만, 출차(나갈 때)에서는 B가 A보다 앞에 있는 경우를 말한다.<br/>


이를 일반화하면, 어떤 차량이 자신보다 먼저 들어왔던 차량보다 나중에 나갔다면 그 차량은 추월한 것이다.<br/>
즉, 출차 순서에서 자신보다 뒤에 있는 차량들 중, 입장 순서가 더 앞선 차량이 하나라도 있다면 추월로 간주할 수 있다.<br/>


이를 효율적으로 판별하기 위해, 먼저 차량 번호에 따라 입장 순서대로 새 인덱스를 부여한다.<br/>
이때 C#의 Dictionary 자료구조를 사용하면 각 차량 번호에 대해 O(1) 시간에 입장 인덱스를 부여할 수 있으므로, 전체적으로 O(N)에 처리가 가능하다.<br/>


다음으로 출차 순서대로 차량 번호를 입력받고, 각 번호를 위에서 부여한 입장 인덱스로 치환한 배열을 구성한다.<br/>
이제 이 배열은 출차 순서에서 각 차량의 입장 인덱스를 담고 있는 배열이 된다.<br/>


차량 번호 부여를 배열로 할 수 있지만 입장 인덱스로 치환할 때 매번 배열 전체를 찾아야 하므로 매번 치환에 O(N)의 시간이 걸린다.<br/>
반면 Dictionary는 O(1)에 치환할 수 있다.<br/>


이 배열을 이용해 추월 여부를 판별한다. 방법은 다음과 같다.<br/>
각 원소를 확인하는데 자기보다 뒤에 있는 원소에 대해 작은값이 존재하는지 확인해야 한다.<br/>
작은게 하나라도 존재하는 것은 최솟값과 비교하는 것과 같으므로 최솟값만 살펴본다.<br/>


그래서 배열을 뒤에서부터 순회하며, 현재까지 본 차량들 중 입장 인덱스의 최솟값을 갱신해나간다.<br/>
그리고 현재 보고 있는 차량의 입장 인덱스가 그 최솟값보다 크다면, 자신보다 먼저 입장한 차량이 출차 순서상 뒤에 있으므로 추월한 것이다.<br/>
이러한 비교를 통해 추월한 차량의 수를 셀 수 있다.<br/>
이 방법은 별도의 배열 할당이나 리스트 삽입 없이, 단순한 변수 하나(min)로 현재까지의 최솟값만 유지하면 되므로 매우 효율적이다.<br/>
또한 배열을 역방향으로 순회하기 때문에, 새로 삽입하거나 탐색할 필요 없이 한 번의 반복문으로 추월 여부를 판단할 수 있다.<br/>


앞에서부터 순회해도 되지만 이 경우 배열을 이용해 남은 번호를 기록하며 찾아야 하므로 사용한 번호를 기록하는 배열 할당이 추가적으로 필요하다.<br/>
두 포인터 알고리즘을 이용하면 전체 경우를 찾는데 O(N)의 시간이 들고 각 경우 O(1)에 찾아갈 수 있어 시간은 같으나 메모리를 더 사용하게 된다.<br/>


이러한 방식으로 추월하는 차량들을 모두 찾을 수 있다.<br/>


차량에 번호를 부여하는 것은 C#의 해시인 Dictionary 자료 구조를 이용하면 매번 O(1)에 부여할 수 있으므로 O(N)의 시간이 걸린다.<br/>
그리고 나가는 순서도 Dictionary를 이용하면 각 차에 대한 O(1)에 번호를 찾고 O(N)의 시간에 나가는 순서 배열을 구할 수 있다.<br/>


이제 역순으로 뒤에 작은 것들을 기록하며 추월하는 찾아가면 매번 O(1)에 찾을 수 있으므로 O(N)의 시간에 모든 추월하는 차를 찾는다.<br/>
그래서 전체 시간 복잡도는 O(3N) = O(N)이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2002