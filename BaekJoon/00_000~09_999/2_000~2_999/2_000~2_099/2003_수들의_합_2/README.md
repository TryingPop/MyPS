# C#

## 난이도 : 실버 4

## 알고리즘 분류
  - 브루트포스 알고리즘
  - 누적 합
  - 두 포인터

## 제한조건
  - 시간 제한 : 0.5초
  - 메모리 제한 : 128 MB

## 문제
N개의 수로 된 수열 A[1], A[2], …, A[N] 이 있다. 이 수열의 i번째 수부터 j번째 수까지의 합 A[i] + A[i+1] + … + A[j-1] + A[j]가 M이 되는 경우의 수를 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 N(1 ≤ N ≤ 10,000), M(1 ≤ M ≤ 300,000,000)이 주어진다. 다음 줄에는 A[1], A[2], …, A[N]이 공백으로 분리되어 주어진다. 각각의 A[x]는 30,000을 넘지 않는 자연수이다.<br/>


## 출력
첫째 줄에 경우의 수를 출력한다.<br/>


## 예제 입력
4 2<br/>
1 1 1 1<br/>


## 예제 출력
3<br/>


## 풀이
S(i, j) = A[i] + A[i + 1] + ... + A[j]라 하자.<br/>
각 항이 자연수이므로 S(i, j) = m이라면 S(i, k) = m인 k는 j로 유일하다.<br/>


이는 k < j인 경우 Sum(i, j) - Sum(i, k) = A[i] + A[i + 1] + ... + A[j] - A[i] - A[i + 1] - ... - A[k] = A[k + 1] + ... + A[j] > 0이므로 성립한다.<br/>
비슷하게 k > j인 경우도 보이면 확인할 수 있다.<br/>


또한 i' < i이고 j' < j이면 Sum(i', j) > Sum(i, j) 이고 Sum(i, j') < Sum(i, j)임도 알 수 있다.<br/>


그래서 다음과 같은 방법으로 모두 찾을 수 있다.<br/>

Sum(i, j) < m이면 j의 값을 늘린다. 반면 Sum(i, j) > m이면 i의 값을 늘린다.<br/>
만약 Sum(i, j) = m인 경우 m인 갯수를 추가하고, i의 값을 1늘린다.<br/>
이렇게 진행하면 모든 경우를 찾을 수 있게 된다.<br/>


그리고 항의 갯수가 1만개이고, 값의 범위가 3만을 넘지 않기에 모두 더해도 int 범위에 들어간다.<br/>
합을 나타내는 변수를 int로 잡고 진행해도 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2003