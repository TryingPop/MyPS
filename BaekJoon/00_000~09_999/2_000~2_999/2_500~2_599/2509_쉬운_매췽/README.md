# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 구현
  - 브루트포스 알고리즘
  - 누적 합

## 제한조건
  - 시간 제한 : 30초
  - 메모리 제한 : 1536 MB

## 문제
다음과 같이 양수로 이루어진 두 수열이 있다. T=t1,t2,...,tn (텍스트), P=p1,p2,...,pm(패턴).<br/>
매칭이란 p1=tk, p2=tk+1, ..., pm=tk+m-1일때, "P는 k에서 T와 매칭된다" 라고 한다. 이러한 매칭은 Knuth-Morris-Pratt 알고리즘으로 찾을 수 있다.<br/>
매칭은 쉬우니깐, 조금 더 어려운 매칭을 생각해보자. P가 k에서 T와 매췽된다는 말은 아래와 같은 조건을 만족하는 수열 k=a0 < a1 < ... < am이 있을 때이다.<br/>
ta0 + ta0+1 + ... + ta1-1 = p1<br/>
ta1 + ta1+1 + ... + ta2-1 = p2<br/>
\.\.\.<br/>
tam-1 + tam-1+1 + ... + tam-1 = pm<br/>
매췽은 먼저 텍스트를 그룹짓고 그룹 내의 연속된 합을 구한 다음에, 패턴을 찾는 것이다.<br/>
예를 들어, T=1,2,1,1,3,2이고, P=3,2일 때를 생각해보자. 이때는 2개의 매췽이 있는데, k=1 (a1=3, a2=5) 일때와 k=5 (a1=6, a2=7)일 때 이다.<br/>
매췽의 개수는 P가 k에서 T와 매췽된때 k의 서로 다른 개수이다.<br/>
텍스트 P와 두 개의 패턴 P1, P2가 주어졌을 때, 다음을 구하시오.<br/>

  1. T와 P1의 매췽의 개수
  2. T와 P2의 매췽의 개수
  3. T와 P1 ⋅ n ⋅ P2의 매췽의 개수를 최대로 하는 가장 작은 양의 정수 n (⋅는 수열을 합치는 것이다)
  4. T와 P1 ⋅ n ⋅ P2의 개수 (여기서 n은 3에서 구한 n이다)


## 입력
첫째 줄에는 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 빈 줄로 구분된다.<br/>
각 테스트 케이스는 다음과 같이 여섯 줄로 구성되어 있다.<br/>
첫째 줄에는 텍스트의 길이 N이 주어진다.<br/>
둘째 줄에는 텍스트의 원소 N개가 주어진다.<br/>
셋째 줄에는 첫 번째 패턴의 길이 M1이 주어진다.<br/>
넷째 줄에는 첫 번째 패턴의 원소 M1개가 주어진다.<br/>
다섯째 줄에는 두 번째 패턴의 길이 M2이 주어진다.<br/>
여섯째 줄에는 두 번째 패턴의 원소 M2개가 주어진다.<br/>
N<=5000, M1,M2<=600, T와 P1, P2에 포함되어 있는 모든 원소를 합한 값은 11,000을 넘지 않는다.<br/>


## 출력
각 테스트케이스이 대해 한 줄에 문제에서 구하라 했던 순서대로 빈 칸을 사이에 두고 출력한다.<br/>


## 예제 입력
1<br/>
<br/>
13<br/>
1 1 1 1 1 47 1 1 1 1 1 1 1<br/>
3<br/>
1 1 2<br/>
3<br/>
1 1 1<br/>


## 예제 출력
6 8 48 2<br/>


## 힌트
첫 번째 패턴은 텍스트의 위치 1, 2, 7, 8, 9, 10에서 매췽된다.<br/>
두 번째 패턴은 1, 2, 3, 7, 8, 9, 10, 11에서 매췽된다.<br/>
"1,1,2,48,1,1,1"은 텍스트의 위치 1, 2에서 매췽된다.<br/>
n이 1<=n<47 일 때, "1,1,2,n,1,1,1"은 어느 곳에서도 매췽되지 않는다.<br/>
"1,1,2,47,1,1,1"은 텍스트의 위치 2에서만 매췽된다.<br/>
n>48일 때, 세 곳에서 매췽되는 "1,1,2,n,1,1,1"은 없다.<br/>


## 풀이
패턴 p1, p2에 대해 텍스트 t와 매췽되는 횟수를 각각 찾아야 한다.<br/>
텍스트와 패턴은 양의 정수로 이루어진 수열이므로, 텍스트의 i번째 위치에서 패턴이 매췽된다면, 그 위치에서의 매췽은 오직 하나뿐이며 중복되지 않는다.<br/>


텍스트의 i번째 위치에서 패턴과 매췽되는지를 확인할 때는, 두 포인터를 이용해 각 자리 수를 비교하며 최대 텍스트의 남은 길이 또는 패턴의 길이만큼만 탐색하면 된다.<br/>
그래서 두 포인터를 이용해 모두 찾는다면 t, p1, p2의 길이를 각각 N, M1, M2라 하면 N x (N + M1 + M2)번 연산에 찾을 수 있다.<br/>
그리고 N ≤ 5_000, M1, M2 ≤ 600이므로 유효한 방법이라 판단했다.<br/>



다음으로 수열을 이어붙이는 연산을 ⋅이라 할 때 t와 p1 ⋅ n ⋅ p2의 매췽의 개수를 최대로 하는 가장 작은 양의 정수 n을 찾아야 한다.<br/>
p1, p2의 매췽이 된 시작지점과 끝지점을 모두 안다고 하자.<br/>
그러면 p1의 매췽이 끝난지점을 end라 할 때, p2의 매췽이 시작된 지점 start가 end보다 큰 경우에 한해 n의 후보는 start + 1, start + 2, ... + end - 1위치에 있는 t의 값들을 누적한 것들이 된다.<br/>
예를들어 p1의 매췽이 t의 2, 3, 4, 5이고, p2의 매췽이 8, 9인 경우 t의 6, 7의 합이 n의 후보가 된다.<br/>
이렇게 가능한 n의 후보 값을 모두 집계하여 각 값의 등장 횟수를 센다.<br/>


이 중 등장 횟수가 가장 많은 n을 기준으로, 그 중 가장 작은 n이 p1 ⋅ n ⋅ p2의 매췽 횟수를 최대로 만드는 최소 양의 정수가 된다.<br/>
그리고 t와 p1 ⋅ n ⋅ p2의 개수는 m이 된다.<br/>


t, p1, p2의 길이를 각각 N, M1, M2라 할 때, t와 p1의 매췽 개수를 찾는데 필요한 연산은 N x (N + M1)이 된다.<br/>
그리고 t와 p2의 매췽 개수를 찾는데 필요한 연산은 N x (N + M2)가 된다.<br/>


모든 p1의 매췽 종료 지점과 p2의 매췽 시작 지점 쌍을 비교해 n 후보를 구하는데 N^2에 찾을 수 있다.<br/>
또한 앞에서 찾은 n에 대해 p1 ⋅ n ⋅ p2의 개수는 ∑t의 범위를 조사하면 찾을 수 있다.<br/>
그래서 전체 시간 복잡도는 O(N x (N + M1 + M2) + ∑t)가 된다.<br/>
N ≤ 5_000, M1, M2 ≤ 600, ∑t ≤ 11_000이므로 유효한 방법이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2509