# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 애드 혹
  - 비트마스킹

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
해빈이는 준규에게 메세지를 받았다. 준규는 세계 최고 수준의 암호학자이기 때문에 해빈이에게 암호로 메세지를 보낸다. 이번에 준규는 One Time Pad(OTP) 암호화 방식을 사용하기로 했다. 준규는 OTP방식을 제대로 적용하면 절대 해독할 수 없다는 것을 알기 때문에, 해빈이가 해석할 수 있도록 몇 가지 힌트를 같이 보내기로 했다.<br/>
준규는 메세지에 항상 영소문자, 온점('.'), 공백 (' ', ASCII코드 32)만 쓴다. 그리고 key값으로는 항상 '0'부터 '9'까지의 숫자만 쓴다. 이 사실을 알고 있는 해빈이는 이를 이용해 메세지에 있는 온점과 공백의 위치를 알 수 있다는 것을 깨닫고, 당신에게 프로그램으로 만들어달라고 부탁했다.<br/>
준규가 이런 메세지를 보낸 게 한두 번이 아니기 때문에 해빈이는 OTP 암호화 방식을 알고 있다. 예를 들어 "0120123"을 key로 사용해서 "abc efg"라는 문자열을 암호화하면 아래와 같다.<br/>


	abc efg
	0120123
	Start
	
	61 62 63 20 65 66 67
	30 31 32 30 31 32 33
	ASCII hexadecimal
	
	51 53 51 10 54 54 54
	excrypted message


먼저 key와 메세지 원문을 ASCII 인코딩을 사용해 16진수로 변환한다. 그리고 변환한 key와 원문을 각각 차례대로 XOR 연산한다. 그 결과가 암호화 된 메세지이다.<br/>


## 입력
입력에 첫 줄에는 암호화 된 메세지의 길이인 정수 N (1 ≤ N ≤ 1000)이 주어진다.<br/>
다음 줄에는 암호화 된 메세지가 N개의 16진수 정수로 주어진다. 이 수는 0(10진수) 이상 127(10진수) 이하이다.<br/>


## 출력
N개의 문자를 한 줄에 출력한다. 만약 i번째 글자가 문자라면 '-'를, 아니라면 '.'을 출력한다.<br/>

## 예제 입력
7<br/>
51 53 51 10 54 54 54<br/>


## 예제 출력
---.---<br/>


## 요약

  - 목표: One Time Pad(OTP) 방법으로 암호화된 문자 중에서 공백(' ')이나, 온점('.') 확인

  - 방법:
    - OTP 방법은 기존 문자와 key 문자 하나씩 ^ 연산을 하면서 암호화
    - '0', '1', ..., '9'와 '.', ' '에 ^연산을 한 결과 16 ~31 사이의 값이 나옴을 확인
    - '0', '1', ..., '9'와 'a', ..., 'z'에 ^ 연산을 한 결과 50 이상임을 확인
    - 암호화 값을 16진수로 표현하면 앞자리가 1인 경우 '.' 또는 ' '라 판별 가능


  - 정답: 암호화된 문자의 앞자리가 1이 아니면 문자, 1인 경우면 공백이나 온점으로 판별

  - 시간 복잡도: O(N), (N: 암호화된 문자의 개수)


## 풀이
One Time Pad 방법으로 암호화된 문자 중에서 공백이나, 온점을 파악해야 한다.<br/>


One Time Pad 에는 암호 연산을 위한 key 가 있다.<br/>
기존 문자열을 str이라 하면, 각 자리 i에 대해 str[i] ^ key[i]의 결과가 암호화된 결과가 된다.<br/>


예를들어 위 예제의 기존 문자는 "abc efg"이고 key는 "0120123"이다.<br/>
그러면 0번째를 보면 기존 문자는 'a'이고 key는 '0'이다 그래서 암호화된 값은 'a' ^ '0' = 81이 된다.<br/>
이렇게 암호화된 문자를 하나씩 생성해 간다.<br/>


기존 문자는 'a', 'b', 'c', ..., 'z'와, '.' 그리고 ' '로 총 28개의 문자로만 만들어진다.<br/>
그리고 key의 문자는 '0', '1', '2', ..., '9'만 온다고 한다.<br/>


암호화된 문자를 하나씩 생성해가기에 각각의 문자로 비교하면 된다.<br/>
그래서 '.', ' '와 '0', '1', ..., '9'에 ^연산을 하니 16이상 31 이하임을 확인했다.<br/>
반면 'a', 'b', ..., 'z'와 '0', '1', ..., '9'에 ^ 연산을 하니 50 ~ 127수로 나오는 것을 확인할 수 있다.<br/>


이를 16 \~ 31의 수를 16진수로 표현하면 1x형태로 표현된다. 반면 50 이상의 수는 yx 형태인데, 여기서 y는 1이 아니다.<br/>
그래서 앞자리가 1인 경우 '.', ' '로 판별하고, 아니면 문자로 판별했다.<br/>


각 문자를 읽고 앞자리가 1인지 여부로 판별했기에 각 경우 O(1)에 해결이 가능하다.<br/>
그래서 입력되는 암호의 개수를 N이라 하면 시간복잡도는 O(N)이 된다.<br/>


참고로 공백의 아스키 값 32 = 0b0_100_000이고 온점의 아스키 값 46 = 0b0_101_110이다.<br/>
'0'의 아스키 값 48 = 0b0_110_000이고 '9'의 아스키 값 57 = 0b0_111_001이므로 둘이 연산을하면 0b0_01x_xxx임이 보장된다.<br/>
반면 'a'의 아스키값 97 = 0b1_100_001이고 이외 'b', 'c', ..., 'z'까지 모두 0b1_xxx_xxx이므로 '0' ~ '9'와 ^연산을 하면 0b1_xxx_xxx이다.<br/>
그래서 16진수로 표현했을 때 앞자리가 1로 판별하는 것이 타당함을 알 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2892