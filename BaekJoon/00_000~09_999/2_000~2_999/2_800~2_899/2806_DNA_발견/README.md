# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
국내 생물학자들은 기존에 보지 못했던 신기한 DNA 분자를 발견했다. 이 분자는 A와 B로만 이루어진 N글자로 나타낼 수 있다. 이 분자는 계속해서 돌연변이를 한 다음에, A로만 된 분자로 변한다.<br/>
어느 날, 이 분자를 연구하던 학자들은 두 종류의 돌연변이를 일으킨다는 사실을 알아내었다. 첫 번째 돌연변이는 분자의 한 글자가 다른 글자로 바뀌는 것이다. (A -> B 또는 B -> A) 두 번째 돌연변이는 첫 K개 글자를 모두 다른 글자로 바꾸는 것이다<br/>
DNA 분자가 주어졌을 때, 돌연변이를 최소 몇 번 일으키면, 전부 A로 된 분자가 되는지 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 분자의 길이 N이 주어진다. (1 ≤ N ≤ 1,000,000)<br/>
둘째 줄에는 분자를 이루는 N글자가 주어진다.<br/>


## 출력
첫째 줄에 최소 몇 번 돌연변이를 일으키면 A로만 된 분자가 되는지 출력한다.<br/>


## 예제 입력
12<br/>
AAABBBAAABBB<br/>


## 예제 출력
4<br/>


## 풀이
따로 규칙성을 찾지 못해 힌트를 보고 dp로 점화식을 구해 해결했다.<br/>
dp[i][j] = val를 i는 1 ~ i번째까지 뒤집은 여부를 나타낸다.<br/>
i = 0인 경우 뒤집지 않은 상태다. 그래서 문자열을 그대로 읽으면 된다.<br/>
i = 1인 경우는 뒤집어진 상태다. 그래서 B는 A로 A는 B로 읽어야 한다.<br/>
j는 현재 가리키는 문자가 끝에서 j번째를 뜻한다.<br/>
val는 j ~ n 번째가 A로 되는 최소 돌연변이 수가 된다.<br/>


그러면 다음과 같은 점화식을 얻을 수 있다.<br/>


뒤에서 j번째 문자가 A인 경우 dp[0][j]의 값을 보자.<br/>
이전에 뒤집지 않은 최솟값을 그대로 계승하는 방법이 있다. dp[0][j - 1]<br/>
또는 이전에 뒤집어진 상태에서 뒤에서 j번째 돌연변이만 바꾸는 방법이 있다. dp[1][j - 1] + 1<br/>
그래서 둘 중 작은 값을 가져오면 된다.<br/>
dp[0][j] = Math.Min(dp[0][j - 1], dp[1][j - 1] + 1)<br/>


뒤에서 j번째 문자가 A인 경우 dp[1][j]의 값을 보자.<br/>
이전에 뒤집지 않은 경우에서 뒤에서 j + 1번째까지 뒤집는 방법으로 올 수 있다. dp[0][j - 1]  + 1<br/>
또는 이전에 뒤집어진 상태에서 현재껄 뒤집는 방법으로 올 수 있다. dp[1][j - 1] + 1<br/>
그래서 둘 중 작은 값을 가져오면 된다.<br/>
dp[1][j] = Math.Min(dp[0][j - 1] + 1, dp[1][j - 1] + 1)<br/>


비슷하게 뒤에서 j번째 문자가 B인 경우도 적용하면 다음과 같은 점화식을 얻을 수 있다.<br/>
dp[0][j] = dp[0][idx] = Math.Min(dp[0][idx - 1] + 1, dp[1][idx - 1] + 1)와 dp[1][idx] = Math.Min(dp[1][idx - 1], dp[0][idx - 1] + 1)을 얻을 수 있다.<br/>


이렇게 dp를 채워가고 dp[0][n], dp[1][n] 중 작은 값이 정답이 된다.<br/>


다른 사람의 풀이를 보니, 그리디로 해결한게 있다.<br/>
코드를 보면 끝에 A를 이어 붙인다.<br/>
그리고 ABA나 BAB가 보이면 해당 1개 짜리는 1개 변환으로 먼저 처리한다.<br/>
이후 앞에서부터 다른 경우 바꿔가는 연산을 통해 최솟값을 찾는다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2806