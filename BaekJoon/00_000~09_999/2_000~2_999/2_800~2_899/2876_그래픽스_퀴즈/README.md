# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 구현
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
오늘은 기초컴퓨터그래픽스의 퀴즈가 있는 날이다. 기다란 교실 안에는 N개의 책상이 한 줄로 늘어서 있는데, 각 책상당 두 명의 학생이 앉도록 되어있다.<br/>
모든 학생들은 그래픽스를  열심히 공부했지만, 말도 안되는 난이도에 질려 포기하고 말았다. 한편 교수님은 각 학생들의 얼굴만 보고도 이 학생이 받아야 할 그레이드를 정확히 알아낼 수 있다.<br/>
교수님은 그래픽스 과목을 가르치는 만큼 자신의 미적 감각을 살리기 위해 각 그레이드를 다른 색을 이용해서 표시한다(예를 들어 A를 빨강으로 칠하면, B,C,D는 빨강으로 표시하지 않는다).<br/>
또, 퀴즈의 방식은 교수님이 수업이 시작할 때 어떤 두 책상을 선택하고, 두 책상과 그 사이에 있는 모든 책상에서 각각 한 명씩 지목해서 질문을 하고, 학생의 대답을 듣는 것이다.<br/>
오늘 교수님은 바쁜 나머지 한 가지 색의 색연필만 가지고 왔고, 결국 자신의 미학을 지키기 위해 퀴즈에서 지목한 모두에게 같은 그레이드를 주려고 한다. 교수님이 채점할 수 있는 학생의 수는 최대 몇 명일까?<br/>


## 입력
입력의 첫 번째 줄에는 정수 N이 주어진다(1 ≤ N ≤ 100,000).<br/>
다음 N개의 줄에는 i번째 책상에 앉은 두 학생이 받아야 할 그레이드 Ai와 Bi(1 ≤ Ai, Bi ≤ 5)가 주어진다.<br/>


## 출력
교수님이 한 가지 색만을 이용해 채점할 수 있는 최대 학생 수와 그때의 그레이드를 출력한다.<br/>
만약 답이 여러 가지라면, 가장 작은 그레이드를 출력한다.<br/>


## 예제 입력
4<br/>
2 1<br/>
3 2<br/>
5 3<br/>
2 5<br/>


## 예제 출력
2 2<br/>


## 요약

  - 목표 : 연속한 책상 폐구간 [s, e]에서 모든 책상에 a가 존재할 때, 가장 긴 길이인 구간 [s, e]의 길이와 그때의 a를 찾기

  - 정의:
    - dp[i] = i번째 책상이 a일 때, i를 끝으로 하는 a의 연속 구간 길이

  - 초기값:
    - dp[i] = 0

  - 점화식:
    - i번째 책상에 a를 포함하는 경우 : dp[i] = dp[i - 1] + 1
    - i번째 책상에 a를 포함하지 않는 경우 : dp[i] = 0

  - 정답: Max(dp[i])

  - 시간 복잡도: O(N x M) (N: 책상의 수, M: a의 범위)
    


## 풀이
연속한 책상 폐구간 [s, e]에서 모든 책상에 a가 존재할 때, 가장 긴 길이인 구간 [s, e]의 길이와 그때의 a를 찾아야 한다.<br/>
a = 1, 2, 3, 4, 5 각각에 대해 a로만 이루어진 가장 긴 연속 부분 구간의 길이를 구한 후, 문제 조건에 따라 가장 긴 구간과 해당 a 값을 찾는다.<br/>


a로만 이루어진 가장 긴 연속 부분 구간(구간 내 숫자가 모두 a인 구간)을 찾는 것은 dp로 자주 풀리는 기본적인 문제다.<br/>
다음과 같이 푼다. dp[i] = val를 다음과 같이 정의한다.<br/>

  - i : 0 ~ i번째까지 확인한 경우
  - val : i를 포함하는 a를 연속으로 포함하는 가장 큰 길이


i번째가 a라면 이전까지의 연속 길이 dp[i - 1]에 1을 더하고, 아니라면 연속성이 끊기므로 dp[i] = 0이다.<br/>


  - i번째 책상에 a를 포함하는 경우: dp[i] = dp[i - 1] + 1
  - i번째 책상에 a를 포함하지 않는 경우 : dp[i] = 0


그러면 우리가 찾는 정답은 Max(dp[i])가 된다.<br/>


이렇게 찾는 경우 탐색하는 경우는 dp의 크기 즉, 책상의 수 N을 넘지 못한다.<br/>
그리고 각 변수의 범위를 M이라 하면 dp연산을 M번 한다.<br/>
그래서 시간 복잡도는 O(N x M)이다. M ≤ 5이므로 O(N) 가깝다.<br/>



## 문제 링크
https://www.acmicpc.net/problem/2876