# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
N(1 ≤ N ≤ 100)개의 수로 이루어진 1차원 배열이 있다. 이 배열에서 M(1 ≤ M ≤ ⌈(N/2)⌉)개의 구간을 선택해서, 구간에 속한 수들의 총 합이 최대가 되도록 하려 한다. 단, 다음의 조건들이 만족되어야 한다.<br/>

  1. 각 구간은 한 개 이상의 연속된 수들로 이루어진다.
  2. 서로 다른 두 구간끼리 겹쳐있거나 인접해 있어서는 안 된다.
  3. 정확히 M개의 구간이 있어야 한다. M개 미만이어서는 안 된다.

N개의 수들이 주어졌을 때, 답을 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 두 정수 N, M이 주어진다. 다음 N개의 줄에는 배열을 이루는 수들이 차례로 주어진다. 배열을 이루는 수들은 -32768 이상 32767 이하의 정수이다.<br/>


## 출력
첫째 줄에 구간에 속한 수들의 총 합의 최댓값을 출력한다.<br/>


## 예제 입력
6 2<br/>
-1<br/>
3<br/>
1<br/>
2<br/>
4<br/>
-1<br/>


## 예제 출력
9<br/>


## 풀이
N의 범위가 100까지이므로 O(N^3)의 방법이 유효하다.<br/>
그래서 max[s][e]를 구간 s에서 e 중 최댓값을 담게 한다.<br/>
이는 s에서 시작해 kadane's 알고리즘을 써서 찾아주면 된다.<br/>


이제 dp[i][j]를 구간을 i개 택한 상태이고 끝이 j일 때 최댓값을 담게 하자.<br/>
그러면 dp[i][j] = max(dp[i - 1][k - 1] + max[k][j])가 된다.<br/>


이렇게 O(N^3)의 방법으로 해결했다.<br/>
다른 사람의 풀이를 보니 마지막 원소를 포함한 경우, 포함하지 않는 경우로 나눠서 O(N^2)에 해결했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2228