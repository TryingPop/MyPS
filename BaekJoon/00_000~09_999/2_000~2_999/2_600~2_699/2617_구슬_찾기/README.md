# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 그래프 이론
  - 그래프 탐색
  - 깊이 우선 탐색
  - 최단 경로
  - 플로이드-워셜

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
모양은 같으나, 무게가 모두 다른 N개의 구슬이 있다. N은 홀수이며, 구슬에는 번호가 1,2,...,N으로 붙어 있다. 이 구슬 중에서 무게가 전체의 중간인 (무게 순서로 (N+1)/2번째) 구슬을 찾기 위해서 아래와 같은 일을 하려 한다.<br/>
우리에게 주어진 것은 양팔 저울이다. 한 쌍의 구슬을 골라서 양팔 저울의 양쪽에 하나씩 올려 보면 어느 쪽이 무거운가를 알 수 있다. 이렇게 M개의 쌍을 골라서 각각 양팔 저울에 올려서 어느 것이 무거운가를 모두 알아냈다. 이 결과를 이용하여 무게가 중간이 될 가능성이 전혀 없는 구슬들은 먼저 제외한다.<br/>
예를 들어, N=5이고, M=4 쌍의 구슬에 대해서 어느 쪽이 무거운가를 알아낸 결과가 아래에 있다.<br/>

  1. 구슬 2번이 구슬 1번보다 무겁다.
  2. 구슬 4번이 구슬 3번보다 무겁다.
  3. 구슬 5번이 구슬 1번보다 무겁다.
  4. 구슬 4번이 구슬 2번보다 무겁다.


위와 같이 네 개의 결과만을 알고 있으면, 무게가 중간인 구슬을 정확하게 찾을 수는 없지만, 1번 구슬과 4번 구슬은 무게가 중간인 구슬이 절대 될 수 없다는 것은 확실히 알 수 있다. 1번 구슬보다 무거운 것이 2, 4, 5번 구슬이고, 4번 보다 가벼운 것이 1, 2, 3번이다. 따라서 답은 2개이다.<br/>
M 개의 쌍에 대한 결과를 보고 무게가 중간인 구슬이 될 수 없는 구슬의 개수를 구하는 프로그램을 작성하시오.<br/>


## 입력
첫 줄은 구슬의 개수를 나타내는 정수 N(1 ≤ N ≤ 99)과 저울에 올려 본 쌍의 개수 M(1 ≤ M ≤ N(N-1)/2)이 주어진다. 그 다음 M 개의 줄은 각 줄마다 두 개의 구슬 번호가 주어지는데, 앞 번호의 구슬이 뒤 번호의 구슬보다 무겁다는 것을 뜻한다.<br/>


## 출력
첫 줄에 무게가 중간이 절대로 될 수 없는 구슬의 수를 출력 한다.<br/>


## 예제 입력
5 4<br/>
2 1<br/>
4 3<br/>
5 1<br/>
4 2<br/>


## 예제 출력
2<br/>


## 풀이
무게이기에 추이성이 성립한다.<br/>


만약 B의 무게가 A보다 무겁다면 즉, A < B이다.<br/>
그리고 C의 무게가 B보다 무겁다면 B < C인 경우다.<br/>
이때 C는 A보다 무겁다고 봐도 된다. 즉, A < C가 성립한다.<br/>


그래서 무거운 경우로 단방향 간선을 잇는다. 예를 들어 A < B라면 A -> B로 가는 간선 front[A][B] = 1을 잇는다.<br/>
이후 플로이드 워셜로 방문할 수 있는 경우를 모두 찾는다.<br/>
N이 100 이하이므로 플로이드 워셜 방법이 유효하다.<br/>


그러면 각 i에 대해 front[i][j]값이 0이아닌 j의 갯수를 센다.<br/>
이는 i보다 무거운 것의 갯수와 같다.<br/>
중간 구슬이 되는 경우를 찾는 것이므로 무거운 것의 갯수가 (n + 1) / 2를 넘어가면 중간이 될 수 없다.<br/>


이와 마찬가지로 가벼운 경우의 단방향 간선을 잇는다. A < B라면 B -> A로 가는 간선 back[B][A] = 1을 잇는다.<br/>
그리고 플로이드 워셜 알고리즘으로 연결상태를 모두 확인한다.<br/>


이렇게 각 i에 대해 back[i][j]값이 0이아닌 j의 갯수를 센다.<br/>
이는 i보다 가벼운 것의 갯수와 같다.<br/>
중간 구슬이 되는 경우를 찾는 것이므로 가벼운 것의 갯수가 (n + 1) / 2를 넘어가면 중간이 될 수 없다.<br/>


이렇게 중간이 될 수 없는 구슬을 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2617