# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
명보네 동네 가게의 현금 출납기에는 k 가지 동전이 각각 n1, n2, … , nk개 씩 들어있다. 가게 주인은 명보에게 T원의 지폐를 동전으로 바꿔 주려고 한다. 이때, 동전 교환 방법은 여러 가지가 있을 수 있다. 예를 들어, 10원 짜리, 5원 짜리, 1원 짜리 동전이 각각 2개, 3개, 5개씩 있을 때, 20원 짜리 지폐를 다음과 같은 4가지 방법으로 교환할 수 있다.<br/>

  - 20 = 10×2 
  - 20 = 10×1 + 5×2 
  - 20 = 10×1 + 5×1 + 1×5 
  - 20 = 5×3 + 1×5

입력으로 지폐의 금액 T, 동전의 가지 수 k, 각 동전 하나의 금액 pi와 개수 ni가 주어질 때 (i=1, 2,…, k) 지폐를 동전으로 교환하는 방법의 가지 수를 계산하는 프로그램을 작성하시오. 방법의 수는 231-1을 초과 하지 않는 것으로 가정한다.<br/>


## 입력
첫째 줄에는 지폐의 금액 T(0＜T ≤ 10,000), 둘째 줄에는 동전의 가지 수 k(0＜k ≤ 100), 셋째 줄부터 마지막 줄까지는 각 줄에 동전의 금액 pi(0＜pi ≤ T)와 개수 ni(0＜ni ≤ 1,000)가 주어진다. pi와 ni사이에는 빈칸이 하나씩 있다.<br/>


## 출력
첫째 줄에 동전 교환 방법의 가지 수를 출력한다. 방법이 없을 때는 0을 출력한다.<br/>


## 예제 입력
20<br/>
3<br/>
5 3<br/>
10 2<br/>
1 5<br/>


## 예제 출력
4<br/>


## 풀이
단순 브루트포스로 찾는다면 각 동전에 대해 0 ~ ni개를 선택할 수 있으므로 전체 경우의 수는 ∏(ni + 1)가 된다.<br/>
따라서 서로 다른 동전 3종에 대해 각 동전이 1000개 이상 존재한다면 (1_000)^3 = 10억 ≤ ∏(ni + 1)이므로 시간초과 난다.<br/>
그래서 브루트포스 방법은 시간 초과가 발생하기 쉽다.<br/>


반면 배낭 알고리즘을 확인하자.<br/>

  - 찾는 금액 t는 1만 이하
  - 동전의 가지수 k는 100개 이하
  - 각 동전의 갯수 ni는 1_000개 이하

배낭 알고리즘으로 접근하는 경우 t x k x ∑ni ≤ 1만 x 100 x 1_000 = 10억이다.<br/>
브루트포스에 비해 빠르게 풀림을 알 수 있지만 시간 초과날 수 있다.<br/>


문제 조건 중 찾는 금액 t를 만드는 경우의 수는 2^31 - 1을 넘기지 않는다고 한다.<br/>
다음과 같은 극단적인 예제를 실행해봤다.<br/>

  - 동전은 총 30종이고 모두 가격은 1원으로 동일
  - 그리고 각 동전은 1000개로 개수역시 동일
  - 목표 금액은 10,000원

이때 int 형으로 구현된 dp 테이블에서 음수가 나왔다.<br/>
이는 오버플로우가 발생했음을 의미하고, 해당 경우의 수는 2^31 - 1를 초과하므로 불가능한 입력이다.<br/>


시간초과 나는 경우는 경우의 수가 2^31 - 1을 넘길거라 추측했다.<br/>
그래서 해당 추측으로 배낭 알고리즘이 유효하다 판단했다. 실제로 배낭 알고리즘이 시간 내에 통과된다.<br/>


이제 배낭 알고리즘의 dp 선언과 점화식 구현 방법이다.<br/>
dp[i][j] = val를 0 ~ i - 1번 동전까지 선택했고, j원을 만드는 서로 다른 경우의 수를 val가되게 한다.<br/>
그러면 i번 동전을 선택할 때 0 ~ i - 1번 동전 모음으로 가능한 j에 대해 즉, dp[i][j] > 0인 경우다.<br/>
dp[i][j]의 각 경우에 대해 i번 동전을 1 ≤ l ≤ ni개 추가하자.<br/>
그러면 금액은 i번째 동전의 가치를 p[i]라 하면 현재 j가격에서 l x p[i]가 추가된 j + l x p[i]이다.<br/>
그리고 dp[i][j]는 0 ~ i - 1번 동전을 이용해 만드는 서로 다른 경우의 수이고, 여기서 i번째 동전을 l개 추가한경우도 모두 다름이 보장된다.<br/>
그래서 dp[i + 1][j + l x p[i]] += dp[i][j]가 추가된다.<br/>


그리고 dp의 정의로 l = 0인 경우도 성립함을 알 수 있다.<br/>
그래서 dp[i + 1][j] += dp[i][j]다.<br/>


그런데, 가격 j의 탐색을 역순으로 한다면, dp[j] = val로 계속 갱신하면서 찾아갈 수 있다.<br/>
해당 경우 l = 0인 경우는 이미 채워져 있기에 추가할 필요가 없다.<br/>


i번째 동전에 대해 다음과 같은 연산을 한다.<br/>
dp[j] > 0, 1 ≤ l ≤ ni라 하자. dp[j + l x p[i]] += dp[j]연산을 해주면 된다.<br/>


이렇게 진행한 뒤 우리가 찾는 값 t에 대해 dp[t]을 제출하니 이상없이 통과한다.<br/>


배낭 알고리즘으로 가격의 범위는 우리가 찾는 t + 1이고, 그리고 서로 다른 동전의 개수는 k개 있다.<br/>
그리고 각 동전의 개수가 ni이므로 전체 시간복잡도는 O((t + 1) x k x ∑ni) = O(t x k x ∑ni)이다.<br/>


배낭 알고리즘에서 dp의 j인덱스 부분을 역순으로 탐색하는 경우 찾는 범위 t의 크기 + 1 만큼 배열을 할당하면 된다.<br/>



## 문제 링크
https://www.acmicpc.net/problem/2624