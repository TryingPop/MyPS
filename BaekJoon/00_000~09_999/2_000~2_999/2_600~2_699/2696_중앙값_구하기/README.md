# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 자료 구조
  - 우선순위 큐

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
어떤 수열을 읽고, 홀수번째 수를 읽을 때 마다, 지금까지 입력받은 값의 중앙값을 출력하는 프로그램을 작성하시오.<br/>
예를 들어, 수열이 1, 5, 4, 3, 2 이면, 홀수번째 수는 1번째 수, 3번째 수, 5번째 수이고, 1번째 수를 읽었을 때 중앙값은 1, 3번째 수를 읽었을 때는 4, 5번째 수를 읽었을 때는 3이다.<br/>


## 입력
첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스의 첫째 줄에는 수열의 크기 M(1 ≤ M ≤ 9999, M은 홀수)이 주어지고, 그 다음 줄부터 이 수열의 원소가 차례대로 주어진다. 원소는 한 줄에 10개씩 나누어져있고, 32비트 부호있는 정수이다.<br/>


## 출력
각 테스트 케이스에 대해 첫째 줄에 출력하는 중앙값의 개수를 출력하고, 둘째 줄에는 홀수 번째 수를 읽을 때 마다 구한 중앙값을 차례대로 공백으로 구분하여 출력한다. 이때, 한 줄에 10개씩 출력해야 한다.<br/>


## 예제 입력
3<br/>
9<br/>
1 2 3 4 5 6 7 8 9<br/>
9<br/>
9 8 7 6 5 4 3 2 1<br/>
23<br/>
23 41 13 22 -3 24 -31 -11 -8 -7<br/>
3 5 103 211 -311 -45 -67 -73 -81 -99<br/>
-33 24 56<br/>


## 예제 출력
5<br/>
1 2 3 4 5<br/>
5<br/>
9 8 7 6 5<br/>
12<br/>
23 23 22 22 13 3 5 5 3 -3<br/>
-7 -3<br/>


## 풀이
원소의 입력이 주어지면서, 동시에 홀수 번째 원소마다 중앙값을 찾는 문제다.<br/>


홀수 번째 중앙값이란, 현재까지의 원소들을 오름차순 정렬했을 때 정확히 가운데에 있는 원소를 의미한다.<br/>


매번 홀수번째 원소마다 들어온 원소를 정렬해 찾을 수 있다.<br/>
이 경우 입력되는 원소의 수를 N이라 하면, 정렬 횟수는 (N + 1) // 2번이다.<br/>
여기서 a // b는 a ÷ b의 몫이다.<br/>


System 네임스페이스에 있는 Array.Sort 메소드를 이용하면 매 정렬당 N log N에 가까운 연산이 수행된다.<br/>
결국 전체 시간 복잡도는 ∑(k log k) (단, k는 N 이하의 홀수)이며, 이는 근사적으로 O(N^2 log N)에 가깝다.<br/>


예를 들어 N = 9999일 때, 1 ≤ k ≤ 9_999인 홀수 k에 대해 ∑(k log k) ≒ O(N^2 log N) ≒ 7.5억이므로 약 7.5억 번의 연산이 발생한다.<br/>
여러 테스트 케이스가 존재하므로 이 방법은 시간 초과가 날 수 있어 적절하지 않다.<br/>


중앙값은 우선순위 큐 2개를 이용하면 원하는 시점에 N log N에 빠르게 찾을 수 있다.<br/>
우선순위 큐는 사용자 정의 정렬에서 가장 앞선 원소를 O(1)에 알 수 있고, 임의의 원소 삽입과 가장 앞선 원소 제거에 각각 O(log N)의 시간이 걸린다.<br/>
그래서 다음과 같은 방법으로 중앙값을 빠르게 찾을 수 있다.<br/>


  - 큐 q1 : 오름차순 기준, 전체 원소 중 (N + 1) // 2개의 '큰 값'을 저장<br/>
  - 큐 q2 : 내림차순 기준, 전체 원소 중 N // 2개의 '작은 값'을 저장<br/>


이 구조에서 q1의 가장 앞 원소(즉, 최솟값)가 항상 중앙값이 된다.<br/>


각 우선순위 q1, q2가 해당 원소를 보관하는 방법을 보자.<br/>


먼저 임의의 원소를 넣을 때 작은 쪽인 q2에 넣는다.<br/>


q1는 (N + 1) // 2개의 원소가 되어야 하고, q2은 N // 2개의 원소가 되어야 한다.<br/>
그래서 q1의 개수는 q2의 개수보다 크거나 같아야 한다.<br/>
q1의 개수가 q2의 개수보다 작은 경우 q1에서 가장 큰 원소 즉, 가장 앞선 원소를 q2에 넣어 주면 된다.<br/>


해당 경우에서 끝내는 경우 q2에 N // 2개가 저장될거 같지만 다음과 같은 경우를 보면 안됨을 알 수 있다.<br/>
1 3을 순차적으로 넣는 상황을 보자.<br/>


  1. q2에 1을 삽입한다.
  2. q2의 개수가 q1보다 크므로 q2의 가장 큰 원소 1을 q1로 옮긴다.
  3. q1에 1이 있고, q2는 비어있다.
  4. q2에 3을 삽입한다.


그래서 결과적으로 q2에 3, q1에 1이 있다.<br/>
이는 q1이 입력된 원소들을 오름차순 정렬했을 때 큰 (N + 1) // 2원소를 포함해야 함을 만족하지 않는다.<br/>


여기서 다음 연산을 추가해주면 해결이됨을 알 수 있다.<br/>
q1과 q2의 원소가 같은 경우 서로 가장 앞에 있는 원소 e1, e2에 대해 e1 < e2인 경우만 다음 연산을 한다.<br/>
e1을 q1에서 빼고 q2에 삽입하고, e2를 q2에서 빼고 q1에 삽입하는 서로 바꿔 넣어주는 연산을 해주면 해당 문제는 해결된다.<br/>


해당 경우 매번 우선순위 큐에 값을 넣으므로 각 원소 확인마다 log N연산을 한다.<br/>
그리고 중앙값은 q2의 가장 큰 원소만 읽어주면 되기에 1번 연산에 찾을 수 있다.<br/>


원소의 개수를 N이라 하면 중앙값 확인은 (N +1) // 2번하고, 원소 삽입은 N번 한다.<br/>
따라서 각 케이스별 전체 시간복잡도는 O((N + 1) // 2 + N log N) = O(N log N)의 연산을 함을 알 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2696