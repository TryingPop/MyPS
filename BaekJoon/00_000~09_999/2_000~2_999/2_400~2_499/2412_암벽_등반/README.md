# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 자료 구조
  - 그래프 이론
  - 그래프 탐색
  - 너비 우선 탐색
  - 해시를 사용한 집합과 맵
  - 집합과 맵

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
어떤 암벽에 n(1 ≤ n ≤ 50,000)개의 홈이 파져 있다. 각각의 홈의 좌표는 (x, y)와 같이 표현되는데, |a - x| ≤ 2이고 |b - y| ≤ 2이면 (x, y)에서 (a, b)로 이동할 수 있다. 이와 같이 홈들을 이용하여 이동하면서 y = T(1 ≤ T ≤ 200,000)일 때까지, 즉 암벽의 정상까지 오르려고 한다.<br/>
현재 당신이 있는 위치는 (0, 0)이다. 이 위치에서 시작하여 이동 회수를 최소로 하면서 정상에 오르려고 한다. 정상에 오를 때의 x좌표는 아무 것이나 되어도 상관이 없다.<br/>


## 입력
첫째 줄에 n, T가 주어진다. 다음 n개의 줄에는 각 점의 x, y좌표가 주어진다. 두 좌표는 모두 0이상이며, x좌표는 1,000,000이하, y좌표는 T이하이다. 입력에 현재 위치인 (0, 0)은 주어지지 않는다.<br/>


## 출력
첫째 줄에 최소 이동 회수를 출력한다. 만약, 정상에 오를 수 없으면 -1을 출력한다.<br/>


## 예제 입력
5 3<br/>
1 2<br/>
6 3<br/>
4 1<br/>
3 2<br/>
0 2<br/>


## 예제 출력
4<br/>


## 풀이
이동이 가능한 좌표는 x와 y의 차이 중 최댓값이 2 이하인 경우다.<br/>
즉, 자기 자신을 제외하면 한 점에서 이동 가능한 좌표는 총 24개가 된다.<br/>


전체 점의 개수가 50만 개이고, 각 점마다 최대 24개의 이웃 좌표를 검사하게 되므로 총 연산량은 약 50만 × 24 = 1.2억 회 정도다.<br/>
시간 제한이 2초인 상황에서, 인접한 좌표가 존재하는지를 O(1)에 가깝게 판별할 수 있다면 BFS를 사용하는 접근이 충분히 가능하다.<br/>


이를 위해 C#의 해시 자료구조를 활용했다.<br/>
C#의 Dictionary는 평균적으로 O(1)에 가까운 탐색 성능을 제공하기 때문이다.<br/>


좌표를 저장하기 위해 다음과 같이 Dictionary<(int x, int y), int> 형태를 사용했다.<br/>
Key는 좌표 (x, y)이며, Value는 해당 좌표까지의 최소 도달 거리를 의미한다.<br/>


이 Dictionary를 통해 좌표의 존재 여부를 확인하면서, 동시에 최소 이동 횟수를 기록하는 방식으로 BFS 탐색을 수행하였다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2412