# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 그래프 이론
  - 그래프 탐색
  - 깊이 우선 탐색
  - 최단 경로
  - 플로이드-워셜

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
1번부터 N번까지 번호가 붙여져 있는 학생들에 대하여 두 학생끼리 키를 비교한 결과의 일부가 주어져 있다. 단, N명의 학생들의 키는 모두 다르다고 가정한다. 예를 들어, 6명의 학생들에 대하여 6번만 키를 비교하였고, 그 결과가 다음과 같다고 하자.<br/>

  - 1번 학생의 키 < 5번 학생의 키
  - 3번 학생의 키 < 4번 학생의 키
  - 5번 학생의 키 < 4번 학생의 키
  - 4번 학생의 키 < 2번 학생의 키
  - 4번 학생의 키 < 6번 학생의 키
  - 5번 학생의 키 < 2번 학생의 키

이 비교 결과로부터 모든 학생 중에서 키가 가장 작은 학생부터 자신이 몇 번째인지 알 수 있는 학생들도 있고 그렇지 못한 학생들도 있다는 사실을 아래처럼 그림을 그려 쉽게 확인할 수 있다. a번 학생의 키가 b번 학생의 키보다 작다면, a에서 b로 화살표를 그려서 표현하였다.<br/>
1번은 5번보다 키가 작고, 5번은 4번보다 작기 때문에, 1번은 4번보다 작게 된다. 그러면 1번, 3번, 5번은 모두 4번보다 작게 된다. 또한 4번은 2번과 6번보다 작기 때문에, 4번 학생은 자기보다 작은 학생이 3명이 있고, 자기보다 큰 학생이 2명이 있게 되어 자신의 키가 몇 번째인지 정확히 알 수 있다. 그러나 4번을 제외한 학생들은 자신의 키가 몇 번째인지 알 수 없다.<br/>
학생들의 키를 비교한 결과가 주어질 때, 자신의 키가 몇 번째인지 알 수 있는 학생들이 모두 몇 명인지 계산하여 출력하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 학생들의 수 N (2 ≤ N ≤ 500)과 두 학생 키를 비교한 횟수 M (0 ≤ M ≤ N(N-1)/2)이 주어진다.<br/>
다음 M개의 각 줄에는 두 학생의 키를 비교한 결과를 나타내는 N보다 작거나 같은 서로 다른 양의 정수 a와 b가 주어진다. 이는 번호가 a인 학생이 번호가 b인 학생보다 키가 작은 것을 의미한다.<br/>


## 출력
입력 파일 세 번째 줄에서 지정한 도착순서가 해당 사다리에서 만들어질 수 있도록 감추어진 가로 줄을 구성해야 한다.<br/>
여러분은 감추어진 가로 줄의 상태를 재구성하여 이를 ‘*’(별) 문자와 ‘-’(빼기) 문자로 구성된 길이 k-1인 문자열로 만들어 출력하면 된다.<br/>
그런데 어떤 경우에는 그 감추어진 가로 줄을 어떻게 구성해도 원하는 순서를 얻을 수 없는 경우도 있다.  이 경우에는  ‘x’(소문자 엑스)로 구성된 길이 k-1인 문자열을 출력해야 한다.<br/>


## 예제 입력
6 6<br/>
1 5<br/>
3 4<br/>
5 4<br/>
4 2<br/>
4 6<br/>
5 2<br/>


## 예제 출력
1<br/>


## 풀이
학생들의 키에 대한 비교 정보가 주어졌을 때, 각 학생이 전체 순위에서 정확히 몇 번째인지 알 수 있는지를 구하는 문제다.<br/>


a가 b보다 크고, b가 c보다 큰 경우 a는 c보다 크다가 성립한다. 즉 추이성(transitive)이 성립한다.<br/>
마찬가지로 작다 역시 추이성이 성립한다.<br/>


이러한 추이적 관계를 그래프로 표현하면, a가 b보다 크다는 정보를 단방향 간선 a → b로 나타낼 수 있다.<br/>
이 문제에서는 각 학생에 대해 자신보다 키가 큰 학생의 수와, 키가 작은 학생의 수를 모두 알 수 있는지를 판단해야 한다.<br/>
만약 한 학생이 자신보다 키가 큰 학생들과 작은 학생들의 수를 모두 알고 있고, 그 합이 전체 학생 수 N - 1과 같다면, 그 학생의 정확한 순위를 알 수 있다.<br/>


이 문제를 해결하기 위해, 먼저 "자신보다 큰 학생"에 대한 정보를 그래프로 구성했다.<br/>
플로이드 워셜(Floyd-Warshall) 알고리즘을 이용해 간접적인 비교까지 모두 포함한 경로 정보를 구한다.<br/>
그 결과, 한 학생 a가 다른 학생 b보다 크다는 관계는 fw[a][b] == 1로 나타낼 수 있다.<br/>


이후 각 학생 i에 대해 다음 두 가지를 계산한다:<br/>

  - i보다 키가 큰 학생 수: fw[i][j] == 1인 j의 수
  - i보다 키가 작은 학생 수: fw[j][i] == 1인 j의 수


이 두 수의 합이 N - 1인 경우, 해당 학생은 전체 순위에서 정확한 위치를 알 수 있다.<br/>


초기에는 "크다", "작다" 관계를 나눠 각각 두 번의 플로이드 워셜 알고리즘을 수행했다.<br/>


학생 수 N이 최대 500이므로, N^3의 알고리즘인 플로이드 워셜 알고리즘이 유효하다.<br/>
그리고 각 사람에대해 자기보다 큰 사람, 작은 사람을 확인하는데는 N^2의 연산이 필용하다.<br/>
그래서 전체 시간 복잡도는 O(N^3 + N^2) = O(N^3)이 된다.<br/>


a, b사람에 대해 크다 관계를 2차원 배열에 저장하므로 메모리역시 N^2을 사용한다.<br/>


초기에는 크다, 작다에 관해 총 2번 플로이드 워셜을 실행했다.<br/>
chat gpt를 통해 검토해본 결과 작은 경우는 할 필요가 없다고 조언을 받았고, 이는 타당한 접근이었다.<br/>
a가 b보다 큰 경우 2차원 배열 fw에 fw[a][b] = 1이라 담으면 플로이드 워셜을 진행한 뒤 i가 j보다 큰 경우의 확인을 fw[i][j] > 0인지로 확인한다.<br/>
그리고 i가 j보다 작은지는 j가 i보다 크다와 같고 fw[j][i]로 확인이 가능하기 때문이다.<br/>


그래서 해당 부분을 수정하니 속도가 2배 빨랐다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/2458