# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 그래프 이론
  - 그래프 탐색
  - 너비 우선 탐색
  - 역추적

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
폴란드 왕자 구사과는 다음과 같은 수를 좋아한다.<br/>

  - 0과 1로만 이루어져 있어야 한다.
  - 1이 적어도 하나 있어야 한다.
  - 수의 길이가 100 이하이다.
  - 수가 0으로 시작하지 않는다.

예를 들어, 101은 구사과가 좋아하는 수이다.<br/>
자연수 N이 주어졌을 때, N의 배수 중에서 구사과가 좋아하는 수를 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 테스트 케이스의 개수 T(T < 10)가 주어진다.<br/>
둘째 줄부터 T개의 줄에는 자연수 N이 한 줄에 하나씩 주어진다. N은 20,000보다 작거나 같은 자연수이다.<br/>


## 출력
각각의 테스트 케이스마다 N의 배수이면서, 구사과가 좋아하는 수를 아무거나 출력한다. 만약, 그러한 수가 없다면 BRAK을 출력한다.<br/>


## 예제 입력
6<br/>
17<br/>
11011<br/>
17<br/>
999<br/>
125<br/>
173<br/>


## 예제 출력
11101<br/>
11011<br/>
11101<br/>
111111111111111111111111111<br/>
1000<br/>
1011001101<br/>


## 풀이
BFS 방법으로 해결했다.<br/>
먼저 1에 대해 n이 해당 값을 나누는지 확인한다.<br/>
나누는 경우 해당 값을 반환한다.<br/>


나누지 않는다면 이전 값을 10배한 뒤 뒤에 0, 1을 뒤에 이어 붙인다.<br/>
나누는 값을 확인하기에 n으로 나머지 연산을 한다.<br/>
만약 해당 나머지 값을 이미 확인했다면 다시 확인하지 않는다.<br/>
그리고 나머지가 0인지 확인해 n을 나누는지 확인한다.<br/>
나누는 경우 해당 경우를 반환하면 된다.<br/>


반면 나누지 않는다면 다시 10배한 뒤 0, 1을 각각 더하고 n으로 나머지 연산을 한다.<br/>
나머지가 이미 확인했다면 진행하지 않고 확인하지 않았다면 계속해서 진행해간다.<br/>
이렇게 100번 이어 붙였음에도 답이 안나오는경우 정답이 존재하지 않는다고 판단한다.<br/>
반면 존재하는 경우 해당 경로를 따라 정답을 찾으면 된다.<br/>


정답을 찾는 것은 만약 a에서 b로 온다면 a에서 b를 기록해 이전 값을 확인한다.<br/>
그리고 이전 값과 현재 값의 관계 b = a * 10 + 0 인지 b = a * 10 + 1인지 통해 0을 붙였는지 1을 붙였는지 확인할 수 있다.<br/>


이렇게 끝에 붙인 값을 찾아갈 수 있다.<br/>
런타임 전 1 부터 2만까지 해본 결과 모두 100자리 이하로 표현된다.<br/>


그리고 길이 제한이 없다면 언제나 해가 존재함을 알 수 있다.<br/>
2와 5의 약수를 소인수로 포함하지 않는다면 n을 나누는 1로만 이루어진 수가 존재함을 확인했었다. [1612_가지고_노는_1](https://github.com/TryingPop/MyPS/tree/main/BaekJoon/00_000~09_999/1_000~1_999/1_600~1_699/1612_%EA%B0%80%EC%A7%80%EA%B3%A0_%EB%85%B8%EB%8A%94_1)<br/>
2와 5의 약수를 소인수로 포함한다면 2와 5를 제외한 나머지 소인수를 나누는 1로만 이루어진 수를 찾고 2와 5의 소인수 중 많은 갯수를 p라하면 1로만 이루어진 수 뒤에 0을 p개 붙이면 모든 수 n에 대해 n을 약수로하는 1, 0으로 이루어진 수가 존재함을 알 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/8111