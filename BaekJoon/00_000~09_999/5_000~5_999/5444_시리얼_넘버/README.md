# C#

## 난이도 : 골드 1

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 배낭 문제
  - 슬라이딩 윈도우

## 제한조건
  - 시간 제한 : 3초
  - 메모리 제한 : 128 MB

## 문제
위대한 기타리스트 강토는 공연을 앞두고 있다. 이제 무대에 올라가야 하는데, 기타가 다른 사람들의 기타와 섞이고 말았다. 또, 강토는 어떤 기타가 자기 것인지 까먹었다.<br/>
다행히도, 모든 기타는 유니크한 시리얼 넘버를 가지고 있으며, 각 시리얼 넘버는 1보다 크거나 같고, 100,000보다 작거나 같은 정수이다. 강토는 자신이 가지고 있는 기타의 시리얼 넘버를 모두 다 합하면 M의 배수가 된다는 것을 알 수 있다.<br/>
모든 기타의 시리얼 넘버와 M이 주어졌을 때, 가능한 강토의 기타 개수 중 최댓값을 구하는 프로그램을 작성하시오.<br/>

## 입력
첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 다음과 같은 형식이다.<br/>
  - 기타의 개수 N과 M이 주어진다. (1 ≤ N ≤ 500, 1 ≤ M ≤ 100,000)
  - 기타의 시리얼 넘버 S1 ... SN이 주어진다. (0 ≤ Si ≤ 100,000)

## 출력
각각의 테스트 케이스마다 시리얼 넘버의 합이 M의 배수가 되는 기타의 개수 중에서 최댓값을 출력한다.<br/>
항상 답이 존재하는 경우만 입력으로 주어진다.<br/>


## 예제 입력
2<br/>
3 5<br/>
1 8 6<br/>
6 9<br/>
8 6 4 1 2 3<br/>

## 예제 출력
3<br/>
5<br/>


## 풀이
기타의 개수는 최대 500개 이고, 나눌 무게 값은 100,000이다.<br/>
그래서 배낭 형식으로 접근하면 500 x 100,000 = 50,000,000 경우의 수이다.<br/>


시간 제한도 3초에 질문게시판에 테스트 케이스 질문글을 보니 배낭도 접근했다.<br/>
질문글 링크 : https://www.acmicpc.net/board/view/94144<br/>


예제의 첫 번째 경우로 어떻게 풀었는지 확인해 보자.<br/>
기타는 3개 나누는 값은 5이다.<br/>
dp를 무게별로 담을 수 있는 기타의 최대 개수라 하자. m의 배수를 찾으므로 m 나머지로 찾아도 충분하다.<br/>
무게 0에 기타 0개가 있다, 이외는 불가능한 경우다. 확인안된 경우나 불가능한 경우를 나타내는 -1로 채운다.<br/>
그러면 초기 무게별 기타 갯수는 다음과 같다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|0|-1|-1|-1|-1|

1번 무게 1인 기타를 보면, 가능한건 무게 0에 0인거 뿐이므로 채워지는 무게는 0 + 1이고, 개수는 1개이다.<br/>
불가능한 경우에서 가능한 경우로 바뀌게 되고 새롭게 1이 채워진다. 다음과 같다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|-1|1|-1|-1|-1|

이전 0개는 0으로 가능했으므로 0에 0 값을 갱신해준다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|0|1|-1|-1|-1|

기타 1번을 선택하고 나면 무게 0에 0개, 무게 1에 1개 있다는 의미다!<br/>


2번 무게 8인 기타를 선택한다. 가능한건 무게 0에 0개, 무게 1에 1개인 경우다.<br/>
무게 0인 경우 개수는 0이고 채우면 무게 3 = (0 + 8) % 5이고 불가능한 경우에서 가능한 경우로 바뀌고 1이 채워진다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|-1|-1|-1|1|-1|

그리고 1인 경우에한해서도 채워질 수 있다.<br/>
그러면 무게는 4 = (1 + 8) % 5이고, 기타 개수는 2개이다. 불가능한 경우에서 가능한 경우로 바뀌므로 2개가 채워진다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|-1|-1|-1|1|2|

앞번 경우에서 0은 0개, 1은 1개로 유효하므로 유효한 값으로 채운다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|0|1|-1|1|2|

2개를 선택한 상태는 무게별로 최대 기타의 개수를 찾아보면,<br/>
무게 0에 0개, 무게 1에 1개, 무게 2는 불가능한 경우, 무게 3은 1개, 무게 4는 2개를 의미한다.<br/>

3번 무게 6인 기타를 선택한다. 가능한 무게는 0, 1, 3, 4인 경우를 확인하면 된다.<br/>
무게 0의 경우 1 = (0 + 6) % 5에 채울려고 시도하면 1개가 된다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|-1|1|-1|-1|-1|

무게 1의 경우 2 = (1 + 6) % 5에 채울려고 시도하면 2개가 된다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|-1|1|2|-1|-1|

무게 3의 경우 4 = (3 + 6)% 5에 채울려고 시도하면 2개가 된다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|-1|1|2|-1|2|

무게 4의 경우 0 = (4 + 6) % 5에 채울려고 시도하면 3개가 된다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|3|1|2|-1|2|

기존에 무게 0에 0개, 무게 1에 1개, 무게 3에 1개, 무게 4에 2개가 있다.<br/>
그래서 무게 3 부분은 1로 채워진다.<br/>

|무게|0|1|2|3|4|
|:---:|:---:|:---:|:---:|:---:|:---:|
|기타의 개수|3|1|2|1|2|

그러면 기타 3개를 확인했을 때 최종 결과 표는 위와 같다.<br/>
이 중 m으로 나눠 떨어지는 기타의 최대 개수는 3개이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/5444