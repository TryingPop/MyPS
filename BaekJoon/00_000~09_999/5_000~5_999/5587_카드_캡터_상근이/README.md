# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 구현
  - 시뮬레이션

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
다음과 같은 카드게임이 BOJ 학교에서 유행하고 있다.<br/>

  - 1에서 2n까지의 정수가 쓰여진 총 2n개의 카드를 사용한다.
  - 카드를 2명이 n장씩 나눠가진다.
  - 다음 규칙에 따라 교대로 카드를 1장씩 낸다.
    - 놓여진 카드가 없다면 원하는 카드를 낼 수 있다.
    - 놓여진 카드가 있다면 마지막에 나온 카드보다 큰 숫자가 적힌 카드를 낼 수 있다.
    - 낼 카드가 없는 경우 상대의 차례가 된다. 이때, 자리에 나와있는 카드는 없어진다.
  - 게임은 카드가 아무 것도 놓여있지 않은 상태에서 시작한다.
  - 둘 중 한 명이라도 카드를 모두 사용하면 게임이 종료된다.
  - 게임 종료시 상대방이 가지고 있는 카드의 수를 점수로 획득한다.

상근이와 근상이는 이 게임에서 맞붙게 됐다. 게임은 상근이의 차례에서 시작하며, 두 사람은 각자 낼 수 있는 카드 중 반드시 가장 작은 숫자가 적힌 카드를 내기로 하였다. 카드 캡터인 상근이는 게임의 결과를 미리 예상해서 질 것 같은 게임은 피하려고 한다. 배부되는 카드가 주어졌을 때, 상근이와 근상이의 점수를 출력하는 프로그램을 작성하자.<br/>


## 입력
1번째 줄에는 n이 주어진다. (1 ≤ n ≤ 100)<br/>
이후 n개의 줄에 상근이에게 주어지는 각 카드에 적힌 수가 주어진다. 즉, 1~2n중 나머지 카드는 근상이에게 주어진다.<br/>


## 출력
첫째 줄에 상근이의 결혼식에 초대하는 동기의 수를 출력한다.<br/>


## 예제 입력
5<br/>
1<br/>
7<br/>
9<br/>
6<br/>
10<br/>


## 예제 출력
3<br/>
0<br/>


## 풀이
n의 범위가 100정도로 매우 작다.<br/>
그리고 사용한 숫자는 다시 사용하지 않으므로 많아야 100번의 턴 교환이 이뤄진다.<br/>
그리고 매번 내는 것을 찾는데 일일히 브루트포스로 찾아도 50을 넘지 않는다.<br/>
이에 시뮬레이션 해도 5000번의 연산이므로 유효하다.<br/>
그래서 문제 상황을 시뮬레이션 돌려 점수를 찾았다.<br/>


여기서는 갖고 있는 카드를 정렬한 뒤 한칸씩 이동하며 찾는 방법으로 구현했다.<br/>
만약 n이 크다면 세그먼트 트리를 썼을 것이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/5587