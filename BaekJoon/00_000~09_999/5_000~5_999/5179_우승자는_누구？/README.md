# C#

## 난이도 : 실버 2

## 알고리즘 분류
  - 구현
  - 정렬

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
대회가 끝이 나면 대부분의 참가자들은 어디서 꼬였는지에 대한 원망과 함께 좌절하게 된다.<br/>
심사위원들 또한 좌절한다. 제출 기록에 따라 각 참가자에게 점수를 매기고 순위를 산정해야 하기 때문이다.<br/>
비록 대회는 끝이 났지만 아직 코딩할 여력이 있다면, 심사위원들을 도울 순위 산정 프로그램을 만들어보자.<br/>


## 입력
첫 줄에 테스트 케이스의 수 K가 주어진다.<br/>
각 테스트 케이스의 첫 줄엔 세 개의 정수 M, N, P가 주어진다.<br/>
M은 대회에 사용된 문제의 개수이며 (1 ≤ M ≤ 10), N은 총 제출 수 (1 ≤ N ≤ 5000),<br/>
P는 참가자의 수 (1 ≤ P ≤ 500) 이다.<br/>
각 문제는 A, B, ... 로 이름붙여져 있으며, 참가자들은 1부터 P까지의 아이디를 갖는다.<br/>
이어 N개의 줄에 걸쳐 제출 기록의 내용이 주어진다.<br/>
제출 기록은 p m t j의 형식이며, p는 제출한 참가자(1, 2, ...) , m은 문제 번호(A, B, ..), t는 제출한 시각, j는 정답 여부이다.<br/>
j=0이라면 오답이며, j=1일 경우엔 정답이다.<br/>
제출 기록은 제출 시각이 감소하지 않는 순으로 주어진다.<br/>
문제를 맞힐 경우, 맞힌 사람은 총점에 문제를 맞힌 시각 + 그 문제를 틀린 횟수*20만큼을 더하게 된다.<br/>
만일 동일한 문제를 두 번 이상 맞히더라도 처음 맞힌 것만 인정된다.<br/>


## 출력
각 테스트 케이스마다 Data Set K: 를 출력한 뒤, 참가자들의 아이디, 푼 문제 수, 총점을 P줄에 걸쳐 1위부터 차례대로 출력한다.<br/>
순위는 푼 문제 수가 다르다면 푼 문제 수가 많은 사람이 높으며,<br/>
푼 문제 수가 같다면 총점이 낮은 사람이 순위가 높다.<br/>
어떤 테스트 케이스에서도 동점자가 나오는 경우는 없다.<br/>
각 테스트 케이스의 사이엔 빈 줄을 하나 출력한다.<br/>


## 예제 입력
2<br/>
4 6 3<br/>
2 C 11 0<br/>
1 B 24 1<br/>
2 C 25 1<br/>
1 C 40 0<br/>
3 D 55 1<br/>
2 B 55 1<br/>
2 8 2<br/>
1 A 8 0<br/>
2 B 11 1<br/>
1 A 11 0<br/>
1 A 14 0<br/>
1 A 20 0<br/>
2 B 22 1<br/>
2 A 23 0<br/>
1 A 24 1<br/>


## 예제 출력
Data Set 1:<br/>
2 2 100<br/>
1 1 24<br/>
3 1 55<br/>
<br/>
Data Set 2:<br/>
2 1 11<br/>
1 1 104<br/>

## 풀이
C#에서 제공하는 ValueTuple의 Generic을 이용해 참가자를 표현했다.<br/>
ValueTuple에는 해당 문제의 시도횟수, 그리고 점수, 푼 문제 수를 저장했다.<br/>
기존 사람 번호도 저장해줘야 하나 시도 횟수는 점수 계산이 끝나면 사용이 안되어 0번 시도횟수에 기존 사람 번호를 저장했다.<br/>
이후에 점수계산이 끝나면 조건에 맞추어 정렬했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/5179