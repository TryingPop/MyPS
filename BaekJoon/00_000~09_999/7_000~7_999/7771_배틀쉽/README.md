# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 해 구성하기

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
당신은 정보 보안 회사의 직원이다. 최근 당신의 한 고객이 새로운 프로그램을 개발했는데, 이 프로그램은 사용 대상이 사람인지 프로그램인지의 여부를 판정해준다. 당신의 임무는 이 프로그램의 효율성을 테스트하는 것이다.<br/>
테스트는 유명 보드게임 '배틀쉽' 의 변형판을 이용한다. 이 게임은 10 * 10 크기로 나눠진 격자판 보드에서 진행된다. 게임을 시작하기 전, 당신은 한 칸 크기의 전함 4척, 두 칸 크기의 전함 3척, 세 칸 크기의 전함 2척, 네 칸 크기의 전함 1척, 총 10척의 우주 전함을 보드 위에 배치해야 한다. 각 전함은 수직 혹은 수평으로 이어진 칸들의 연속된 집합 위에 놓을 수 있다. 어떤 두 전함도 좌우, 상하, 대각선으로 인접할 수 없으며, 당연히 어떤 칸을 공유할 수도 없다.<br/>
보드를 세팅한 뒤, 몇 라운드를 거쳐 테스트를 진행하게 된다. 각 라운드에서 단 하나의 칸을 마음대로 골라 그 칸을 향해 발포할 수 있고, 만일 어떤 전함이 놓인 모든 칸에 한 번 이상의 타격을 입었다면 그 전함은 침몰하게 된다. 모든 전함이 침몰한 뒤에 게임은 끝난다.<br/>
당신은 이 게임의 '복잡도' 를 게임이 끝나기까지 진행된 라운드의 수로 정의하고, 만일 사람이 게임을 진행한다면 프로그램이 진행할 때보다 게임이 더 복잡해질 것이라고 가정하여 테스트를 진행하기로 했다.<br/>
당신은 이미 어떤 칸을 향해 발포할지 정해 두었다. 이 목록에선 같은 칸에 두 번 발포하지 않는다. 이제 당신은 게임을 가능한 한 가장 복잡하게 만드는 보드의 초기 상태를 구하는 프로그램을 작성하면 된다.<br/>


## 입력
열 개의 정수가 열 개의 줄에 걸쳐 입력된다.<br/>
각각의 정수는 몇 번째 순서로 그 칸에 발포할지를 나타내며, 1 이상 100 이하의 값을 갖는다.<br/>


## 출력
게임을 가장 오래 가게 만드는 보드의 초기 상태를 열 줄에 걸쳐 출력한다.<br/>
빈 칸엔 '.'을, 전함이 놓인 자리엔 '#'을 출력하면 된다.<br/>


## 예제 입력
1 2 3 4 5 6 7 8 9 10<br/>
36 37 38 39 40 41 42 43 44 11<br/>
35 64 65 66 67 68 69 70 45 12<br/>
34 63 84 85 86 87 88 71 46 13<br/>
33 62 83 96 97 98 89 72 47 14<br/>
32 61 82 95 100 99 90 73 48 15<br/>
31 60 81 94 93 92 91 74 49 16<br/>
30 59 80 79 78 77 76 75 50 17<br/>
29 58 57 56 55 54 53 52 51 18<br/>
28 27 26 25 24 23 22 21 20 19<br/>


## 예제 출력
\.\.\.\#\#\#\#\.\.\.<br/>
\.\.\.\.\.\.\.\.\.\.<br/>
\#\.\.\.\.\#\#\.\.\.<br/>
\#\.\#\.\.\.\.\.\#\.<br/>
\.\.\.\.\.\.\.\.\#\.<br/>
\.\.\.\#\#\#\.\.\.\.<br/>
\.\#\.\.\.\.\.\.\.\.<br/>
\.\.\.\.\.\.\.\.\#\.<br/>
\.\.\#\.\.\.\.\.\#\.<br/>
\.\.\.\.\.\#\.\.\#\.<br/>


## 풀이
만약 복잡도 100에 배가 있다면 모든 칸에 타격을 입어야 배가 침몰하기에 100라운드에 끝나고 이는 복잡도가 100이다.<br/>
반면 복잡도가 100에 배가 없다면 100전에 모두 침몰했으므로 복잡도는 100미만이다.<br/>
그래서 복잡도가 최대가 되는것은 100의 자리에 배가 있는 경우와 일치한다.<br/>


이제 100이 위치한 행과 열을 찾는다.<br/>
해당 장소를 최대한 채울건데 4칸짜리 전함 1개, 2칸짜리 전함 2개로 채울 생각이다.<br/>
100짜리 열이 어디에 있던 다음 두 형태로 표현이 가능하다.<br/>


	##.##.####
	####.##.##


편의상 위를 기본으로 3열과 6열이 빈 경우를 확인해 비었다면 아래, 아니면 위에 형태로 배치했다.<br/>


그리고 다음과 같이 배치하면 2행으로 끝낼 수 있다.<br/>
3칸짜리 전함 2개, 2칸짜리 전함 1개로 10개가 딱 맞다.<br/>
그리고 나머지인 1칸짜리 전함 4개이다.<br/>


	###.###.##
	#.#.#.#...


이제 이 행들을 행과, 대각선 인접하지 않게 배치해야 한다.<br/>
이는 행만 인접하지 않게 배치해도 된다.<br/>


만약 100 짜리 행이 위에서 5번째 줄 이하인 경우<br/>
100이 있는 행에만 4칸짜리 전함 1개, 2칸짜리 전함 2개로 채운다.<br/>
이제 7번째 행에 3칸짜리 전함 2개, 2칸짜리 전함 1개를 채운다.<br/>
마지막으로 9번째 행에 1칸짜리 전함 4개를 채우면 문제 조건을 모두 만족한다.<br/>


반면 100 짜리 행이 위에서 6번째 줄 이상인 경우<br/>
100이 있는 행에만 4칸짜리 전함 1개, 2칸짜리 전함 2개로 채운다.<br/>
이제 2번째 행에 3칸짜리 전함 2개, 2칸짜리 전함 1개를 채운다.<br/>
마지막으로 4번째 행에 1칸짜리 전함 4개를 채우면 문제 조건을 모두 만족한다.<br/>


이렇게 두 가지로 나눠서 하니 이상없이 통과한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/7771