# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 그리디 알고리즘
  - 정렬

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
아 과제 하기 싫다. 아무 것도 안 하고 싶다. 더 적극적이고 격렬하게 아무 것도 안 하고 싶다.<br/>
있잖아. 내가 아까 책상에다가 n개의 과제 목록을 적어놨어. 각각의 과제 i는 di 일이 걸리고, 오늘로부터 ti 일 안에 끝내야 해. 그러니까 오늘이 0일이면, ti일이 끝나기 전에 제출이야. 과제는 한번 시작하면 쉬지 않고 계속해야 해. 안 그러면 머리 아파 지거든.<br/>
근데 있잖아. 내가 지금 너무, 너무 아무 것도 안 하고 싶어. 그래서 오늘은 아무 것도 안 할 거야. 더 중요한 게 뭔지 알아? 사실 나 내일도, 모레도, 아무 것도 안 하고 싶어. 한 며칠 동안은 계속 아무 것도 안하려고. 아. 과제가 있을 때 내가 내일부터 연속으로 최대 며칠동안 놀 수 있는지 궁금하다. 궁금하긴 한데, 난 아무 것도 안 하고 싶어.<br/>
좋은 생각이 났다. 너희가 이걸 대신 구해주면, 내가 너희의 맞은 문제 수를 하나 올려줄게.<br/>


## 입력
첫째 줄에는 과제의 개수인 정수 n (1 ≤ n ≤ 106)이 주어진다.<br/>
이후 n개의 줄에 각각의 과제를 나타내는 두 정수 di, ti (1 ≤ di, ti ≤ 109)가 순서대로 주어진다. 오늘은 0일이다.<br/>
모든 입력에 대해, 오늘 아무 것도 안 해도 과제를 마무리 할 수 있는 방법이 존재함이 보장된다.<br/>


## 출력
내일(1일)부터 연속으로 최대 며칠 동안 놀 수 있는지를 출력한다. 가령, 답이 0이면, 내일 과제를 해야 하며, 1 이면, 모레에 과제를 해야 한다.<br/>


## 예제 입력
3<br/>
2 8<br/>
1 13<br/>
3 10<br/>


## 예제 출력
5<br/>


## 풀이
오늘 아무일도 안해도 과제를 마무리할 수 있는 방법이 존재한다고 한다.<br/>
일을 마감 시간에 맞춰 끝내게 일을 시작해도 뒷일들을 모두 처리할 수 있음을 뜻한다.<br/>


그리고 최대 쉴 수 있는 중간 텀은 이전 일과 현재일 사이에 쉴 수 있는 텀과 같다.<br/>
그래서 일이 끝나는 시간으로 오름차순 정렬한다.<br/>
이후 일을 최대한 빨리 시작하고, 일을 최대한 늦게 시작할 때의 텀을 계산한다.<br/>
해당 텀이 두 일 사이에 최대한 쉴 수 있는 시간이다.<br/>
그리디로 해당 방법으로 찾아간 최대한 쉴 수 있는 시간이 정답이 보장된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/7983