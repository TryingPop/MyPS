# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 수학
  - 정수론
  - 소수 판정
  - 에라토스테네스의 체

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
두 수의 최대공약수는 두 수를 나머지 없이 나눌 수 있는 가장 큰 자연수로 정의한다. 예를 들어, 8과 12의 최대공약수는 GCD(8,12)로 나타내고, 그 값은 4이다. 4는 8과 12를 나눌 수 있는 가장 큰 정수이기 때문이다. (8과 12의 공약수는 1, 2, 4가 있다)<br/>
자연수의 팩토리얼은 그 수보다 작거나 같은 모든 양의 정수의 곱이다. 예를 들어, 5의 팩토리얼은 5!로 나타내고 1*2*3*4*5 = 120이다. (0!은 1로 정한다)<br/>
두 수 n과 k가 주어졌을 때, n!과 k의 최대공약수를 구하는 프로그램을 작성하시오. 예를 들어, n = 3, k = 10이라면, GCD(n!,k) = GCD(3!,10) = GCD(1*2*3,10) = GCD(6,10) = 2가 된다.<br/>


## 입력
각 줄에 n과 k가 하나씩 주어진다. (0 ≤ n ≤ 1,000,000,000, 1 ≤ k ≤ 1,000,000,000)<br/>


## 출력
입력의 각 줄에 대해서, n!과 k의 최대공약수를 출력한다.<br/>


## 예제 입력
3 10<br/>
10 240<br/>
12 364<br/>
100 2351<br/>
629 163547<br/>


## 예제 출력
2<br/>
240<br/>
28<br/>
1<br/>
67<br/>


## 풀이
소인수 분해를 이용해 최대 공약수를 찾았다.<br/>


k의 소인수 분해한다. k = p1^i1 * p2^i2 * ... pj * ij라하자.<br/>
이제 n!을 소인수 분해 했을 때 pm 소인수로 얼마나 있는지 확인한다.<br/>
이들 중 작은 값을 곱하면서 최대 공약수를 찾을 수 있다.<br/>


먼저 k의 소인수는 2부터 √k의 수들로 직접 나누면서 소인수를 찾으면 된다.<br/>
여기서는 여러 테스트케이스가 있으므로 매번 2부터 √k를 카운팅하기에는 합성수가 많다고 생각했다.<br/>


그래서 k가 10억까지오므로 제곱해서 10억을 넘지 않는 소수를 에라토스테네스의 체로 먼저 찾은 뒤 기록했다.<br/>
찾아보니 3401개가 존재했고 해당 3401개를 비교하면서 k의 소인수와 갯수를 찾았다.<br/>


이제 n!에 해당 수의 p 소인수의 갯수 확인은 다음과 같다.<br/>


먼저 1, 2, ..., n에 대해 p의 소인수 갯수를 찾았다.<br/>
그러면 p, 2p, .., ip에 각각 p가 소인수로 적어도 1개 존재한다. 여기서 i는 ip ≤ n인 가장 큰 값이다.<br/>
이를 세어주면 i = n // p개가 된다. 여기서 // 는 나눗셈 연산인데 소숫점이 있으면 버리는 연산이다.<br/>


p^2의 경우 p의 소인수로 2개 포함하고 있다.<br/>
그래서 1, 2, ..., n에 p^2, 2p^2, ..., jp^2에 각각 p의 소인수가 적어도 2개 존재한다.<br/>
그리고 p^2은 p, 2p, .., 에서 1개를 세었으므로 여기서도 1개를 세면 된다.<br/>
그래서 여기서 센 n // p^2을 더해주면 된다.<br/>


이렇게 계속해서 p^m승까지 올려주면서 찾으면 된다.<br/>
내림 연산이므로 어느 순간 n // p^m = 0인 m이 존재하고 n // p^(m+1) = 0 이므로 m까지만 찾아주면 된다.<br/>


이렇게 n!에 포함된 소인수 p의 갯수를 n // p + n // (p^2) + ... + n // (p^k) + ...로 찾아 줬다.<br/>


그리고 소인수 중 작은 것을 결과에 곱해가며 정답을 찾으면 된다.<br/>
다만 k의 소인수를 찾을 때 3401개와 비교해서 나눠떨어지지 않는다면 남은 k는 소수이다.<br/>
그리고 k ≤ n인 경우 남은 것을 곱해주기만 하면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/7806