# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
믿기 힘들겠지만 상근이는 이번 겨울 방학에 달에 갔다 왔다. 방학이 끝나고 다시 학교로 돌아온 상근이는 친구들에게 달나라 사람(Selenites)을 만났던 이야기를 해주었다.<br/>
상근이는 달에서 사용하는 수 체계를 주로 설명해주었다. 달에서는 음의 진법을 사용한다.<br/>
음의 진법은 사람들이 이해하기는 어렵다. 따라서, 상근이는 달을 여행하는 동안 0과 n을 포함하는 사이의 수 중에서 k진법과 -k진법에서 표현이 같은 수를 모두 외웠다. 상근이가 외운 숫자의 개수를 구하는 프로그램을 작성하시오.<br/>
x의 k진법 표현은 0 ≤ a_i < |k|), (∑_{i = 0} ^ {p} {a_i x k^i} = x)를 만족하는 수열 a_0, a_1, ..., a_p이다.<br/>


## 입력
첫째 줄에 n과 k가 주어진다. (1 ≤ n ≤ 10^15, 2 ≤ k ≤ 1,000)<br/>


## 출력
첫째 줄에 상근이가 달에서 생활하면서 외운 숫자의 개수를 출력한다.<br/>


## 예제 입력
21 3<br/>


## 예제 출력
9<br/>


## 힌트
상근이는 0, 1, 2, 9, 10, 11, 18, 19, 20을 외웠다.<br/>
19는 3진법과 -3진법에서 19 = 201(3) = 201(-3) 으로 표현이 같다. 하지만, 7은 7 = 21(3) = 111(-3) 으로 같지 않다.<br/>


## 풀이
힌트에서 7 = 111(-3)을 보듯이 양수의 진법 변환은 항상 양이되게 진법을 변환해야 함을 확인할 수 있다.<br/>
실제로 7 = -(-7) = -(-27 + 18 + 2) = -1202(-3)으로도 표현할 수 있다.<br/>


수 m이 있는데 k진법으로 표현한 값이 -k진법으로 표현한 값과 같다고 하자.<br/>
즉, m = a_pa_(p-1)...a_0(k) = a_pa_(p-1)...a_0(-k)이라 하자.<br/>


그러면 0 = m - m = ((a_0) x k^0 + (a_1) x k^1 + ... + (a_p) x k^p) - ((a_0) x (-k)^0 + (a_1) x (-k)^2 + ... + (a_p) x (-k)^p)이 성립한다.<br/>
이제 여기서 짝수항의 값은 같으므로 2i를 p보다 작거나 같은 가장 큰 짝수라 하자.<br/>
a_0 x k^0 + a_2 x k^2 + ... + a_2i x k^(2i) = a_0 x (-k)^0 + a_2 x (-k)^2 + ... + a_2i x (-k)^(2i)이므로 다음을 얻는다.<br/>
그러면 a_1 x k^1 + a_3 x k^3 + ... = a_1 x (-k)^1 + a_3 x (-k)^3 + ...<br/>
이는 a_1, a_3, 이 모두 0과 동치이다.<br/>


따라서 홀수항이 모두 0이어야 m을 k진법으로 바꿨을 때 수열과 -k진법으로 바꿨을 때 수열이 같음을 확인할 수 있다.<br/>
이제 n이하이면서 k진법으로 바꿨을 때 짝수항으로만 이루어진 숫자를 찾아야 한다.<br/>


먼저 n을 k진법으로 나타냈을 때 n = a_pa_(p-1)...a_0(k)라 하자.<br/>
만약 p가 홀수라면 2i + 1 = p라 하자 각 자리에 k개씩 올 수 있으므로 짝수항으로 이루어진 n이하의 수의 갯수는 k^i임을 알 수 있다.<br/>


반면 p가 짝수라면 2i = p라 하자.<br/>
그러면 가장 큰 자릿수부터 가능한 경우를 찾아가면 된다.<br/>
a_p > 0 이므로 a_(p-2), a_(p-4), ..., a_0에 들어갈 수 있는 갯수는 k^(i-1)이 된다.<br/>
그래서 정답에 k^(i-1)을 누적하고 a_p의 값을 1 빼준다.<br/>
앞의 방법을 실행했음에도 a_p > 0이라면 a_(p-2), a_(p-4), ..., a_0에 들어갈 수 있는 갯수는 k^(i-1)이 된다.<br/>
다시 정답에 k^(i-1)을 누적하고 a_p의 값을 1 빼준다.<br/>
이렇게 a_p가 0이될때까지 반복한다.<br/>


다음으로 a_(p-1)를 확인한다. p-1은 홀수이다.<br/>
a_(p-1) > 0이면 a_(p-2), a_(p-4), ..., a_0에 들어갈 수 있는 갯수는 k^(i-1)이 된다.<br/>
정답에 k^(i-1)을 누적하고 종료한다.<br/>
반면 a_(p-1)이 0이라면 a_(p-2)를 조사한다.<br/>


p-2는 짝수이므로 a_(p-2) > 0이면 a_(p-4), a_(p-6), ..., a_0에 들어갈 수 있는 갯수는 k^(i-2)이 된다.<br/>
정답에 k^(i-2)를 누적하고 a_(p-2)의 값을 1빼준다.<br/>
앞의 방법을 실행했음에도 a_(p-2) > 0이면 앞과 같이 연산을 a_(p-2) = 0이될 때까지 계속한다.<br/>


그리고 a_(p-3)을 확인한다. p-3은 홀수이므로 a_(p-3) > 0이면 a_(p-4), a_(p-6), ..., a_0에 들어갈 수 있는 갯수는 k^(i-2)이 된다.<br/>
정답에 k^(i-2)를 누적하고 종료한다.,br/>
반면 a_(p-3)이 0이라면 a_(p-4)를 조사한다.<br/>


이렇게 탈출하기 전까지 항의 값을 1씩 줄여가면서 진행하면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/3996