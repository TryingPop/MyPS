# C#

## 난이도 : 플레티넘 4

## 알고리즘 분류
  - 그래프 이론
  - 최단 경로
  - 벨만-포드

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
오늘은 할로윈이다. 상근이와 친구들은 할로윈을 기념하기 위해 묘지를 방문했다. 상근이와 친구들은 한 명씩 묘지로 들어가고, 혼자서 묘지의 출구를 찾아야 한다. 이제, 상근이의 차례가 돌아왔다.<br/>
상근이가 어렸을 적에 할머니는 상근이에게 할로윈 밤에 묘지에는 귀신 구멍이 나타난다고 말해주었다. 귀신 구멍으로 들어가면, 묘지의 다른 장소로 다시 나오게 된다. 이 구멍은 시간을 이동할 수 있는 구멍이다. 귀신 구멍에 떨어지면, 특정 시간이 지난 후(또는 이전)에 평행 우주의 다른 구멍에서 나오게 된다.<br/>
묘지는 W × H 크기의 그리드로 나타낼 수 있다. 묘지의 입구는 (0, 0)이고, 출구는 (W-1, H-1)이다. 상근이는 겁이 많기 때문에, 최대한 빨리 묘지를 나가려고 한다. 그리고 상근이는 이동하던 도중 출구에 도달하면 뒤도 돌아보지 않고 그 즉시 묘지를 빠져나갈 생각이다. 상근이는 현재 있는 칸과 동, 서, 남, 북으로 인접한 칸으로 이동할 수 있다. 각 칸은 잔디, 묘비, 또는 귀신 구멍이다.<br/>

  - 묘비는 매우 높기 때문에, 묘비가 있는 칸으로는 이동할 수 없다.
  - 귀신 구멍이 있는 칸으로 이동하면, 특정 시간이 지난 후에 묘지의 다른 곳에서 상근이가 나타나게 된다. 시간은 귀신 구멍마다 다르며, 양수, 음수, 0 중 하나이다.
  - 잔디가 있는 칸으로는 자유롭게 이동할 수 있다.

상근이는 묘지를 빨리 나가기 위해 귀신 구멍도 이용할 것이다. 묘지를 나갈 수 없는 경우나, 계속해서 과거로 이동하는 경우가 존재할 수도 있다.<br/>


## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있다.<br/>
각 테스트 케이스의 첫째 줄에는 묘지의 너비 W와 높이 H가 주어진다. (1 ≤ W, H ≤ 30) 다음 줄에는 묘비의 개수 G (G ≥ 0)가 주어진다. 다음 G개 줄에는 묘비의 위치를 나타내는 두 정수 X와 Y가 주어진다. (0 ≤ X < W, 0 ≤ Y < H)<br/>
다음 줄에는 귀신 구멍의 수 E (E ≥ 0)가 주어진다. 다음 E개 줄에는 귀신 구멍의 정보를 나타내는 X1, Y1, X2, Y2, T 가 주어진다. (X1, Y1)은 귀신 구멍의 위치이고, (X2, Y2)는 그 귀신 구멍으로 들어갔을 때, 나오는 곳의 위치이다. (0 ≤ X1, X2 < W, 0 ≤ Y1, Y2 < H) (X1,Y1)과 (X2,Y2)가 같을 수도 있다. T는 귀신 구멍에서 나오는데 걸리는 시간이다. (-10,000 ≤ T ≤ 10,000) T가 양수인 경우에는 귀신 구멍을 들어간 이후에 나온다는 의미이다. 두 귀신 구멍이 같은 장소에 있거나, 구멍에서 나오는 지점이 묘비인 경우는 없다. 묘비와 귀신 구멍이 (0, 0)이나 (W-1, H-1)에 있는 경우는 없다.<br/>
입력의 마지막 줄에는 0 0이 주어진다.<br/>


## 출력
각 테스트 케이스 마다 상근이가 과거로 계속해서 돌아간다면 "Never"를 출력하고, 출구를 빠져나올 수 없으면 "Impossible"을 출력한다. 그 외의 경우에는 묘지를 빠져나오는데 가장 빠른 시간을 출력한다.<br/>


## 예제 입력
3 3<br/>
2<br/>
2 1<br/>
1 2<br/>
0<br/>
4 3<br/>
2<br/>
2 1<br/>
3 1<br/>
1<br/>
3 0 2 2 0<br/>
4 2<br/>
0<br/>
1<br/>
2 0 1 0 -3<br/>
0 0<br/>


## 예제 출력
Impossible<br/>
4<br/>
Never<br/>


## 풀이
격자의 \(0, 0\)에서 \(w-1, h-1\)로 가는 최단 경로를 찾아야 한다.<br/>
그런데 귀신 구멍이 있어 특정 귀신 구멍이 있는 좌표에 이동하면 귀신 구멍이 나오는 특정 좌표가 있다.<br/>
그래서 그래프 형식으로 탐색을 했다.<br/>


그리고 귀신 구멍을 타는 경우 시간 역행을 할 수 있어 즉, 음의 간선이 존재한다.<br/>
그래서 다익스트라 알고리즘은 사용하지 못한다.<br/>
w, h의 크기가 30이하로 벨만-포드 알고리즘이 유효하다 판단해 벨만-포드로 접근했다.<br/>


귀신 구멍의 시작 좌표와 끝 좌표가 있고 이를 변형없이 표현하면 시작좌표 2차원, 도착 좌표 2차원, 귀신 구멍 시간으로 5차원으로 저장해줘야 한다.<br/>
그런데 격자좌표를 새롭게 \(0, 0\)부터 0번을 놓고, \(0, 1\)을 1, ..., \(30, 30\)을 899로 새롭게 인덱스를 부여했다.<br/>
그래서 새로운 인덱스로 시작 좌표와 끝 좌표를 나타내서 구멍의 시간을 추가해 3차원으로 저장되게 했다.<br/>
묘비가 놓인 곳, 최단 거리 역시 새로운 인덱스 위치에 저장해뒀다.<br/>


그래서 벨만-포드 탐색을 현재 격좌의 새로운 인덱스를 확인한다.<br/>
새로운 인덱스로 한 번도 방문하지 않은 곳인지, 새로운 인덱스로 묘비가 세워진 곳인지 확인해 탐색 여부를 확인한다.<br/>


방문한 곳이고 묘비가 없을 때 탐색을 하는데, 현재 장소가 귀신 구멍이 있는지 판단한다.<br/>
문제에서 출구에 도달하면 즉시 빠져나간다고 했으므로 도착지점인 경우도 탐색하지 않는다.<br/>


이제 탐색할 곳인 경우 귀신 구멍이 있으면 귀신 구멍을 강제로 탄다.<br/>
반면 귀신 구멍이 있는 곳이 아니라면 4방향 이동을 한다.<br/>
이는 기존 격좌 좌표로 이동을 시도한다.<br/>


맵을 벗어나지 않았다면 이동한 곳의 새로운 좌표를 확인해 묘비가 있는지 탐색한다.<br/>
묘비가 없다면 거리를 확인해 최소 거리로 갱신한다.<br/>


이렇게 격자의 크기만큼 확인했다.<br/>
효율을 생각한다면 격좌의 크기 에서 묘비가 있는 위치를 빼고 -1을 하면 된다.<br/>


격자의 크기만큼 이동한 후 다시 1번 이동을 하는데 여기서 최솟값 갱신이 이뤄진다면 음의 간선이 존재하는 경우이므로 Never로 했다.<br/>
또는 출구 지점이 방문되지 않았다면 갈 수 없는 경우이므로 Impossible을 반환한다.<br/>
이외의 경우는 출구 지점의 거리 값을 반환하니 이상없이 통과한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/3860