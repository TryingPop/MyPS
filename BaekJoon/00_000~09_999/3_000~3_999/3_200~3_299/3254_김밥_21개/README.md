# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 구현
  - 시뮬레이션

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
상근이와 정인이는 재미있는 게임을 하려고 한다. 이 게임은 상근이가 아이디어를 제안하고, 정인이가 규칙을 만들었다. 게임의 이름은 "깁밥 21개"이다.<br/>
김밥 21개 게임은 가로 6줄, 세로 7줄 모양의 게임판(6행 7열)을 세워놓고 진행한다. 게임 방법은 각 사람이 서로 번갈아가면서 김밥을 게임판에 던지는 것이다. <br/>
게임판에 김밥을 던지게 되면, 김밥이 있는 칸에서 아래로 점점 떨어지게 된다. 김밥은 아래로 비어있는 칸이 없을 때 까지 떨어진다. 떨어지는 속도는 매우 빠르다.<br/>
상근이와 정인이는 매우 뛰어난 플레이어이기 때문에, 김밥을 두 칸 또는 그 이상 칸에 걸치게 던지는 경우는 없고, 항상 비어있는 칸에 김밥을 던진다. 또한, 이 김밥은 신기하게도 모양이 망가지지 않으며, 김밥은 정확하게 한 칸을 차지한다.<br/>
상근이와 정인이는 김밥 21개를 가지고 게임을 시작하고, 항상 상근이가 먼저 게임을 시작한다. 상근이는 참치 김밥을, 정인이는 김치 김밥을 가지고 있다.<br/>
이 게임의 목표는 김밥 4개를 가로, 세로, 또는 대각선으로 연속하게 만드는 것이다. 상근이와 정인이는 승부욕이 엄청나기 때문에, 게임의 승자가 결정된 이후에도 김밥을 던진다. 따라서, 이 둘은 항상 승자없이 게임을 마치게 된다.<br/>
김밥이 먹고싶었던 창영이는 상근이와 정인이가 맞춘 칸을 차례대로 기록해놨다.<br/>
이때, 게임의 승자가 누군지, 그리고 몇 번째 김밥에서 게임의 승자가 정해졌는지(처음으로 등장하는 김밥 4개의 연속)를 구하는 프로그램을 작성하시오. 게임의 승자가 없을 수도 있다.<br/>


## 입력
입력은 21줄로 이루어져 있다. i번째 줄은 Si와 Ji로 이루어져 있다. Si는 상근이가 i번째 던진 김밥이 맞춘 열의 번호이고, Ji는 정인이가 i번째 던진 김밥이 맞춘 열의 번호이다.<br/>
열의 번호는 1번부터 시작한다.<br/>


## 출력
상근이가 게임을 승리했다면 "sk M"을, 정인이가 게임을 승리했다면 "ji M"을 출력한다. 여기서 M은 승자가 몇 번째 김밥으로 게임에 승리했는지를 출력하는 것이다. 만약, 승자가 없다면 ss를 출력한다.<br/>


## 예제 입력
2 2<br/>
5 2<br/>
3 7<br/>
6 1<br/>
4 6<br/>
3 1<br/>
3 5<br/>
3 3<br/>
6 3<br/>
2 5<br/>
4 1<br/>
6 2<br/>
2 5<br/>
7 5<br/>
1 7<br/>
4 4<br/>
4 1<br/>
7 6<br/>
1 7<br/>
7 5<br/>
6 4<br/>


## 예제 출력
sk 5<br/>


## 풀이
돌을 놓을 때 밑에서 부터 놓는데, 만약 해당 열의 밑 바닥 위치를 기록한다면 O(1)에 바닥을 알 수 있다.<br/>
해당 방법으로 맵의 크기가 6 x 7로 매우 작고 매번 8방향 조사해도 시간이 충분하다.<br/>
실제로 6 x 7 x 8 x 4 < 4 x 10^3이므로 시간이 많이 걸리지 않는다.<br/>
그래서 돌을 놓으면서 8방향 확인을통해 게임이 끝나는지 확인하며 시뮬레이션 돌렸다.<br/>


만약 맵의 크기가 10만 가까이 크다면, 유니온 파인드 알고리즘을 이용해 이어진 경우를 확인했을 것이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/3254