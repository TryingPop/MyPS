# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학
  - 재귀

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
새트리는 무한 이진 트리이다.<br/>
새트리의 각 노드는 다음과 같이 재귀적으로 정의할 수 있다.<br/>
bird = 1/1<br/>
왼쪽 자식: 1/(bird + 1) 오른쪽 자식: (1/bird) + 1<br/>
여기서 bird는 완전 트리를 의미하고, bird+1은 트리의 모든 분수에 1를 더하는 것을 의미하고, 1/bird는 트리의 모든 분수를 뒤집는 것을 의미한다.<br/>
놀랍게도 트리에는 모든 유리수가 딱 한 번씩 등장한다. 따라서, 모든 기약분수는 유일한 경로가 있다. 경로는 왼쪽 자식노드로 갈 때는 L, 오른쪽으로 갈 때는 R로 표현한다. 예를 들어, 2/5는 LRR로 표현할 수 있다.<br/>
기약분수가 주어졌을 때, 루트에서 그 노드까지의 경로를 L과 R로 표현하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 a와 b가 '/'로 구분되어 주어진다. a는 기약분수의 분자, b는 분모이며, a와 b가 동시에 1인 경우는 없다. 또한, gcd(a,b) = 1을 만족한다. (1 ≤ a,b ≤ 10^9) 경로의 길이는 10,000을 넘지 않는다.<br/>


## 출력
첫째 줄에 루트에서 입력으로 주어진 기약분수까지 가는 경로를 출력한다.<br/>


## 예제 입력
2/5<br/>


## 예제 출력
LRR<br/>


## 풀이
문제를 이해하는데 많은 시간이 걸렸다.<br/>


이전을 u / d라하자. 다음 왼쪽 자식의 경우 d / (u + d)의 형태가 되고, 오른쪽 자식의 경우 (u + d) / u가 된다.<br/>
그래서 분자와 분모를 비교하는데 분모가 큰 경우 왼쪽 자식이 된다.<br/>
반면 분자가 큰 경우는 오른쪽 자식이 된다.<br/>


예제 2/5를 보자.<br/>
분모 5가 분자 2보다 크므로 왼쪽 자식이 된다.<br/>
그러면 이전 값은 u + d = 5이고 d = 2이므로 u = 3 즉 3/2가 된다.<br/>


3/2의 경우는 분자가 크므로 오른쪽 자식이 된다.<br/>
이전 값은 2/1이된다.<br/>
그리고 마찬가지로 분자가 크므로 오른쪽 자식이 되고 이전 값은 1/1이다.<br/>


이렇게 LRR을 얻는다.<br/>


새트리의 진행과정을 보면 유클리드 호제법이다.<br/>
문제 입력에서 a, b의 최대 공약수는 1이라 했으므로 언제나 1/1로 감을 알 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/3652