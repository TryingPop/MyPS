# C#

## 난이도 : 플레티넘 3

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 비트마스킹

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
용태는 바람의 신이다.<br/>
용태는 구름을 움직여서 날씨를 조정할 수 있다. 구름의 밑에 있는 지역에는 항상 비가 내리며, 그 이외의 지역은 항상 맑다.<br/>
용태는 마음씨가 매우 좋기 때문에, 모든 마을에 비를 골고루 내리게 하려고 한다. 또, 축제나 시장이 열리는 날은 맑게 만들어 주려고 한다.<br/>
용태가 맡은 나라는 창영제국이라는 매우 작은 나라이다. 이 나라는 4×4 크기의 정사각형으로 이루어져 있으며, 다음과 같이 번호가 매겨져 있다. 한 마을은 1×1 정사각형 하나를 차지한다.<br/>

|1|2|3|4|
|:---:|:---:|:---:|:---:|
|5|6|7|8|
|9|10|11|12|
|13|14|15|16|

구름의 크기는 2×2이며, 나라의 경계를 넘어갈 수 없다. 용태는 축제와 시장이 각 마을 별로 언제 열리는지를 알고 있다. 이 날은 그 마을에 비가 오면 안 된다.<br/>
첫 날에 구름은 이 나라의 중심부에 있다. (6-7-10-11)<br/>
그 다음 날 부터 하루가 시작하는 순간에 구름을 움직일 수 있다. 구름은 동서남북 중 한 방향으로 한 칸 또는 두 칸 움직일 수 있다. 구름을 전날과 같은 자리에 놔두는 것은 가능하다. 하지만, 대각선으로 움직이거나 서로 다른 방향으로 두 칸 움직이는 것은 불가능하다.<br/>
어떤 마을을 비가 오지 않은 채로 일주일을 내버려 두면 안 된다. 최대 6일까지 비가 오지 않은채로 있을 수 있지만, 적어도 7일이 되는 날에는 비가 와야 한다. 또, 문제가 시작하기 바로 전 날에는 모든 마을에 비가 왔고, N일 이후의 일은 전혀 관여할 필요가 없다.<br/>


## 입력
입력은 여러 개의 테스트 케이스로 이루어져 있으며, 마지막 줄에는 0이 하나 주어진다.<br/>
테스트 케이스의 첫째 줄에는 마지막 날 N이 주어진다. 다음 N개 줄에는 각 마을의 축제와 시장 계획이 주어진다. 한 줄에는 16개의 숫자가 주어지며, 1번마을부터 16번마까지 차례대로 주어진다. 1이면 축제나 시장이 열리는 것이고, 0이면 없는 것이다.<br/>
N은 365를 넘지 않는다.<br/>


## 출력
각 테스트 케이스마다, 문제의 조건을 만족시키면서 비를 내리게 할 수 잇으면 1을, 없으면 0을 출력한다.<br/>


## 예제 입력
1<br/>
0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0<br/>
7<br/>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br/>
1 0 0 0 0 0 1 0 0 0 0 1 1 0 0 1<br/>
0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 1<br/>
0 0 0 0 0 0 0 0 0 1 0 1 0 0 0 0<br/>
0 1 0 1 0 0 0 0 0 0 0 0 0 0 0 0<br/>
1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1<br/>
0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 0<br/>
7<br/>
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0<br/>
0 0 1 0 0 0 0 1 0 0 0 0 0 1 0 0<br/>
0 0 0 1 0 0 0 0 0 0 1 0 1 0 0 0<br/>
0 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0<br/>
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0<br/>
0 0 0 0 0 0 0 1 1 0 1 0 0 0 0 1<br/>
0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0<br/>
15<br/>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0<br/>
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0<br/>
0 0 0 0 0 0 0 0 1 1 0 0 0 0 0 0<br/>
0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0<br/>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br/>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br/>
0 0 0 0 0 0 0 0 1 1 0 1 0 0 0 0<br/>
0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0<br/>
0 0 1 1 0 0 0 0 0 1 0 0 0 0 0 0<br/>
1 1 0 0 0 0 0 0 0 0 1 0 0 1 0 0<br/>
0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0<br/>
0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0<br/>
1 0 0 1 1 0 0 0 0 1 0 1 0 0 0 0<br/>
0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0<br/>
0 0 0 0 0 1 0 1 0 1 0 0 0 0 0 0<br/>
0<br/>


## 예제 출력
0<br/>
1<br/>
0<br/>
1<br/>


## 풀이
문제를 처음 접했을 때는 탐색 공간도 넓어 보였기 때문에, 직관적으로 어떻게 접근해야 할지 전혀 감이 잡히지 않았다.<br/>
비트마스킹의 경우 쓴다면 연속된 맑은 날에 쓸 수 있음을 확인했지만 dp는 어떻게 써야할지 감이 안잡혔다.<br/>


챗 gpt를 통해 푸는 방향을 정했다.<br/>
gpt의 방법은 백트래킹 기반의 DFS 탐색에, 불필요한 중복 탐색을 줄이기 위해 메모이제이션(DP)을 결합하는 방식이었다.<br/>


먼저 dp에 현재 날짜, 현재 좌표, 각 좌표별 연속된 맑은 날의 상태에 대해 가능 여부를 저장한다.<br/>
현재날짜는 365 < 512 = 2^9이다. 그리고 현재 구름의 좌표는 왼쪽 위를 기준으로 하면 행과 열이 3이하이므로 3 < 2^2으로 표현가능하다.<br/>
그리고 연속된 맑은 날의 최댓값은 7 < 2^3이고 좌표는 16개가 있다.<br/>
그래서 가능한 경우는 (현재 날짜) x (현재 좌표) x (각 좌표별 맑은 날의 상태) = (2^9) x (2^2 x 2^2) x ((2^3)^16) = 2^61이다.<br/>
이를 long으로 비트마스킹하고 dp는 배열이 아닌 해시에 저장 했다.<br/>
그리고 탐색을 성공한 경우 바로 탈출하게 하면 dp에 저장된 것들은 불가능하다고 판별해도 된다.<br/>
그래서 HashSet에 비트마스킹 한 값만 넣었다.<br/>


이제 탐색에서 dp에 값이 있으면 해당 dp 값을 반환하는 식으로 했다.<br/>
dp 값이 없는 경우, 이제 비를 내린다. 비를 내리는 곳에 축제가 있으면 탈출한다.<br/>
그리고 비가 안내리는 곳이면 맑은날 1일 늘린다. 7일 이상 연속된 맑은 날인 좌표가 있으면 불가능하다고 판단한다.<br/>


이렇게 판별했음에도 탈출을 하지 않았다면 유효한 좌표다.<br/>
이제 구름의 좌표를 이동한다.<br/>


이렇게 탈출하지 않고 N일을 넘길 수 있는지 확인한다.<br/>


dp의 크기를 보면 (현재 날짜) x (현재 좌표) x (각 좌표별 연속된 맑은 날의 상태) = 365 x 9 x 7^16 > 10^17이다.<br/>
그래서 해당 방법이 시간 초과날거 같았다.<br/>
틀리면 뒤에 다시 접근해보자는 식으로 제출하니 이상없이 통과했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/3935