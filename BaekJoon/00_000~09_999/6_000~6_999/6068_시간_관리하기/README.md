# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 그리디 알고리즘
  - 정렬

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
성실한 농부 존은 시간을 효율적으로 관리해야 한다는 걸 깨달았다. 그는 N개의 해야할 일에 (1<=N<=1000) 숫자를 매겼다. (우유를 짜고, 마굿간을 치우고, 담장을 고치는 등의)<br/>
존의 시간을 효율적으로 관리하기 위해, 그는 끝내야만 하는 일 목록을 만들었다. 완성될 때 필요한 시간을 T_i(1<=T_i<=1,000) 라고 하며, 끝내야하는 시간을 S_i(1<=S_i<=1,000,000) 이라 한다. 농부 존은 하루의 시작을 t = 0으로 정했다. 그리고 일 할 때는 그 일을 마칠 때 까지 그 일만 한다. <br/>
존은 늦잠 자는 걸 좋아한다. 따라서 제 시간에 끝낼 수 있게 결정할 수 있는 한도에서 존이 가장 늦게 일어나도 되는 시간을 출력하라.<br/>


## 입력
첫 줄에는 일의 개수인 N을 받고<br/>
두 번째 줄부터 N+1줄까지 T_i와 S_i를 입력받는다.<br/>


## 출력
존이 일을 할 수 있는 마지막 시간을 출력 하라. 존이 제시간에 일을 끝낼 수 없다면 -1 을 출력하라.<br/>


## 예제 입력
4<br/>
3 5<br/>
8 14<br/>
5 20<br/>
1 16<br/>


## 예제 출력
2<br/>


## 풀이
일을 최대한 늦게 시작하는게 그리디로 가장 많은 잠을 잘 수 잇다.<br/>


일을 끝나는 시간으로 내림차순 정렬하고, 해당 일을 순차적으로 진행해간다.<br/>
처음 일은 끝나는 시간에서 일을 해야하는 시간을 뺀 값에 시작한다.<br/>
만약 시작 시간이 0보다 작으면 불가능하다.<br/>


그리고 해당 일이 끝나면 다음일을 시작한다.<br/>
만약 일이 끝나는 시간이 다음 일의 끝시간보다 큰 경우 처음 일처럼 끝나는 시간에서 일을 해야하는 시간을 뺀 값에 시작한다.<br/>
반면 이전 일이 끝나는 시간이 다음 일의 끝시간보다 작은 경우 해당 시간에서 일을 해야하는 시간을 뺀 시간에 시작한다.<br/>
두 경우 모두 시작 시간이 0보다 작으면 불가능하다.<br/>


이렇게 일을 진행해 간다.<br/>
시작 시간이 0보다 작은 경우 불가능하므로 바로 중단한다.<br/>
이렇게 진행해서 찾은 0이상의 값이 최대한 잘 수 있는 값이된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/6068