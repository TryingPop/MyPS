# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 구현
  - 자료 구조
  - 스택

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
모범생 현수는 코딩하는 시간을 늘리기 위해 타임 머신을 구매 했다. 현수는 정상적으로 문제를 코딩하거나 (타임 머신을 사용하지 않고), 과거의 임의의 지점으로 시간여행 할 수 있다.  미래로 시간 여행 할 수 없으며, 과거로 가면 새로운 미래가 진행된다.<br/>
현수는 자유롭게 문제를 풀거나 과거로 돌아가면서 자신이 푼 문제 목록을 기록한다. 과거로 돌아가면 과거 이전까지 풀었던 문제 목록만 남는다.<br/>
현수는  기록 되어 있는 문제 목록 중 가장 최근에 푼 문제 번호를 알고 싶다. (가장 최근에 푼 문제가 없다면 -1을 출력)<br/>
매 쿼리마다 문제 목록에 기록되어 있는 가장 최근에 푼 문제를 출력하는 프로그램을 작성하시오.<br/>
현수는 개인의 타임라인 관점에서 연속적인 업데이트를 나타내는  N (1 <= N <= 80,000) 개의 쿼리 Qi(1...N) 를 제공한다.<br/>
각 쿼리는 한 줄의 입력이다. 각 줄은 하나의 문자 c ( 'a', 's', 't' 중 하나)로 시작한다. c가 'a'또는 't' 이면 c 다음에 공백과 정수 K가 주어진다. (1 <= K <= 1,000,000)<br/>
c가 'a' 이면 현수는 문제 번호가 K인 문제를 풀고 문제 목록에 기록 한다.<br/>
c가 's' 이면 현수는 가장 최근에 작성한 문제 목록을 삭제한다.<br/>
c가 't'이면, 현수는 K 번째 쿼리 직전까지 시간을 거슬러 올라 간다. 즉, 현수는 K-1번째 쿼리와 K번째 쿼리 사이로 시간 여행한다. (입력을 위해 예제 입력 참조). K 쿼리  바로 전에 있던 푼 문제 목록으로 되돌아 간다.<br/>
이해를 돕기 위해 아래에 푼 문제 목록과 12개의 쿼리, 각 쿼리에 대한 출력결과가 주어진다.<br/>

	Q#   쿼리     문제목록      출력         참조
	 1   a 5  -> [5]         => 5        5번 문제를 목록에 기록
	 2   a 3  -> [5,3]       => 3        3번 문제를  목록에 기록
	 3   a 7  -> [5,3,7]     => 7        7번 문제를 목록에 기록
	 4   s    -> [5,3]       => 3        가장 최근 기록한 7를 목록에서 삭제
	 5   t 2  -> [5]         => 5        2번째 쿼리 직전으로 되돌아감
	 6   a 2  -> [5,2]       => 2        2번 문제를 목록에 기록
	 7   t 4  -> [5,3,7]     => 7        4번째 쿼리 직전으로 되돌아감
	 8   a 4  -> [5,3,7,4]   => 4        4번 문제를 목록에 기록
	 9   s    -> [5,3,7]     => 7        가장 최근 기록한 4를 목록에서 삭제
	10   t 7  -> [5,2]       => 2        7번째 쿼리 직전으로 되돌아감
	11   s    -> [5]         => 5        가장 최근 기록한 2를 목록에서 삭제
	12   s    -> []          => -1       가장 최근 기록한 5를 목록에서 삭제


## 입력
첫 번째 줄 : 하나의 정수 N<br/>
두 번째 줄 부터 N+1번째 줄까지: 쿼리 Qi<br/>


## 출력
1부터 N번째 줄 : Qi 처리 후 목록에 기록 되어 있는 가장 최근에 푼 문제를 출력하시오 (가장 최근에 푼 문제가 없으면 -1).<br/>


## 예제 입력
12<br/>
a 5<br/>
a 3<br/>
a 7<br/>
s<br/>
t 2<br/>
a 2<br/>
t 4<br/>
a 4<br/>
s<br/>
t 7<br/>
s<br/>
s<br/>


## 예제 출력
5<br/>
3<br/>
7<br/>
3<br/>
5<br/>
2<br/>
7<br/>
4<br/>
7<br/>
2<br/>
5<br/>
-1<br/>


## 풀이
연결 리스트 형태로 스택을 구현하면 된다.<br/>


그러면 가장 최근 문제 목록은 Peek에 있는 노드의 값이 된다.<br/>
만약 Peek이 없다면 -1을 출력하면 된다.<br/>


그러면 t i의 쿼리가 주어지는 경우 i - 1번 Peek노드로 돌아가는 것과 같다.<br/>


그래서 매 Peek노드에 있는 노드를 배열에 기록하고 되돌아가는 것은 해당 Peek 노드의 상태를 가져왔다.<br/>
이렇게 Peek 노드 정보를 이용해 풀었다.<br/>


메모리를 생각하면 class를 이용해 푸는 것이 좋다.<br/>
여기서는 struct인 ValueTuple을 이용해도 메모리가 넉넉해 struct를 이용했다.<br/>


Peek이 없다는 의미로 0번 노드를 NULL노드의 의미로 할당했고 문제 조건에 맞게 값과 이전을 -1로 저장했다.<br/>
NULL 노드를 확인하는 것은 이전이 -1로 했다.<br/>


만약 클래스를 이용해 풀었다면 이전이 있는지 확인하는 ?연산자를 이용해 원소 접근을 시도할 것이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/6051