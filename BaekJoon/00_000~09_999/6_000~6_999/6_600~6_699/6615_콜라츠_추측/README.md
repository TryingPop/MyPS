# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 구현
  - 브루트포스 알고리즘
  - 트리
  - 최소 공통 조상

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
콜라츠 추측은 흥미로운 현상이다. 이 법칙은 간단해보이지만, 수학적으로 아직까지 증명되어있지 않은 문제이다. 우리는 이 추측이 옳다고 받아들이겠다.<br/>
콜라츠 추측을 설명하면 다음과 같다. 우선 다음과 같은 양의 정수 수열 xi 를 생각하자.<br/>

  - 만약 xi 가 짝수이면, xi+1=xi/2
  - 만약 xi 가 홀수이면, xi+1=3*xi +1 이다.

콜라츠 추측은 이렇게 만든 수열은 결국 1이 된다는 것이다.<br/>
과학자들은, 컴퓨터를 이용하여 첫 번째 수열이 258 보다 작으면, 이 추측은 참이라고 증명했다.<br/>
이제 문제를 보자.<br/>
두개의 양의 정수를 준다. 각각의 수에 대해서 콜라츠 추측으로 만든 수열을 생각하자.<br/>
각각의 수열을 비교하였을때 처음으로 같은 숫자가 나왔을때 , 각각 몇번째 수열에서 만나는지 구해본다. 문제의 편의를 위해, 이 수열은 1이 나오면 더이상 진행하지 않는다고 하자. ( 1 다음에 나올 수열을 생각하면, 1, 4, 2, 1, 4, 2, 1로 반복되기 때문이다.)<br/>


## 입력
입력은 몇개의 테스트 케이스로 구성된다. 각 테스트 케이스는 두개의 정수 A와 B가 주어진다. ( 1 ≤ A, B ≤ 1,000,000) 마지막 줄은 두개의 0으로 구성된다.<br/>


## 출력
각각의 테스트 케이스마다 다음과 같은 문장을 한줄에 출력한다.<br/>
"A needs SA steps, B needs SB steps, they meet at C"<br/>
SA와 SB는 A와 B로 수열을 만들고, 처음으로 같은 숫자 C가 나왔을때 각각의 수열에서 몇번째 인지 알려주는 숫자이다.<br/>


## 예제 입력
7 8<br/>
27 30<br/>
0 0<br/>


## 예제 출력
7 needs 13 steps, 8 needs 0 steps, they meet at 8<br/>
27 needs 95 steps, 30 needs 2 steps, they meet at 46<br/>


## 풀이
2^58은 1로 간다고 나와있다. 그래서 100만 이하는 무조건 1로 간다고 생각했다.<br/>
a 숫자를 노드로 가는 방법을 dictionary에 해당 숫자를 key로 몇 번째 들렀는지 value로 저장했다.<br/>
그리고 b를 진행해 가며 해당값이 dictionay에 등록된 키면 만난 횟수를 출력했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/6615