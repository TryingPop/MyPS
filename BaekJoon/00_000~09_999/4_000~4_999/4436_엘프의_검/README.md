# C#

## 난이도 : 브론즈 2

## 알고리즘 분류
  - 수학
  - 브루트포스 알고리즘

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
중간계에 살고있는 엘프 종족은 특정 숫자를 다른 숫자보다 중요하다고 믿는다. 따라서, 그들은 금속 n만큼을 이용해서 칼을 만들 때, 두께를 다음과 같은 규칙을 지키는 k로 한다면, 엄청나게 강력한 칼을 만들 수 있다고 믿는다.<br/>
음이 아닌 정수 n이 주어졌을 때, 다음과 같은 수열을 만들 수 있다.<br/>
n, 2n, 3n, 4n, ..., kn<br/>
이때의 수열에서, 0~9까지의 숫자가 한 번 이상 나타나는 가장 작은 k를 찾아야 한다.<br/>
리븐델의 영주 엘론드는 이 일을 대신해주는 프로그램을 만들려고 한다. 금속의 양 n이 주어졌을 때, 위의 규칙을 지키는 이상적인 두께 k를 구하는 프로그램을 작성하시오.<br/>


## 입력
한 줄에 하나씩 n이 주어진다. n은 1보다 크거나 같고, 200,000,000보다 작거나 같은 정수이다.<br/>


## 출력
각 입력에 대해, 0~9까지 숫자가 모두 등장하는 가장 작은 값 k를 출력한다.<br/>


## 예제 입력
1<br/>
10<br/>
123456789<br/>
3141592<br/>


## 예제 출력
10<br/>
9<br/>
3<br/>
5<br/>


## 풀이
1 ~ 10사이에 0 ~ 9까지 모두 등장하는 경우를 찾아보니, 100번 이내에 찾을 수 있다.<br/>
이후 11 이상의 수에 대해 0이 아닌 가장 작은 단위의 숫자를 보면 100번 이내로 찾음을 알 수 있다.<br/>
이는 각 숫자당 100번 이내로 정답을 찾을 수 있음을 확인하고 브루트포스로 방향을 잡았다.<br/>


입력 범위가 2억까지 오고, 100배를 하면 200억까지 간다.<br/>
그래서 long으로 입력받고 곱하면서 0 ~ 10까지 나오는 때를 찾는다.<br/>
이후 0 ~ 9까지 수를 찾는데 이는 10으로 나눈 나머지로 확인했다.<br/>
자릿수가 바뀜은 기존 수로 10으로 나눈 몫을 다음수로 나타내면 된다.<br/>


이후 숫자 출현 관리는 bool배열을 이용했다.<br/>
다 풀고나서 보니 비트마스킹도 좋아보인다.<br/>
새롭게 i가 추가되면 use[i] = true로 바꾸고 갯수를 추가한다.<br/>
해당 갯수가 10개가되면 종료했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/4436