# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 자료 구조
  - 그리디 알고리즘
  - 덱

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
세준이는 어떤 문자열 S를 뒤집으려고 한다. 문자열을 뒤집는 방법은 문자열의 길이를 N이라고 하자. i만큼을 뒤집는다는 소리는 그 문자열의 처음부터 정확하게 i개의 문자를 역순으로 뒤집는 것이다. 세준이는 1부터 N까지 수를 차례대로 생각한다. 그리고, 뒤집을지 안 뒤집을지 선택할 수 있다.<br/>
예를 들어, S="BCDAF" 이고, 세준이가 길이 1만큼을 뒤집지 않고, 길이 2만큼도 뒤집지 않고 세준이가 길이 3만큼을 뒤집는다고 하면 문자열은 DCBAF가 된다. 다시 여기서 4만큼 뒤집으면 ABCDF가 된다. 그리고, 마지막으로 길이를 5만큼 뒤집지 않으면 주어진 문자열 S를 사전순으로 가장 앞서게 만들 수 있다.<br/>
문자열 S가 주어졌을 때, 위와같은 뒤집기 방법으로 만들 수 있는 문자열 중 사전순으로 제일 앞서는 것을 출력하시오.<br/>


## 입력
첫째 줄에 문자열 S가 주어진다. 문자열의 길이는 최대 50이다. 알파벳 대문자만 들어온다.<br/>


## 출력
첫째 줄에 사전순으로 가장 앞서는 정답을 출력한다.<br/>


## 예제 입력
BCDAF<br/>


## 예제 출력
ABCDF<br/>


## 풀이
뒤집는 길이를 1씩 순차적으로 늘려간다.<br/>
i번째 문자를 진행할 때 이전 뒤집는 경우를 거꾸로 하면 1번째에서 i - 1번까지의 문자열을 뒤집게 할 수 있다.<br/>
그래서 앞의 뒤집는 경우를 적절히 조절하면 i번째 문자는 현재까지 진행된 문자의 맨 앞이나 i번째인 맨 뒤에 추가된다.<br/>
앞 뒤에 이어붙이는 형식이므로 덱의 형태로 문자열을 추가해주면 된다.<br/>


사전식 정렬이므로 문자열 A, B에 대해 A가 맨 앞의 문자가 B보다 사전순으로 앞서는 경우 뒤는 상관없이 A가 B보다 앞서게 된다.<br/>
그래서 현재 가장 앞서는 상태가 되게 문자열을 뒤집어가면 그리디로 가장 사전순으로 앞서는 문자열을 얻을 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1464