# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 자료 구조
  - 그리디 알고리즘
  - 덱

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
세준이는 어떤 문자열 S를 뒤집으려고 한다. 문자열을 뒤집는 방법은 문자열의 길이를 N이라고 하자. i만큼을 뒤집는다는 소리는 그 문자열의 처음부터 정확하게 i개의 문자를 역순으로 뒤집는 것이다. 세준이는 1부터 N까지 수를 차례대로 생각한다. 그리고, 뒤집을지 안 뒤집을지 선택할 수 있다.<br/>
예를 들어, S="BCDAF" 이고, 세준이가 길이 1만큼을 뒤집지 않고, 길이 2만큼도 뒤집지 않고 세준이가 길이 3만큼을 뒤집는다고 하면 문자열은 DCBAF가 된다. 다시 여기서 4만큼 뒤집으면 ABCDF가 된다. 그리고, 마지막으로 길이를 5만큼 뒤집지 않으면 주어진 문자열 S를 사전순으로 가장 앞서게 만들 수 있다.<br/>
문자열 S가 주어졌을 때, 위와같은 뒤집기 방법으로 만들 수 있는 문자열 중 사전순으로 제일 앞서는 것을 출력하시오.<br/>


## 입력
첫째 줄에 문자열 S가 주어진다. 문자열의 길이는 최대 50이다. 알파벳 대문자만 들어온다.<br/>


## 출력
첫째 줄에 사전순으로 가장 앞서는 정답을 출력한다.<br/>


## 예제 입력
BCDAF<br/>


## 예제 출력
ABCDF<br/>


## 풀이
1번부터 i번까지 뒤집는데 길이를 1씩 순차적으로 늘려간다. 그래서 j < i에 대해 1 ~ j 번 뒤집기는 i번에 영향을 주지 못한다.<br/>
그래서 i번째 뒤집을 때 가장 사전식으로 앞서게 뒤집어가면 그리디로 전체에서 가장 앞서는 경우가 된다.<br/>


또한 i번째 문자를 진행할 때 이전 뒤집는 경우를 거꾸로 하면 1번째에서 i - 1번까지의 문자열을 뒤집게 할 수 있다.<br/>
그래서 앞의 뒤집는 경우를 적절히 조절하면 i번째 문자는 현재까지 진행된 문자의 맨 앞이나 i번째인 맨 뒤에 추가된다.<br/>
앞 뒤에 이어붙이는 형식이므로 덱의 형태로 문자열을 추가해주면 된다.<br/>


덱에 문자열을 이어붙이는데 추가하는 문자가 앞에 붙이는게 뒤에 붙이는거보다 사전식으로 앞선다면 앞에 붙이고 아니면 뒤에 붙이면 된다.<br/>
이렇게 덱에 이어붙여 결과를 제출하니 통과한다.<br/>


덱을 배열로 구현했다.<br/>
길이를 딱 맞춰서 구현했다면 head의 인덱스가 음수가 되면 끝이되게 조절해줘야 한다.<br/>
입력되는 횟수를 알아 해당 횟수의 2배로 잡은 뒤 head를 중앙에서 시작하게 하면 해당 연산이 필요없다.<br/>
그래서 길이를 2배로 늘린 덱을 이용해 인덱스를 검증안하는 덱을 구현했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1464