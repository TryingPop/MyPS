# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 백트래킹

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
숌 사각형은 숫자 2개 N과 D를 가지고 시작한다. 일단 N×N크기의 정사각형을 만든다. 그 다음, 정사각형 안에 0보다 크거나 같고, D-1보다 작거나 같은 수를 채운다.<br/>
숌 사각형에 수를 채우는 규칙은 각 행에는 0보다 크거나 같고, D보다 작은 수가 적어도 하나는 존재해야 한다는 것이고, 각 열도 마찬가지이다.<br/>
N과 D가 주어졌을 때, 사전순으로 가장 빠른 숌 사각형을 출력하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 N과 D가 주어진다. N은 10보다 작거나 같은 자연수이고, D는 N보다 작거나 같은 자연수이다.<br/>


## 출력
첫째 줄에 숌 사각형을 출력한다.<br/>


## 예제 입력
9 7<br/>


## 예제 출력
0 0 0 1 2 3 4 5 6<br/>
0 0 0 1 2 3 4 5 6<br/>
0 0 0 1 2 3 4 5 6<br/>
1 1 1 0 3 2 5 6 4<br/>
2 2 2 3 0 1 6 4 5<br/>
3 3 3 4 5 6 0 1 2<br/>
4 4 4 2 6 5 1 0 3<br/>
5 5 5 6 1 4 2 3 0<br/>
6 6 6 5 4 0 3 2 1<br/>


## 풀이
N > D인 경우 M = N - D라하면 i, j ≤ M에 대해 i, j의 값은 0이고 나머지 부분은 1, 2, ..., D - 1까지 순차적으로 채워간다.<br/>
그리고 나머지 M < i, j에 대해 해당 열에 들어갈 수 있는 수는 적절히 분배하면 채울수 있지 않을까 추측했다.<br/>


예제에서 N = 9, D = 7이다. 그래서 M = N - D = 9 - 7 = 2이다.<br/>
위 추측대로 채운다면 0행, 1행, 2행, 0열, 1열 2열은 다음과 같다.<br/>

||0열|1열|2열|3열|4열|5열|6열|7열|8열|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|0행|0|0|0|1|2|3|4|5|6|
|1행|0|0|0|1|2|3|4|5|6|
|2행|0|0|0|1|2|3|4|5|6|
|3행|1|1|1|||||||
|4행|2|2|2|||||||
|5행|3|3|3|||||||
|6행|4|4|4|||||||
|7행|5|5|5|||||||
|8행|6|6|6|||||||


실제로 예제 출력 부분과 일치해서 타당해 보인다.<br/>
해당 추측이 맞다고 가정하고 나머지 부분은 작은 수들을 넣어가면서 가능한 경우 탈출하는 백트래킹 방법으로 접근했다.<br/>


해당 행과 열에 사용한 숫자를 비트마스킹으로 표시했다.<br/>
그리고 사용되지 않은 낮은 수부터 값을 숌 사각형에 넣어간다.<br/>
넣은 경우 열과 행에 비트마스킹으로 표시한다.<br/>


그리고 다음 칸으로 넘어가며, 모든 사각형을 채운 경우 종료한다.<br/>
모든 칸에 대해 가능한 값 중 가장 작은 수부터 시도하기 때문에, DFS 탐색 과정에서 가장 먼저 완성된 경우가 사전순으로 가장 앞선다. 따라서 이 값이 곧 사전순 최소가 된다.<br/>
그래서 그리디로 사전순으로 최소임이 보장된다.<br/>


실제로 제출하니 통과했고 가정이 성립함을 알 수 있었다.<br/>


다만 매번 작은 수만 넣어가면서 진행한다면, 예제 출력의 4번째 줄 1 1 1 0 3 2 5 6 4<br/>
부분이 1 1 1 0 3 2 5 4 -1 로 마지막 -1부분에 값이 채워지지 않을 수 있다.<br/>
이러한 상황을 방지하기 위해 백트래킹을 통해 실패 시 계속해서 찾아가도록 구현해야 한다.<br/>


각 줄에서 해당 수가 이미 사용되었는지는 비트연산자 &를 통해 O(1) 시간에 확인할 수 있으며, 사용 여부의 기록과 해제는 ^ 연산자를 통해 마찬가지로 O(1) 시간에 처리할 수 있다.<br/>
모든 경우는 각 행에 배치 가능한 수의 경우의 수는 최대 (D - 1)!이고, 행은 D - 1개 있으므로 O((D - 1)!^(D-1))이 된다.<br/>
하지만 D ≤ 9 이고, 유효하지 않은 경우에는 조기 종료(백트래킹)를 수행하므로 실제 탐색 횟수는 크게 줄어들며, 시간 제한 내에 충분히 해결 가능하다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1481