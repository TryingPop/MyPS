# C#

## 난이도 : 플레티넘 2

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 이분 탐색

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
1부터 시작해서 N을 만들려고 한다. 사용할 수 있는 연산은 아래와 같이 총 3가지이다. 이때, N을 만드는데 사용하는 연산의 최소 횟수를 구하는 프로그램을 작성하시오.<br/>

  1. 현재 수를 1 증가시킴 (현재 수+1)
  2. 현재 수가 1보다 크면 1 감소 시킴 (현재 수-1)
  3. 현재 수를 자연수 제곱함. (현재 수^x, x는 자연수)


## 입력
첫째 줄에 N이 주어진다. N은 10^18보다 작거나 같은 자연수이다.<br/>


## 출력
첫째 줄에 문제의 정답을 출력한다.<br/>


## 예제 입력
123456789<br/>


## 예제 출력
2566<br/>


## 풀이
dp[i]를 1에서 i로 가는 문제 조건으로 가는 최솟값이라 하자.<br/>
그러면 i > 1에 대해 현재 수를 1증가시키는 방법으로 가면 i - 1번에 i에 도달 가능하다.<br/>
그래서 dp[i] < i가 된다.<br/>


이제 i의 값을 고정하자. i < j인 j에 대해 확인하자.<br/>
i에서 j로 1씩 증가시켜 가면 dp[i] + j - i번에 j로 도달 가능하다.<br/>
dp의 정의로 dp[j] ≤ dp[i] + j - i이고, dp[j] - dp[i] ≤ j - i가 성립한다.<br/>


각 2^60 ≥ 10^18이므로 3번의 방법으로 이동할 때 x가 60을 넘으면 최소 경우가 안됨을 알 수 있다.<br/>


이제 n으로 가는 경우를 생각해보자.<br/>
x > 1에 대해 a를 a^x ≤ n인 최댓값이라 하자.<br/>
그러면 1 ≤ b < a에 대해 dp[a] - dp[b] < a^x - b^x이다.<br/>
그래서 dp[a] + 1 + |a^x - n| < dp[b] + 1 + |b^x - n|이므로 a보다 작은 값으로 이동하는 경우는 최소가 안됨을 알 수 있다.<br/>
마찬가지로 a + 1 < b에 대해 dp[a + 1] + 1 + |(a + 1)^x - n| < dp[b] + 1 + |b^x - n|이므로 a + 1보다 큰 값으로 이동하는 경우 최소가 안됨을 알 수 있다.<br/>
그래서 각 x에 대해 a, a + 1에서 x승 방법으로 오는 최소 횟수의 경우만 확인하면 된다.<br/>


이렇게 dfs로 n에 가는 최소 횟수를 찾아갔다.<br/>
dp[i]에서 i가 10^18까지 오므로 dictionary 자료 구조로 했다.<br/>
x > 1인 i^x승 방법으로 이동하므로 처음 n으로 찾으면 후보가 120개 나오고, 후보들로 탐색하면 많아야 14400개가 된다.<br/>
그리고 2번 탐색하는 경우 인덱스의 후보 값은 10만을 넘지 못함을 알 수 있고 이는 많아야 12만개를 넘지 못함을 확인할 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1056