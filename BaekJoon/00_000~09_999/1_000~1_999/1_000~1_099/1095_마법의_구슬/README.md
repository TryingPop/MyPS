# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 정수론
  - 소수 판정
  - 에라토스테네스의 체

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
옛날에 백은진이라는 마법사가 S개의 마법의 구슬을 만들었다. 이 마법의 구슬은 함께 모여있을 때는, 상상을 초월하는 힘의 근원이 된다. 이것을 김지민과 같은 악당이 사용하는 것을 막기 위해 백은진은 F개의 가짜 구슬을 만들었다. 이 가짜 구슬은 마법의 구슬과 똑같이 생겼지만, 마법의 힘은 없다.<br/>
이제 김형택은 세계를 지배하기 위해 어떤 구슬이 진짜 구슬인지 알아야 한다. 따라서 김지민은 N명의 사람을 모아서, S+F개 중 모든 S개의 조합을 테스트하기로 했다.<br/>
김형택은 각 사람들에게 미리 어떤 조합을 테스트 할 것인지 정해주었다. 그리고 같은 조합을 최대 한 번만 테스트한다.<br/>
그런데, 이 사람들은 절대로 다른 사람보다 일을 많이 하지 않는다. 즉, 모두 같은 개수의 조합을 테스트 한다. 따라서 김형택은 몇 명의 사람을 뽑아야, 모든 조합을 테스트하면서, 모든 사람이 같은 횟수의 테스트를 하는지 궁금해졌다.<br/>
김형택이 모을 수 있는 사람의 최댓값 M이 주어질 때, M을 넘지 않으면서, 김형택이 뽑을 수 있는 최대 사람의 수를 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 S, F, M이 주어진다. S와 F는 1,000,000,000보다 작거나 같은 자연수이고, M은 100,000보다 작거나 같은 자연수이다.<br/>


## 출력
첫째 줄에 문제의 정답을 출력한다. 만약 불가능 할 때는 -1을 출력한다.<br/>


## 예제 입력
15634 456 5000<br/>

## 예제 출력
4990<br/>


## 풀이
전체 조합의 개수는 (S + F) C S = (S + F)! / (S! F!)이다.<br/>
여기서 C는 조합을 뜻한다.<br/>


모을 수 있는 사람의 최댓값 M은 자연수이므로 1 이상이다.<br/>
그리고 1명이 하는 경우 모두 공평하게 분배되므로 불가능한 경우는 없다.<br/>


이제 자연수 m이 c = (S + F) C S를 나눌 수 있는 경우를 확인하자.<br/>
m을 소인수분해하면, m = ∏pi^ki 로 표현할 수 있고, m이 c를 나눈다는 것은, 소인수 분해 m = ∏pi^ki에 대해 c가 모든 pi^ki를 약수로 가져야 함을 의미한다.<br/>


m = ∏pi^ki이고 m ≤ M이므로 각 pi^ki는 pi^ki ≤ M이 성립한다.<br/>
그래서 M이하의 소수 p에 대해 c는 얼마나 많은 인수로 갖는지 확인할 수 있어야 한다.<br/>
c = (S + F)! / (S! F!)이므로 (S + F)!에 p의 갯수를 세는데 이는 각 j에 대해 (S + F) // p^j의 합인 u = ∑ (S + F) // p^j와 일치함을 알 수 있다. 여기서 //는 몫연산이다.<br/>
비슷하게 S!, F!도 d = (∑ S // p^j) + (∑ F // p^j)세어준다.<br/>
그러면 c에 p의 소인수는 u - d가 된다.<br/>


이렇게 M이하의 모든 소수 p에 대해 c의 소인수를 모두 찾아줄 수 있다.<br/>
이제 해당 소인수들로 M이하인 가장 큰 수를 만들어야 한다.<br/>


이는 브루트포스로 찾았다.<br/>
m = M부터 시작해서 m을 소인수분해 한다.<br/>
그렇게 m = ∏pi^ki를 찾는다.<br/>
ki에 대해 pi에 대한 c의 소인수보다 큰지 확인한다.<br/>
큰게 1개라도 존재하면 m은 불가능하고 m - 1에 대해서 조사한다.<br/>


반면 모두 작거나 같은 경우라면 큰거부터 확인했기에 우리가 찾는 가장 큰 값이 된다.<br/>
해당 과정은 앞에서 말햇듯이 언제나 1에서 종료된다.<br/>


초기 c의 소인수들을 찾는데 에라토스테네스 체 방법으로 M log log M 연산을 한다.<br/>
그리고 각 p에 대해 log (S + F)의 연산을 하므로 M log (S + F)연산을 한다.<br/>
m을 찾는 연산에서 매번 소인수 분해를 하므로 √M번 연산을 하고 전체 M√M 연산을 한다.<br/>
전체 시간 복잡도는 O(M (log (S + F) + log log M) + M√M)이다.<br/>
M이 10만이고 시간제한이 2초이므로 유효한 방법이라 판단했고 실제로 1.5초 안에 통과했다.<br/>


다른 사람의 풀이를 보니 m을 줄여가며 브루트포스로 찾는게 아닌 배낭 알고리즘을 이용해 찾아 간다.<br/>


c에서 찾은 소수 pi ≤ M에 대해 c의 소인수를 qi라하자.<br/>
이때, 가능한 값의 집합을 만들기 위해 다음과 같이 진행한다:<br/>

  - 처음 가능한 수는 1이다.
  - 이후 각 pi에 대해, pi를 최대 qi번까지 곱하면서, 기존 가능한 수 e에 대해 e × pi^k (k = 1 ~ qi) 를 구성하여 새로운 가능한 수에 추가한다.
  - 이때 구성한 수가 M을 넘지 않는 경우에만 기록한다.

이렇게 모든 pi를 조사한 후, 가능한 수들 중 M 이하인 가장 큰 수가 우리가 찾는 m이 된다.<br/>


이 방식은 일종의 정수 구성 문제로, 각 소인수를 제한된 횟수만큼 사용하는 경우의 수를 제한된 배낭 알고리즘 방식으로 처리한 것이다.<br/>
해당 경우 M√M연산이 M log (S + F)연산으로 바뀌며 매우 빠르게 m을 찾을 수 있다.<br/>
실제로 앞의 브루트포스 방법보다 20배 이상 빠르다.<br/>



## 문제 링크
https://www.acmicpc.net/problem/1095