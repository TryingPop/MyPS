# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학
  - 브루트포스 알고리즘
  - 기하학

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는데, 빌딩은 선분으로 나타낸다. i번째 빌딩 (1부터 시작)은 (i,0)부터 (i,높이)의 선분으로 나타낼 수 있다. 고층 빌딩 A에서 다른 고층 빌딩 B가 볼 수 있는 빌딩이 되려면, 두 지붕을 잇는 선분이 A와 B를 제외한 다른 고층 빌딩을 지나거나 접하지 않아야 한다. 가장 많은 고층 빌딩이 보이는 빌딩을 구하고, 거기서 보이는 빌딩의 수를 출력하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 빌딩의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에 1번 빌딩부터 그 높이가 주어진다. 높이는 1,000,000,000보다 작거나 같은 자연수이다.<br/>


## 출력
첫째 줄에 문제의 정답을 출력한다.<br/>


## 예제 입력
15<br/>
1 5 3 2 6 3 2 6 4 2 5 7 3 1 5<br/>


## 예제 출력
7<br/>


## 풀이
N의 크기가 50으로 매우 작다.<br/>
그래서 두 빌딩간 모든 기울기를 구하고, 볼 수 있는 빌딩의 갯수를 찾아도 된다.<br/>


현재 빌딩을 i번째라 하면, j < i인 j번째 빌딩의 기울기 m[i][j]를 구한다.<br/>
기울기 m[i][j] = (height[i] - height[j]) / (i - j)이다.<br/>
여기서 height[i]는 i번째 높이이다.<br/>

k < i에대해 k가 보일러면 k < j < i인 모든 j에 대해 m[i][k] < m[i][j]인 경우만 k가 보인다.<br/>
왼쪽은 이렇게 찾을 수 있으나 부동소수점 오차가 발생할 것 같아 정수 연산으로 해결했다.<br/>


m[i][j] = (height[i] - height[j]) / (i - j)이므로 m[i][k] < m[i][j]을 변형하면,<br/>
(height[i] - height[k]) x (i - k) < (height[i] - height[j]) x (i - j)식과 동치이다.<br/>
이렇게 N^3의 방법으로 찾았다.<br/>


이제 오른쪽에 보이는 것을 찾아야 한다.<br/>
i < j인 j번째 빌딩의 기울기 m[i][j]는 다음과 같다.<br/>
기울기 m[i][j] = (height[j] - height[i]) / (j - i)이다.<br/>


i < k에 대해 k가 보일러면 i < j < k인 모든 j에 대해 m[i][j] < m[i][k]가 되어야 한다.<br/>
이도 long 자료형으로 표현했기에 m[i][j] = (height[j] - height[i]) / (j - i)를 빌려왔다.<br/>
m[i][j] < m[i][k]는 (height[j] - height[i]) x (k - i) < (height[k] - height[i]) x (j - i)식과 동치이다.<br/>
이렇게 양방향으로 비교하면서 각 빌딩에서 볼 수 있는 최댓값을 찾았다.<br/>


그러면 O(N^3)이 되지만 N이 50으로 작아 유효하다 생각했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1027