# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 정렬

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
버블 소트 알고리즘을 다음과 같이 C++로 작성했다.<br/>

	bool changed = false;
	for (int i=1; i<=N+1; i++) {
	    changed = false;
	    for (int j=1; j<=N-i; j++) {
	        if (A[j] > A[j+1]) {
	            changed = true;
	            swap(A[j], A[j+1]);
	        }
	    }
	    if (changed == false) {
	        cout << i << '\n';
	        break;
	    }
	}


위 소스에서 N은 배열의 크기이고, A는 정렬해야 하는 배열이다. 배열은 A[1]부터 사용한다.<br/>
위와 같은 소스를 실행시켰을 때, 어떤 값이 출력되는지 구해보자.<br/>

## 입력
첫째 줄에 N이 주어진다. N은 500,000보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에 A[1]부터 A[N]까지 하나씩 주어진다. A에 들어있는 수는 1,000,000보다 작거나 같은 자연수 또는 0이다.<br/>

## 출력
정답을 출력한다.<br/>

## 예제 입력
5<br/>
10<br/>
1<br/>
5<br/>
2<br/>
3<br/>

## 예제 출력
3<br/>

## 풀이
버블 정렬 구현 방식을 보면 1 ~ N - i까지 탐색하면 남은 부분 중 가장 큰 값을 뒤로 보내고<br/>
이외 원소들은 정렬에서 자기자리가 아닌 경우 1번씩 움직인다.<br/>
그래서 작은 원소들이 자기자리를 찾아가는데 경우의 수를 찾고 최대값을 정답으로 생각했다.<br/>
찾는 방법으로는 정렬된 배열을 따로 만들고 이분탐색으로 커지는 인덱스 바로 앞으로 잡았다.<br/>
다른 사람의 풀이를 보니 2차원 배열을 할당하고 크기와 인덱스 순으로 정렬하니 깔끔하게 풀린다.<br/>

## 문제 링크
https://www.acmicpc.net/problem/1377