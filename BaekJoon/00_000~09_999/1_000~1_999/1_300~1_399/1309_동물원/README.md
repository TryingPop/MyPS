# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
어떤 동물원에 가로로 두칸 세로로 N칸인 아래와 같은 우리가 있다.<br/>

|||
|:---:|:---:|
|||
|||
|:|:|


이 동물원에는 사자들이 살고 있는데 사자들을 우리에 가둘 때, 가로로도 세로로도 붙어 있게 배치할 수는 없다. 이 동물원 조련사는 사자들의 배치 문제 때문에 골머리를 앓고 있다.<br/>
동물원 조련사의 머리가 아프지 않도록 우리가 2*N 배열에 사자를 배치하는 경우의 수가 몇 가지인지를 알아내는 프로그램을 작성해 주도록 하자. 사자를 한 마리도 배치하지 않는 경우도 하나의 경우의 수로 친다고 가정한다.<br/>


## 입력
첫째 줄에 우리의 크기 N(1≤N≤100,000)이 주어진다.<br/>


## 출력
첫째 줄에 사자를 배치하는 경우의 수를 9901로 나눈 나머지를 출력하여라.<br/>


## 예제 입력
4<br/>


## 예제 출력
41<br/>


## 풀이
사자의 배치한 상태만 알면 된다. 사자의 배치순서는 원하는대로 배치하면 된다.<br/>
경우의 수를 찾기 위해 위에서부터 사자를 배치하는 식으로 찾아간다.<br/>
배치 순서는 맨 위에 줄에서 왼쪽 오른쪽 순으로 배치해간다.<br/>


우리의 줄 수가 n개일 때, 각 줄에는 2개의 칸(왼쪽/오른쪽)이 존재하므로 총 n줄 x 2칸의 사자 배치 문제로 볼 수 있다.<br/>
현재 줄(i)의 배치 상태를 결정하려면, 바로 윗줄(i-1)의 상태 정보를 참조해야 하므로 점화식 기반의 DP 방법이 적합하다고 판단했다.<br/>


dp[i][j][k] = val를 i번째 줄이 남은 상태이고, j는 현재 줄의 윗줄(즉, i - 1번째 줄)에 대해, 현재 왼쪽/오른쪽 칸 위에 사자가 배치되어 있었는지를 2비트로 나타낸 비트마스크이다.<br/>
이전 칸에 배치한 경우 j & 2 = 2이고, 바로 위에 칸에 사자를 배치한 경우면 j & 1 = 1이다. 다음 상태는 j >> 1로 나타낼 수 있다.<br/>


k는 왼쪽(k = 0) 오른쪽(k = 1) 상태를 나타내고 val은 해당 상태(i번째 줄, 위쪽 상태 j, 현재 칸 k)에 대해 조건을 만족하는 사자 배치의 경우의 수를 의미한다.<br/>
다음과 같은 점화식을 얻는다.<br/>


먼저 현재 탐색하는 칸이 왼쪽 칸인 k = 0인 경우를 보자.<br/>
현재 칸에 사자를 미배치할 수 있다.<br/>
그래서 다음 오른쪽 칸을 확인 해야 한다. dp[i][j][0] += dp[i][j >> 1][1]<br/>


그리고 현재 칸에 사자를 배치할 수 있는지 확인한다.<br/>
왼쪽 → 오른쪽 순서로 탐색하기에 같은 행의 칸은 탐색할 필요 없고 위에 칸에 사자가 있는지만 확인하면 된다.<br/>
위에 칸에 없는 경우 현재 칸에 사자를 배치한다.<br/>


그래서 위에 칸에 사자가 없는 j & 1 = 0인 경우 dp[i][j][0] += dp[i][2 | (j >> 1)][1]이다.<br/>


이제 오른쪽 칸인 k = 1인 경우를 보자.<br/>
현재 칸에 사자를 미배치할 수 있다.<br/>
그래서 dp[i][j][1] += dp[i + 1][j >> 1][0]<br/>


그리고 현재 칸에 사자를 배치할 수 있는지 확인해야 하는데 같은 행과 위에칸을 확인해야 한다.<br/>
그래서 위와 옆에 모두 사자가 없는 j & 1 = 0 이고, j & 2 = 0인 경우 dp[i][j][1] += dp[i + 1][2 | (j >> 1)][0]이다.<br/>


이렇게 깊이가 n 까지 오면 1의 값을 반환하게 해서 탐색을한다.<br/>
그러면 dp[0][0][0]에 우리가 찾는 값이 담긴다.<br/>


해당 경우 줄 수 N이 최대 10만개이므로 우리는 총 2 x 10만개이다.<br/>
그리고 이전 사자 배치 상태는 4가지가 있으므로 전체 경우의 수는 4 x 20만 = 80만가지 경우를 탐색한다.<br/>
그래서 시간 복잡도는 O(8 x N) = O(N)이 된다.<br/>


dp에 모든 경우를 포함할 수 있어야 하므로 사용하는 메모리 역시 8 x N의 배열을 사용한다.<br/>


비트마스킹을 이용한 dp는 탐색하는 노드가 많다.<br/>
반면 각 가로 줄 i에 대한 경우의 수로 점화식을 찾아보면 dp2[i] = dp2[i - 1] * 2 + dp2[i - 2]를 얻을 수 있다.<br/>
이렇게 푸는 경우 시간 복잡도 측면에서는 O(N)으로 같지만, 사용하는 배열의 크기는 8 x N에서 N으로 많이 줄어든다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1309