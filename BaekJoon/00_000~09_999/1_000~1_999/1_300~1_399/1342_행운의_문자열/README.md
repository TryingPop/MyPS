# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 브루트포스 알고리즘
  - 백트래킹

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
민식이와 준영이는 자기 방에서 문자열을 공부하고 있다. 민식이가 말하길 인접해 있는 모든 문자가 같지 않은 문자열을 행운의 문자열이라고 한다고 한다. 준영이는 문자열 S를 분석하기 시작했다. 준영이는 문자열 S에 나오는 문자를 재배치하면 서로 다른 행운의 문자열이 몇 개 나오는지 궁금해졌다. 만약 원래 문자열 S도 행운의 문자열이라면 그것도 개수에 포함한다.<br/>


## 입력
첫째 줄에 문자열 S가 주어진다. S의 길이는 최대 10이고, 알파벳 소문자로만 이루어져 있다.<br/>


## 출력
첫째 줄에 위치를 재배치해서 얻은 서로 다른 행운의 문자열의 개수를 출력한다.<br/>


## 예제 입력
abcdefghij<br/>


## 예제 출력
3628800<br/>


## 풀이
서로 다른 문자열의 갯수를 찾아야 한다. 그래서 순열이 아닌 조합 형식으로 찾아야 한다.<br/>
aab인 경우 aba 를 위치별 a를 구분하지 않고 1번만 세면 된다.<br/>


기존 문자열을 재배치하므로 먼저 알파벳의 갯수는 불변이다.<br/>
그래서 소문자만 입력되므로 소문자 알파벳 갯수를 세어 재배치를 하고 가능하면 카운팅하면 된다.<br/>
그런데 이전 문자열과 다르게 문자열을 재배치하는 경우 전체 인접한 문자열이 다른 문자열과 동치가 되므로 이전 문자열과 다르게 배치해가며 세었다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1342