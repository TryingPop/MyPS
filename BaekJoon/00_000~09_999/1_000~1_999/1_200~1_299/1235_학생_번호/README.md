# C#

## 난이도 : 실버 4

## 알고리즘 분류
  - 구현
  - 문자열
  - 브루트포스 알고리즘

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
이번에는 학생들을 더욱 효율적으로 관리하기 위해 학생마다 고유한 학생 번호를 부여하기로 하였다. 학생 번호는 0부터 9 사이의 숫자로 이루어진 문자열로, 모든 학생들의 학생 번호는 서로 다르지만 그 길이는 모두 같다.<br/>
학생들의 번호를 부여해 놓고 보니, 김진영 조교는 어쩌면 번호가 지나치게 긴 것은 아닌가 싶은 생각이 들었다. 예를 들어 아래와 같은 7자리의 학생 번호를 보자.<br/>


|이름|번호|
|:---:|:---:|
|오민식|1212345|
|김형택|1212356|
|이동호|0033445|


이처럼 학생 번호를 굳이 7자리로 하지 않고, 뒤에서 세 자리만을 추려서 남겨 놓아도 모든 학생들의 학생 번호를 서로 다르게 만들 수 있다.<br/>


|이름|번호|
|:---:|:---:|
|오민식|345|
|김형택|356|
|이동호|445|


하지만 세 자리보다 적게 남겨 놓아서는 모든 학생들의 학생 번호를 서로 다르게 만들 수 없다.<br/>
학생들의 번호가 주어 졌을 때, 뒤에서 k자리만을 추려서 남겨 놓았을 때 모든 학생들의 학생 번호를 서로 다르게 만들 수 있는 최소의 k를 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에는 학생의 수 N(2≤N≤1,000)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 학생의 학생 번호가 순서대로 주어진다. 모든 학생들의 학생 번호는 서로 다르지만 그 길이는 모두 같으며, 0부터 9 사이의 숫자로 이루어진 문자열이 주어진다. 문자열의 길이는 100보다 작거나 같다.<br/>


## 출력
첫째 줄에 구하고자 하는 가장 작은 k값을 출력한다.<br/>


## 예제 입력
3<br/>
1212345<br/>
1212356<br/>
0033445<br/>


## 예제 출력
3<br/>


## 풀이
문제 조건대로 HashSet을 이용해 해결했다.<br/>
i = 1부터 문자열의 길이까지 뒤에서 i자리만 남긴 문자열을 HashSet에 넣는다.<br/>
그리고 HashSet이 n과 길이가 같아지는지 확인한다.<br/>


n이랑 같은 경우 i를 반환했다.<br/>
n보다 작은 경우 i의 값을 1을 올려 다시 HashSet을 초기화한 뒤 HashSet에 넣어 서로 다른게 n개인지 확인한다.<br/>


n의 크기가 1000으로 작고, 문자열의 길이도 100이하로 1000 x 100 = 10만이므로 충분히 시도할만하다.<br/>
다만 문자열을 10만개 가까이 생성할 수 있기에 메모리 사용량이 많다.<br/>


그런데 효율적으로 한다면 우선 i일 때 학생 번호 구분이 성립하는 경우 i + 1에서도 학생 번호 구분이 성립함을 알 수 있다.<br/>
그래서 매개변수 탐색으로 접근이 가능하다.<br/>
그래서 1000 x 100을 1000 x log 100으로 줄일 수 있다.<br/>


그리고 메모리 사용량은 문자열을 배열로 받고, 적당히 구분할 수 있는 해시를 구현하면 줄일 수 있다.<br/>
그런데 해당 방법은 해시 충돌 때문에 해시 구현 방법이 중요해진다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1235