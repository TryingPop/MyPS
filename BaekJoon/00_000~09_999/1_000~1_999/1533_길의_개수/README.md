# C#

## 난이도 : 플레티넘 3

## 알고리즘 분류
  - 수학
  - 그래프 이론
  - 분할 정복을 이용한 거듭제곱

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
세준이는 정문이를 데리러 공항으로 가기로 했다. 하지만, 방금 세준이는 정문이의 비행기가 연착된다는 전화를 받았다. 세준이는 정문이가 정확하게 몇 분 늦는지 알고 있고, 그 시간 동안 밖에서 드라이브를 하려고 한다. 정문이가 늦는 시간을 T라고 하자.<br/>
세준이는 자기가 지금 있는 위치에서부터, 공항까지 정확하게 T분만에 도착하는 경로의 개수를 구하고 싶다.<br/>
길의 정보는 인접행렬로 주어진다. A[i][j]가 0이라면 i에서 j로 가는 길이 없는 것이고, A[i][j] ≤ 5라면, 정확히 그 만큼의 시간이 걸리는 i에서 j로 가는 길이 있는 것이다.<br/>


## 입력
첫째 줄에 교차점의 개수 N이 주어진다. N은 10보다 작거나 같고, 시작점의 위치 S와 끝점의 위치 E, 그리고 정문이가 늦는 시간 T도 주어진다. S와 E는 N보다 작거나 같은 자연수이다. T는 1,000,000,000보다 작거나 같은 자연수이다. 둘째 줄부터 길의 정보가 주어진다.<br/>


## 출력
첫째 줄에 경로의 개수를 1,000,003로 나눈 나머지를 출력한다.<br/>


## 예제 입력
3 1 3 5<br/>
012<br/>
201<br/>
120<br/>


## 예제 출력
8<br/>


## 풀이
처음에는 3차원 배열로 접근해 dp[i][j][k] = val를 i일에서 j에서 k로 가는 경우의 수로 dp를 선언했다.<br/>
그리고 root[i][j][k]는 i일에서 j에서 k로 가는 경로라 생각하자. dp[i + j] += dp[i] x root[j] 여기서 x는 행렬곱을 의미한다.<br/>
이렇게 찾아가면 되지 않을까 생각했다. 예제는 통과했으나 i 가 10억 이상으로 커서 불가능한 방법이라 생각한다.<br/>


그래서 고민해도 답이 안나와 검색을하게 되었다. 그러니 행렬을 행과 열에 각각 최대 날짜 5 만큼 곱한 행렬로 확장한다.<br/>
그리고 i + 4 -> i + 3 -> i + 2 -> i + 1 -> i의 형태로 날짜가 지난 것을 단방향 경로를 추가해준다.<br/>
이후 행렬 곱으로 해결하는 아이디어였다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1533