# C#

## 난이도 : 브론즈 2

## 알고리즘 분류
  - 구현
  - 시뮬레이션

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
영식이와 친구들이 원형으로 모여서 시계방향으로 1부터 N까지 적혀있는 자리에 앉는다. 영식이와 친구들은 공 던지는 게임을 하기로 했다. 게임의 규칙은 다음과 같다.<br/>
일단 1번 자리에 앉은 사람이 공을 받는다. 그리고 나서 공을 다른 사람에게 던진다. 다시 공을 받은 사람은 다시 공을 던지고, 이를 계속 반복한다. 한 사람이 공을 M번 받았으면 게임은 끝난다. (지금 받은 공도 포함하여 센다.) 공을 M번보다 적게 받은 사람이 공을 던질 때, 현재 공을 받은 횟수가 홀수번이면 자기의 현재 위치에서 시계 방향으로 L번째 있는 사람에게, 짝수번이면 자기의 현재 위치에서 반시계 방향으로 L번째 있는 사람에게 공을 던진다.<br/>
공을 총 몇 번 던지는지 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 N, M, L이 입력으로 들어온다. N은 3보다 크거나 같고, 50보다 작거나 같은 자연수이고, M은 50보다 작거나 같은 자연수이다. L은 N-1보다 작거나 같은 자연수이다.<br/>


## 출력
첫째 줄에 공을 몇 번 던지는지 횟수를 출력한다.<br/>


## 예제 입력
5 3 2<br/>


## 예제 출력
10<br/>


## 힌트
예제 1의 경우 일단 1번이 공을 잡는다. 1번은 공을 한 번 잡았기 때문에, 공을 3번에게 던진다. 3번은 공을 한 번 잡았기 때문에, 공을 5번에게 던진다. 5번은 2번에게 던지고, 2번은 4번에게 던진다. 4번은 1번에게 던진다. 1번은 이제 공을 두 번 잡았기 때문에, 공을 4번에게 던진다. 4번은 2번에게 던지고, 2번은 5번에게 던지고, 5번은 3번에게 던지고, 마지막으로 3번은 1번에게 던진다. 1번은 이제 공을 세 번 잡았기 때문에, 게임은 끝난다.<br/>


## 풀이
N, M의 크기가 50으로 작고 0 < L < N이므로 시뮬레이션 돌려도 L x M < 2500으로 시뮬레이션 방법이 가능하다.<br/>


시뮬레이션 사용하면 1번에서 시작해서 다음 1번이 잡을때까지 한방향으로만 던짐을 알 수 있다.<br/>
그래서 시계방향인 +인 경우와 -인 경우를 나눠 보자.<br/>


+의 경우 가환군 Z_N에서 1부터 시작해 L만큼 계속 더하는 것과 같다.<br/>
그에 대응하는 원소는 {1, 1 + L, 1 + 2L, ... }이다.<br/>
이는 L이 생성하는 부분군 <L>과 원소의 수가 같다.<br/>
<L>의 원소의 수는 N과 L의 최대 공약수를 gcd라 하면 N / gcd개의 원소가 나옴을 군론에서 알려져 있다.<br/>
해당 경우 공을 총 N / gcd번 던진다.<br/>


-의 경우 가환군 Z_N에서 1부터 시작해 L만큼 계속 빼는 것과 같다.<br/>
그에 대응하는 원소는 {1, 1 - L, 1 - 2L, ...}이고 이는 {1, 1 + L, 1 + 2L, ... }와 같다.<br/>
그래서 마찬가지로 N / gcd번 던진다.<br/>


M번 공을 잡은 경우 종료되므로 (N / gcd) x (M - 1)번 공을 던지게 된다.<br/>
해당 경우 gcd를 찾아야 하므로 log L이고, 찾은 경우 사칙연산만 하면 되기에 시간 복잡도는 O(log(L))임을 알 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1592