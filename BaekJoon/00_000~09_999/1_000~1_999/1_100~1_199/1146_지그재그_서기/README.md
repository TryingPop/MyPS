# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 조합론

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
N명의 학생들이 있다. 이 학생들을 다음과 같은 방식으로 줄을 세우려고 한다.


  1. 맨 앞줄에는 아무나 설 수 있다.
  2. 둘째 줄에도 아무나 설 수 있다.
  3. 셋째 줄에는 둘째 줄에 서 있는 사람이 첫째 줄에 서 있는 사람보다 클 경우, 둘째 줄에 서 있는 사람보다 작은 사람만이 설 수 있으며, 둘째 줄에 서 있는 사람이 첫째 줄에 서 있는 사람보다 작을 경우, 둘째 줄에 서 있는 사람보다 큰 사람만이 설 수 있다.
  4. 넷째 줄부터는 둘째 줄과 셋째 줄을 비교하는 식으로 해서 N번째의 줄을 서는 사람은 N-2번째 줄과 N-1번째 줄에 서는 사람을 비교해서 세운다.


학생들이 1이 가장 작은 사람, N이 가장 큰 사람이며, 같은 키를 가진 사람이 없다고 할 때, 5명을 세운다면 1 - 3 - 2 - 5 - 4, 3 - 2 - 5 - 1 - 4 등의 방법으로 세울 수 있다.
문제는 N명의 학생을 이런 식으로 줄을 세울 때 총 몇 가지의 경우의 수가 생기는지 찾아내는 것이다.<br/>


## 입력
첫째 줄에 학생 수 N(1 ≤ N ≤ 100)이 입력된다.<br/>


## 출력
첫째 줄에 총 경우의 수를 1,000,000으로 나눈 나머지를 출력한다.<br/>


## 예제 입력
5<br/>


## 예제 출력
32<br/>


## 풀이
문제 조건에 맞춰 줄을 세운 경우를 보자.<br/>
앞에서부터 있는 학생의번호를 a_1, a_2, ..., a_n이라 하자.<br/>
그리고 인접한 항끼리 크기를 비교하면 다음이 성립한다.<br/>

  - a_1 > a_2 < a_3 > a_4 < ...
  - a_1 < a_2 > a_3 < a_4 > ... 

이를 보면 수 a_i들의 값은 별로 중요하지 않음을 알 수 있다.<br/>


예를들어 1, 2, 3, 4, 5의 경우 3 - 2 - 4 - 1 - 5 로 배치하면 3 > 2 < 4 > 1 < 5로 문제 조건을 만족한다.<br/>
서로 다른 5개인 원소 6, 8, 11, 13, 16에 대해 작은수부터 1씩 대응한다.<br/>

  - 1 ↔ 6
  - 2 ↔ 8
  - 3 ↔ 11
  - 4 ↔ 13
  - 5 ↔ 16

그리고 3 - 2 - 4 - 1 - 5을 해당 수대로 변형하면 11 - 8 - 13 - 6 - 15이고 이역시 11 > 8 < 13 > 6 < 15로 문제 조건을 만족한다.<br/>
즉, 수의 값은 경우의 수에 영향을 안준다.<br/>


앞에서부터 수를 하나씩 배치하면서 불가능한 경우를 알아보자.<br/>
a_1 > a_2 < a_3 > a_4 < ...의 경우로 찾아보자.<br/>


먼저 a_1에 숫자를 배치한다. 이후 a_2에 숫자를 배치해야 하는데 a_1보다 작은 수가 없다면 불가능하다.<br/>
만약 존재한다면 작은 수 중 아무거나 배치하면 된다.<br/>


다음으로 a_3에 값을 배치하는데, a_2보다 큰 값이 없다면 불가능하고 존재하면 a_2보다 큰 값을 아무거나 배치한다.<br/>


해당 경우를 보면 이전 값 prev보다 큰 것의 갯수 big, prev보다 작은 것의 갯수 small, 그리고 현재 prev와 현재 배치하는 연산자 \>, \<가 경우의 수에 영향을 줌을 알 수 있다.<br/>
그리고 앞의 이유로(동형사상) 남은 수 값들은 관계없이 big, small, 연산자만 일치하면 경우의 수가 같으면 경우의 수도 같음을 알 수 있다.<br/>
그리고 big, small 연산자의 값은 big + small - 1의 값에 영향받기에 dp의 방법으로 풀었다.<br/>


dp[big][small][k] = val를 big을 이전 prev보다 큰 수의 개수, small을 prev보다 작은 것의 개수로 한다.<br/>
그리고 k를 prev와 다음 연산자 관계로 할 때 k = 0이면 prev \> 현재, k = 1이면 prev \< 현재로 잡는다.<br/>
그리고 val는 경우의 수가 담기게 dp를 선언했다.<br/>


그러면 다음과 같은 점화식을 얻는다.<br/>
dp[big][small][0] = ∑dp[big + i][small - i - 1][1] (단, i는 0 ≤ i < small)<br/>
dp[big][small][1] = ∑dp[big - i - 1][small + i][0] (단 i는 0 ≤ i < big)<br/>


이렇게 진행했을 때 n명을 모두 배치한 big = 0, small = 0인 경우 dp[0][0][0] = dp[0][0][1] = 1로 삼는다.<br/>
이외 n명을 배치 시도했는데 big > 0이거나 small > 0인 경우 0으로 한다.<br/>


입력으로 들어오는 전체 인원 n은 n ≤ 100이므로 big ≤ 100, small ≤ 100이고 연산자는 2개다.<br/>
dp의 크기는 100 x 100 x 2 = 2만이된다.<br/>


또한 dp의 값이 채워진 경우 재 방문은 O(1)에 해결 가능하고 big, small은 많아야 dp의 크기만큼 방문한다.<br/>
그리고 dp[big][small][0] = ∑dp[big + i][small - i - 1][1], dp[big][small][1] = ∑dp[big - i - 1][small + i][0] 점화식으로 많아야 n개를 조사한다.<br/>
그래서 시간 복잡도는 O(n^3)이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1146