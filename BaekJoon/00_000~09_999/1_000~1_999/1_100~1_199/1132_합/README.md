# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 그리디 알고리즘

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
N개의 수가 주어진다. 이 숫자는 모두 자연수이고, 알파벳 A부터 J가 자리수를 대신해서 쓰여 있다. 이 알파벳은 모두 한 자리를 의미한다. 그리고, 각 자리수는 정확하게 알파벳 하나이다. 0으로 시작하는 수는 없다. 이때, 가능한 수의 합 중 최댓값을 구해보자.<br/>


## 입력
첫째 줄에 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각 수가 주어진다. 수의 길이는 최대 12이다. 적어도 한 알파벳은 수의 가장 처음에 주어지지 않는다.<br/>


## 출력
첫째 줄에 합의 최댓값을 출력한다.<br/>


## 예제 입력
10<br/>
A<br/>
BB<br/>
CCC<br/>
DDDD<br/>
EEEEE<br/>
FFFFFF<br/>
GGGGGGG<br/>
HHHHHHHH<br/>
IIIIIIIII<br/>
AJJJJJJJJJ<br/>


## 예제 출력
9973936905<br/>


## 풀이
처음에는 2초이므로 C#의 추가시간으로 10!의 방법도 유효해보였다.<br/>
그래서 0이 가능한 경우면 0을 채운다. 이후 나머지 문자에 1부터 9까지 값을 DFS로 배치해갔다.<br/>
그리고 알파벳을 숫자로 변환해 합들의 최댓값을 찾아갔다.<br/>
해당 방법으로 풀이를 제출하니 2.8초에 통과했다.<br/>


이후 다른 사람들의 풀이 시간을 보니 0.1초도 안걸렸고 힌트를 보니 그리디 알고리즘이 있었다.<br/>
그래서 고민하니 더 빠른 방법이 보였다.<br/>


특정 알파벳만 1로 이외는 0으로 숫자를 만들었을 때, 찾는다.<br/>
예를들어 AAAJ, 의 경우 특정 알파벳을 A라 하면 1110이 된다.<br/>
AAAJ에서 특정 알파벳이 B인 경우는 0이다.<br/>
그리고 AAAJ에서 특정 알파벳이 J인 경우는 1이다.<br/>
이렇게 A부터 J까지 값들을 찾아 각 경우에 맞게 누적해간다.<br/>


이렇게 찾은 숫자들에 값을 곱하는 것을 해당 알파벳에 값을 부여하는 것과 같다.<br/>
예를들어 AAAJ의 경우 A만 봤을 때 1110인데, A에 2를 곱해주면 1110 x 2 = 2220이다.<br/>
그리고 AAAJ에서 A에 2를 주는 경우 2220이된다.<br/>


이로 0을 줄 수 있는 값 중 가장 작은 값을 가진 알파벳에 0을 주고,<br/>
이외는 오름차순으로 1부터 9까지 배정한다.<br/>
그리고 배정한 값을 누적한 것이 그리디로 가장 큰 값임이 보장된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1132