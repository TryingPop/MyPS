# C#

## 난이도 : 실버 2

## 알고리즘 분류
  - 구현
  - 문자열
  - 정렬
  - 파싱

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 128 MB

## 문제
동혁이는 크로스워드 퍼즐을 좋아한다. R×C 크기의 크로스워드 퍼즐을 생각해 보자. 이 퍼즐은 R×C 크기의 표로 이루어지는데, 퍼즐을 다 풀면 금지된 칸을 제외하고는 각 칸에 알파벳이 하나씩 적혀 있게 된다. 아래는 R = 5, C = 5 인 경우 다 푼 퍼즐의 한 예이다. 검은 칸은 금지된 칸이다.<br/>

|g|o|o|d||
|:---:|:---:|:---:|:---:|:---:|
|a|n|||b|
|m|e|s|s|y|
|e|||i|t|
||l|a|t|e|

세로 또는 가로로 연속되어 있고, 더 이상 확장될 수 없는 낱말이 퍼즐 내에 존재하는 단어가 된다. 위의 퍼즐과 같은 경우, 가로 낱말은 good, an, messy, it, late의 5개가 있고, 세로 낱말은 game, one, sit, byte의 4개가 있다. 이 중 사전식 순으로 가장 앞서 있는 낱말은 an이다.<br/>
다 푼 퍼즐이 주어졌을 때, 퍼즐 내에 존재하는 모든 낱말 중 사전식 순으로 가장 앞서 있는 낱말을 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에는 퍼즐의 R과 C가 빈 칸을 사이에 두고 주어진다. (2 ≤ R, C ≤ 20) 이어서 R개의 줄에 걸쳐 다 푼 퍼즐이 주어진다. 각 줄은 C개의 알파벳 소문자 또는 금지된 칸을 나타내는 #로 이루어진다. 낱말이 하나 이상 있는 입력만 주어진다.<br/>


## 출력
첫째 줄에 사전식 순으로 가장 앞서 있는 낱말을 출력한다.<br/>


## 예제 입력
4 5<br/>
adaca<br/>
da##b<br/>
abb#b<br/>
abbac<br/>


## 예제 출력
abb<br/>


## 풀이
문제 설명이 부실하다. 해당 케이스가 없는지 모르겠지만 크기가 1칸인 칸은 세지 않아도 된다.<br/>
왼쪽에 문자가 없고 가로 길이가 2개 이상인 문자들을 저장한다.<br/>
똑같이 위쪽에 문자가 없고 세로 길이가 2개 이상인 문자들을 저장한다.<br/>
그리고 C#에서 제공하는 내부 문자열 비교함수를 이용해 정렬해주는 Array.Sort로 정렬 한 뒤 맨 앞의 문자를 출력하면 된다.<br/>
다만 단순 CompareTo로 가장 앞의 문자를 찾아가니 구현이 잘못되었는지 틀렸다.<br/>
msdn을 참고하니 string인 경우, object인 경우 주의 해야 한다.<br/>

[msdn 문자열 비교](https://learn.microsoft.com/ko-kr/dotnet/api/system.string.compareto?view=net-9.0) 에서 string과 object 부분을 참고하면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1706