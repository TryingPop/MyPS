# C#

## 난이도 : 골드 1

## 알고리즘 분류
  - 정렬

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
버블 정렬이란 배열에서 서로 인접해 있는 값을 비교해서 작은 값이 더 뒤에 있을 때 두 값을 바꾸어 주는 과정을 계속 반복하는 정렬 방법이다. N개의 서로 다른 정수가 A[0], A[1], ..., A[N-1]의 정수형 배열에 저장되어 있고, 이를 오름차순으로 정렬하기 위해 태국이는 다음과 같은 코드를 작성하였다.<br/>


	for (i=0; i<N; i++) {
	    flag = 0;
	    for (j=0; j<N-1; j++) {
	        if (A[j] > A[j+1]) {
	            flag = 1;
	            temp = A[j];
	            A[j] = A[j+1];
	            A[j+1] = temp;
	        }
	    }
	}


하지만 주어진 배열 A에 따라 변수 i가 모든 loop를 반복하지 않아도 정렬이 완료되기도 한다. 따라서 도현이는 다음과 같이 코드를 개선하였다.<br/>


	for (i=0; i<N; i++) {
	    flag = 0;
	    for (j=0; j<N-1; j++) {
	        if (A[j] > A[j+1]) {
	            flag = 1;
	            temp = A[j];
	            A[j] = A[j+1];
	            A[j+1] = temp;
	        }
	    }
	    if (flag == 0) {
	        break;
	    }
	}


도현이는 자신이 태국이보다 우월하다는 것을 증명하기 위해, 개선된 코드를 이용하여 주어진 배열 A를 정렬해 보려고 한다. 만일 정렬이 완료되었을 때(즉 for문을 빠져나왔을 때)의 i값이 작으면 작을수록 도현이의 코드가 더 빠른 것이 된다. 태국이를 이기고 싶은 도현이를 도와서, 배열 A에 저장된 수가 주어지면 정렬이 완료되었을 때 변수 i에 저장되어 있는 값을 구하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에는 정수 N(1 ≤ N ≤ 500,000)이 주어진다. 다음 줄에 배열 A를 이루는 N개의 정수가 빈 칸을 사이에 두고 순서대로 주어진다. 주어지는 정수는 절댓값이 2,147,483,647을 넘지 않는다.<br/>


## 출력
첫째 줄에 정렬이 완료되었을 때 변수 i에 저장되어 있는 값을 출력한다.<br/>


## 예제 입력
5<br/>
30 10 44 27 49<br/>


## 예제 출력
2<br/>


## 풀이
버블 소트 방법을 보면 매 탐색마다 가장 큰 원소는 자기 자리로 찾아 간다.<br/>
여기서 자기 자리는 정렬된 상태의 자리를 뜻한다.<br/>


반면 가장 큰 원소 이외의 원소로 보면 자기 자리보다 뒤에 있다면 매 버블소트 정렬당 모두 앞으로 1칸씩만 이동함을 알 수 있다.<br/>
그리고 자기자리로 모두 찾아갔다면 이는 정렬된 상태와 같다.<br/>
그래서 버블 소트로 정렬되는 시점은 자기 자리보다 뒤에 있는 원소에 한해서 거리가 가장 큰게 자기자리를 찾아갈 때와 같다.<br/>


이제 이를 찾는 것은 기존 인덱스와 값을 그대로 정렬한다.<br/>
그리고 값이 같은 경우 인덱스가 낮은 순으로 앞에오게 정렬한다.<br/>
이제 인덱스에대해 기존 인덱스 - 정렬된 상태의 인덱스의 값이 0보다 큰 경우에 한해 가장 큰 값을 찾아줘서 구했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/1838