# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 정렬
  - 이분 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
승관이와 영우는 앞으로 Q일 동안 점심을 같이 먹기로 했다.<br/>
승관이는 [u, v] 구간의 매운맛을 좋아하고 영우는 [x, y] 구간의 단맛을 좋아한다. (u, v, x, y는 매일 매일 기분 따라 바뀐다)<br/>
N가지 점심 메뉴의 매운맛 수치 a와, 단맛 수치 b가 주어지고, 앞으로 Q 일간의 u, v, x, y가 주어진다.<br/>
승관이와 영우의 점심 메뉴 선택을 돕기 위해, 날마다 승관이와 영우가 둘 다 좋아하는 메뉴의 수를 알려주는 프로그램을 만들어주자.<br/>


## 입력
입력의 첫 줄에 점심 메뉴의 수 N(1 ≤ N ≤ 10만)과, 점심을 같이 먹는 기간 Q(1 ≤ Q ≤ 5000)가 주어진다.<br/>
둘째 줄부터 N개의 줄에 각 메뉴의 매운맛, 단맛 수치인 a, b가 주어진다. (1≤ a, b ≤ 10억)<br/>
a, b값은 유니크하다. 즉 같은 a 값을 가지는 서로 다른 두 메뉴는 없고, 같은 b 값을 가지는 서로 다른 두 메뉴도 없다.<br/>
그 다음 줄부터 Q개의 줄에 각 날의 u, v, x, y가 주어진다. (1 ≤ u ≤ v ≤ 10억, v ≤ u + 10000, 1 ≤ x ≤ y ≤ 10억, y ≤ x + 10000)<br/>


## 출력
Q개의 줄에 줄마다 각 날의 영우와 승관이가 둘 다 좋아하는 메뉴의 수, 즉 u ≤ a ≤ v 이고, x ≤ b ≤ y 인 메뉴의 수를 출력한다.<br/>


## 예제 입력
6 4<br/>
10 50<br/>
30 30<br/>
20 70<br/>
60 20<br/>
70 40<br/>
100 10<br/>
1 1000 10 70<br/>
10 30 50 70<br/>
10 100 20 20<br/>
30 99 1 39<br/>

## 예제 출력
6<br/>
2<br/>
1<br/>
2<br/>


## 풀이
먼저 음식을 매운 맛으로 정렬한다.<br/>
쿼리가 주어지면 매운맛 범위 [u, v]에 대해 매운맛이 u보다 크거나 같은 가장 작은 인덱스 s를 이분 탐색으로 찾는다.<br/>
그리고 v보다 작거나 같은 가장 큰 인덱스 e를 이분 탐색으로 찾는다.<br/>
각 경우 log n의 연산을 한다.<br/>


각 맛의 수치는 고유하므로 u ≤ v ≤ u + 10_000인 폐구간 [u, v]에 속하는 매운맛 음식의 갯수는 1만개를 넘지 않는다.<br/>
이후 브루트포스로 단맛이 폐구간 [x, y]에 속하는 것을 조사한다. 이는 1만번 연산을 넘지 않는다.<br/>


이렇게 각 쿼리에 대해 갯수를 반환했다.<br/>
각 쿼리에 대해 이분 탐색 2번 2 log n연산을 하고, 많아야 10_000번 연산을 한다.<br/>
n이 10만이므로 log n < 18로 무시할만한 양이므로 각 쿼리마다 연산은 1만으로 잡는다.<br/>
쿼리는 많아야 5000개이므로 5000 x 1만 = 5000만번 한다.<br/>
그리고 초기 정렬으로 n log n 연산을 포함해도 충분히 시간안에 풀만한다고 파악했다.<br/>



만약 매운맛과 단맛이 고유하지 않았다면, 오프라인 쿼리와 세그먼트 트리를 이용해 풀었을 것이다.<br/>
먼저 매운맛이나 단맛을 기준으로 삼는다. 편의상 매운맛을 기준으로 삼는다.<br/>
그리고 쿼리와, 음식 모두의 단맛에 대해 좌표압축을한다.<br/>


쿼리를 이제 나누는데 매운맛의 시작지점 - 1인 u - 1와 끝지점인 v로 나눌 것이다.<br/>
그리고 단맛의 [x, y]의 정보를 담는다.<br/>


음식과 쿼리의 매운맛을 값을 기준으로 오름차순 한다.<br/>
여기서 음식과 쿼리의 값이 같은 경우 쿼리가 먼저 오게 한다.<br/>


이제 매운맛으로 정렬된 것을 하나씩 읽는다.<br/>
음식인 경우 세그먼트 트리에 단맛에 맞게 1을 추가한다.<br/>


쿼리인 경우 시작지점 - 1인 u - 1이면 세그먼트 트리에 단맛의 폐구간 [x, y]에 포함된 점의 갯수 p를 찾는다.<br/>
만약 쿼리의 끝 지점인 v이면 세그먼트 트리에 단맛의 폐구간 [x, y]에 포함된 점의 갯수 q를 찾는다.<br/>
그러면 q - p가 해당 쿼리에 맞는 음식의 갯수가 된다.<br/>
그래서 해당 방법으로 풀었을 것이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/12099