# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 애드 혹
  - 트리
  - 트리의 지름

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
트리는 사이클이 없는 연결 그래프이다. 정점 N개로 이루어진 트리는 N-1개의 간선으로 이루어져 있다.<br/>
트리의 두 정점 사이의 거리는 한 정점에서 다른 정점으로 갈 때, 지나는 간선 개수의 최솟값이다.<br/>
트리의 지름은 모든 두 정점 사이의 거리 중에서 가장 큰 값이다.<br/>
아래와 같은 조건을 만족하는 트리 중에서 지름이 가장 긴 것을 만들어보자.<br/>


  - 트리의 루트를 V라고 하자.
  - V에서 가장 거리가 먼 정점과의 거리를 D라고 하자.
  - 1보다 크거나 같고, D보다 작거나 같은 모든 i에 대해서, 거리가 i인 정점의 개수는 cnt[i] 이다.


cnt배열이 주어졌을 때, 만들 수 있는 트리 중에서 지름이 가장 큰 것의 지름을 출력하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 cnt 배열의 크기 N (1 ≤ N ≤ 50)이 주어진다.<br/>
둘째 줄에는 cnt 배열의 값이 cnt[1]부터 cnt[N]까지 차례대로 주어진다. (1 ≤ cnt[i] ≤ 1000)<br/>


## 출력
첫째 줄에 문제의 조건을 만족시키는 트리 중에서 지름이 가장 큰 것의 지름을 출력한다.<br/>


## 예제 입력
4<br/>
4 1 2 4<br/>


## 예제 출력
5<br/>


## 풀이
문제에서 트리에서의 두 노드 b와 c 사이의 거리 dis(b, c)는 b에서 c까지 가는 간선의 수로 정의된다.<br/>
트리는 사이클이 없는 연결 그래프이고, 두 노드 사이의 경로는 유일하다.<br/>
이로 dis(b, c)는 다음과 같은 공식으로 계산할 수 있다.<br/>


dis(b, c) = d(b) + d(c) - 2 × d(lca(b, c)) 이다.<br/>


여기서 d(b)는 루트와 노드 b 사이의 거리이며, lca(b, c)는 노드 b와 c의 최소 공통 조상이다.<br/>
거리 계산 시 사용할 것이다.<br/>


이제 트리의 지름을 구하는 방법을 보자.<br/>
트리에서 임의의 정점 하나를 잡고 BFS나 DFS를 통해 가장 먼 정점 a를 찾는다.<br/>
그리고 다시 a에서 가장 먼 정점을 찾으면, 그 정점을 b라 할 때 a와 b 사이의 거리가 트리의 지름이 된다.<br/>
이때 a와 b는 트리 내에서 가장 멀리 떨어진 두 정점이며, 지름의 양 끝점이다.<br/>


이제 이러한 성질을 이용해 아무 정점을 루트로 잡자.<br/>
그러면 그 루트에서 가장 먼 노드인 a는 거리 D에 위치하게 된다.<br/>
이제 dis(a, b) 가 최대가 되는 점을 b라 하자.<br/>


그러면 D는 트리안에서 루트와 가장 멀리 떨어진 노드와의 거리이므로 해당 정의로 b는 0 ≤ d(b) ≤ D를 만족한다.<br/>
그리고 d(c) = d(b)를 만족하는 모든 c에 대해 dis(a, c) ≤ dis(a, b)를 만족한다.<br/>
이는 dis(a, b)가 최대가 되는 점을 b라 했기에 정의로부터 자명하게 성립한다.<br/>


그래서 b를 찾는데 각 E = 0, 1, 2, ..., D에 대해 d(e) = E인 노드 e에 대해 가장 큰 거리를 f(E) = max(dis(a, e))라 하자.<br/>
그러면 dis(a, b) = max(f(E))가 성립한다.<br/>


이제 각 d(e) = E에서 F(E)를 찾아보자.<br/>
만약 d(e) = E인 노드가 유일하다면, 트리에서 경로는 유일하므로, 루트에서 a로 가는 경로는 딱 하나뿐이다.<br/>
깊이 1부터 D까지의 모든 노드를 차례로 거쳐서 이동하게 되며, d(e) = E인 노드가 유일하다는 것은 그 깊이에 노드가 하나만 있다는 뜻이다.<br/>
따라서 해당 노드는 루트에서 a로 가는 경로상에 포함될 수밖에 없고, 이는 곧 그 노드가 a의 조상이라는 의미다.<br/>
즉, 이 경우에는 lca(a, e) = e가 되고, 거리는 f(E) = dis(a, e) = d(a) - d(e)로 계산된다.<br/>


반면 d(e) = E인 노드가 2개 이상인 경우를 보자.<br/>
이 중 하나는 a의 부모가 될 수 있고 이를 i라 하자.<br/>
다른 하나는 a의 경로 외부에 존재할 수 있다. 이를 j라 하자.<br/>
그러면 lca(i, j) = lca(a, j)가 성립한다.<br/>


이제 a와 j의 거리를 최대화하고 싶을 때, dis(a, j) = d(a) + d(j) - 2 * lca(a, j)이고, d(a), d(j)는 고정된 값이다.<br/>
i가 a의 조상이므로 lca(i, j) = lca(a, j)이고, lca(i, j)의 깊이를 최대한 줄이는 것이다. 그래야 dis(a, j)가 커질 수 있기 때문이다.<br/>


이때 트리 구조상 중요한 성질이 있다. i와 j가 서로 다르고 같은 깊이에 있을 때는 lca(i, j)의 깊이는 d(j)보다 작다.<br/>
이는 트리의 경로가 유일하다는 성질과 사이클이 없다는 특성에서 나온다.<br/>
따라서 i와 j의 공통 조상은 반드시 그들보다 위쪽에 있어야 한다.<br/>


만약 d(e) = d(j) - 1인 노드 e가 단 하나뿐이라면, 그 노드는 i와 j의 최소 공통 조상이 되어야 한다.<br/>
트리에서 경로는 유일하므로, 루트에서 i로 가는 경로는 딱 하나뿐이다.<br/>
깊이 1부터 d(i)까지의 모든 노드를 차례로 거쳐서 이동하게 되며, d(e) = d(j) - 1인 노드가 유일하므로 해당 노드는 루트에서 i로 가는 경로상에 포함될 수밖에 없고, 이는 곧 그 노드가 i의 조상이라는 의미다.<br/>
똑같이 e가 j의 조상임을 보일 수 있다. 그래서 e는 i, j의 공통 조상이된다.<br/>


그래서 d(j) - 1 ≤ d(lca(i, j))이다.<br/>
그리고 d(lca(i, j)) < d(j)이므로 d(lca(i, j)) = d(j) - 1이된다.<br/>
따라서 lca(i, j) = e이다.<br/>
그리고 이 이상 d(lca(i, j))의 값을 줄일 수 없다.<br/>
f(E) = max(dis(a, j)) = dis(a, j) = d(a) + d(j) - 2 * (d(j) - 1)가 된다.<br/>


반면 d(e) = d(j) - 1인 노드 e가 두 개이상 존재한다면, 그 노드를 각각 i1, j1이라 하고, i1을 i의 부모가 되게 j1을 j의 부모가되게 i, j, i1, j1노드를 조절할 수 있다.<br/>
그러면 i1 != j1이고 i가 i1의 부모이고, j가 j1의 부모이다. 트리에서 경로는 유일하므로 lca(i, j) < d(j1)로 만들 수 있다.<br/>
이는 d(j) - 1인 경우를 lca(i, j)가 존재하지 않게 할 수 있다.<br/>


즉, d(lca(i, j))의 값을 줄이는 것이고 dis(a, j)의 값을 증가시키는 것이다.<br/>
그래서 d(e) = d(j) - 2인 경우 줄일 수 있는지 앞과 같이 확인한다.<br/>


이렇게 계속해서 lca(i, j)의 값을 줄여가며 조사한다.<br/>


d(e) = 0인 경우를 보자. 이는 루트와 거리가 0을 뜻한다.<br/>
루트와 거리 0인 노드는 루트뿐이고 이 경우 e는 유일하므로 해당 과정은 늦어도 0에서 끝남을 알 수 있다.<br/>


그래서 j의 조상 k를 대해 d(k)가 유일하고 j와 가장 가까운 조상이라 하자.<br/>
그러면 f(E) =  max(dis(a, j)) = d(a) + d(j) - 2 * d(k)가 된다.<br/>


각 경우에 대해 부모로 올라가면서 찾으면 k의 값을 O(N)에 찾을 수 있다.<br/>
N이 50이므로 조상의 갯수를 조사하면서 찾는 방법이 유효하다.<br/>


그런데 탐색 순서를 루트와 거리가 0부터 N까지 찾아가면, 현재와 가장 가까운 거리가 되므로 dp의 방법을 쓸 수 있다.<br/>
그래서 cnt[i] = 1인 경우 k에 저장하는식으로 확인해가면 k의 값을 O(1)에 찾을 수 있다.<br/>


이렇게 f(E)를 찾아가고 이 중 최댓값을 가능한 트리의 지름으로 제출했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/12947