# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 비트마스킹

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
희현이는 인터넷 ID를 만들 때 주로 쓰는 비밀번호가 있다. 하지만 이 비밀번호는 너무 길어서 희현이는 항상 쪽지에 적어 다니면서 확인을 한다. 하지만 장난꾸러기 영훈이는 이 쪽지를 가져가 1들 중 몇 개를 6로, 6들 중 몇 개를 1로 바꾸고 2들 중 몇 개를 7로 7들 중 몇 개를 2으로 바꾸는 장난을 쳤다. 따라서 영훈이가 장난쳐놓은 비밀번호 무용지물이 되었다. 왜냐하면 1이라고 쓰여 있어도 1 또는 6일수가 있고, 또한 6이라 쓰여 있어도 1 또는 6일수가 있다. 2과 7에서도 마찬가지이다. 하지만 희현이는 이러한 상황에 대비하여 비밀번호에 대한 한 가지 단서를 만들어 놓았는데 이는 다음과 같다.<br/>
비밀번호 수열의 숫자 중 1과 6을 모두 1로, 2와 7을 모두 2으로 바꾼 숫자와 1과 6을 모두 6으로 2과 7을 모두 7로 바꾼 숫자 사이에 가능한 경우를 모두 사전순으로 나열한 다음 그 중 k번째가 비밀번호이다.<br/>
따라서 이 단서를 통해 멘붕에 빠진 희현이를 도와 비밀번호를 다시 찾아보자.<br/>


## 입력
첫째 줄에 영훈이가 장난을 쳐서 바뀐 비밀번호가 주어진다. (비밀번호의 길이는 60자까지이고 첫 숫자가 0일수도 있다.)<br/>
둘째 줄에 숫자 k가 주어진다. (k ≤ 2^63 – 1)<br/>


## 출력
첫째 줄에 원래 비밀번호를 출력한다.<br/>
만약 k번째 비밀번호가 존재하지 않으면 -1을 출력한다.<br/>


## 예제 입력
1234567890<br/>
4<br/>

## 예제 출력
1234567890<br/>


## 풀이
해당 수에서 자리별로 읽으며 1, 2, 6, 7의 갯수 n를 찾는다.<br/>
그러면 가능한 비밀번호는 2^n개 있다.<br/>
k > 2^n인 k번째 비밀번호는 존재하지 않는다.<br/>


이후 사전순으로 k번째의 규칙을 보면 k - 1을 이진 수로 나타냈을 때,<br/>
뒤에서부터 0은 최솟값을, 1은 최댓값으로 변환하는 것과 같게된다.<br/>


즉, k = 3인 경우 16에 대해 보자.<br/>
16에서 1, 2, 6, 7의 갯수는 2개이고, 2^2 >= k이므로 k번째 비밀번호가 존재한다.<br/>
k - 1 = 2 = 10(2)이된다.<br/>
그러면 k - 1을 이진수로 바꾼 뒤에서 첫 번째 값이 0이므로 16에서 뒤에서 첫 번째 1, 2, 6, 7인 6은 최솟값의 형태여야 한다.<br/>
그래서 6의 값은 1이어야 한다.<br/>
다음으로 k - 1을 이진수로 바꾼 뒤에서 두 번째 값은 1이므로 16에서 뒤에서 두 번째 1, 2, 6, 7인 1은 최댓값의 형태여야 한다.<br/>
그래서 6으로 되어야 한다.<br/>
따라서 정답은 61이다.<br/>


이를 코드로 구현하면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/12025