# C#

## 난이도 : 골드 1

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 배낭 문제

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
세 모질이들 관우, 철환, 길원이가 모였다. 모질이들은 모이면 서로 '햄버거 최대 몇 개 드실 수 있나요?'의 준말인 '햄최몇?'을 시전하며 자랑을 하기 바쁘다.<br/>
막내 길원이는 문득 중요한 사실을 깨달았다. 바로, 개수가 중요한 것이 아니라 최대 효용이 중요하다는 것이었다! 이들은 바로 N개의 햄버거를 준비했다. 그리고 이 햄버거를 사이좋게 나누어 먹었다. 각 모질이들이 얻을 수 있는 효용은 이들이 먹은 햄버거들의 효용의 합이다. 또한 나름의 서열과 규칙이 있어, 존경하는 선배님들보다는 높은 효용을 누려서는 안 된다.<br/>
막내 길원이는 선배님들을 존경하기 때문에 규칙을 따라야 하는 한편, 햄버거를 잘 분배하여 본인이 얻을 수 있는 효용이 최대가 되도록 하고 싶다.<br/>


## 입력
첫 번째 줄에 N (1 ≤ N ≤ 50)이 주어진다. N은 햄버거의 수이다.<br/>
두 번째 줄에 N개의 양의 정수 ai (1 ≤ ai ≤ 50)가 공백으로 구분되어 주어진다. 각각의 값은 햄버거의 효용을 의미한다.<br/>


## 출력
세 모질이 중 막내 길원이가 얻을 수 있는 효용의 합의 최댓값을 출력한다.<br/>


## 예제 입력
10<br/>
4 37 50 2 6 15 2 13 3 10<br/>


## 예제 출력
46<br/>


## 풀이
dp[i][j][k] = val를 i 번째까지 햄버거를 선택했을 때, 1번이 선택한 무게 j, 2번이 선택한 무게 k에 가능한 여부 val를 담는다.<br/>
그러면 dp[i][j][k]가 true이면, dp[i +1][j + arr[i + 1][k] = true이고, dp[i + 1][j][k + arr[i] = true, dp[i + 1][j][k] = true가 된다.<br/>
이렇게 i를 n번까지 진행한 뒤 dp[n][j][k] = true인 j, k에 대해 j, k, sum - j - k중 가장 작은 값이 길원이가 받는 양이 된다.<br/>
여기서 sum은 1번에서 n번까지 햄버거의 총합이 된다.<br/>
그런데, for문의 순서를 i에 대해 모든 j, k를 순차적으로 조사를 진행해 가면, 하나의 dp로 해결할 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/19645