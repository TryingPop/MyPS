# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 구현
  - 브루트포스 알고리즘
  - 시뮬레이션
  - 많은 조건 분기
  - 백트래킹

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
어린 빛의 왕은 장난감을 좋아한다. 요즘 좋아하게 된 장난감은 (N x M)크기인 직사각형 판의 각 칸에 대각선 모양의 거울을 꽂고 뺄 수 있는 장난감이다. 거울들을 적절하게 꽂아 넣은 다음에, 레이저를 어떤 테두리 칸의 중심을 향하고 그 칸의 변에 수직이게 쏘면 다른 칸으로 레이저가 나오는데 이것을 보고 신기해하며 좋아하는 것이다. 어린 빛의 왕은 테두리에 있는 각 칸에 아래와 같은 방법으로 자연수 번호를 하나씩 붙였다.<br/>

  - 위쪽의 M개의 칸 : 왼쪽에서 오른쪽으로 1에서 M까지
  - 왼쪽의 N개의 칸 : 위쪽에서 아래쪽으로 M+1에서 M+N까지
  - 오른쪽의 N개의 칸 : 위쪽에서 아래쪽으로 M+N+1에서 M+N+N까지
  - 아래쪽의 M개의 칸 : 왼쪽에서 오른쪽으로 M+N+N+1에서 M+N+N+M까지

예를 들어 2 x 3크기의 직사각형 판의 테두리는 아래와 같이 번호 붙여지는 것이다.

| |1|2|3| |
|:---:|:---:|:---:|:---:|:---:|
|4| | | |6|
|5| | | |7|
| |8|9|10| |

어린 빛의 왕은 요즘 x에 레이저를 쏘면 y로 레이저가 나오는 장난감에 큰 관심을 가지고 있다. 또한 어린 빛의 왕은 특별한 배치의 장난감을 원하기 때문에 그가 원하는 거울의 배치가 길이가 M인 문자열 N개로 주어진다. 각 문자의 구성은 아래와 같다.<br/>

  - / : 왼쪽에서 레이저가 들어오면 위쪽으로 반사, 위쪽에서 레이저가 들어오면 왼쪽으로 반사, 오른쪽에서 레이저가 들어오면 아래쪽으로 반사, 아래쪽에서 레이저가 들어오면 오른쪽으로 반사하는 거울.
  - \\ : 왼쪽에서 레이저가 들어오면 아래쪽으로 반사, 위쪽에서 레이저가 들어오면 오른쪽으로 반사, 오른쪽에서 레이저가 들어오면 위쪽으로 반사, 아래쪽에서 레이저가 들어오면 왼쪽으로 반사하는 거울.
  - . : 거울이 없어 레이저가 아무 방해를 받지 않고 지나갈 수 있는 칸.
  - ? : 위의 셋 중 어떤 것이라도 상관 없는 칸.

?의 개수에 따라 만들 수 있는 배치의 개수가 많아질 수 있다. 그 중 x에 레이저를 쏘면 y로 레이저가 나오는 배치의 개수를 구하는 프로그램을 작성하라.<br/>


## 입력
첫 번째 줄에 직사각형 판의 크기를 의미하는 두 정수 N, M (1 ≤ N,M ≤ 8)과 x, y (1 ≤ x,y ≤ 2(N+M)) 가 공백으로 구분되어 주어진다.<br/>
다음 N개의 줄의 각 줄에는 길이가 M인 문자열이 주어진다. 이 문자열은 '/', '\', '.', '?'로만 이루어져 있다.<br/>
이 문제는 두 개의 부분 문제로 이루어져 있다.<br/>
1번 문제의 입력은 '?'의 개수가 12개 이하이며 해결하면 10점을 얻을 수 있다.<br/>
2번 문제의 입력은  '?'의 개수가 64개 이하이며 해결하면 90점을 얻을 수 있다.<br/>


## 출력
첫 번째 줄에 x에 레이저를 쏘면 y로 레이저가 나오는 배치의 개수를 10,007로 나눈 나머지를 출력한다.<br/>


## 예제 입력
2 2 1 8<br/>
??<br/>
??<br/>

## 예제 출력
6<br/>


## 풀이
?의 갯수가 최대 12개라 한다. 3^12 < 55만이므로 ?를 다른 타일로 변환할 수 있다.<br/>
그리고 빛의 이동은 많아야 2번 방문하기에 128을 곱해도 7000만을 넘지 못한다.<br/>
그래서 브루트포스로 ?를 변형시킨 맵을 만들고 시뮬레이션 돌려 정답을 구할 수 있다.<br/>


그런데 해가되는 집합을 보면, 목표지점까지 가는데 방문하지 않은 ?의 갯수가 k라고하면 중복이 3^k번씩 일어남을 알 수 있다.<br/>
그래서 DFS로 진행하되 남은 ?갯수로 해당 경로의 갯수를 확인하면 중복 경로를 제거하기에 더 빠르게 정답을 찾을 수 있다.<br/>


다만, 레이저가 중복 방문 하는 경우를 캐치하지 못해 시간을 많이 썼다.<br/>
다음과 같은 맵을 보자.<br/>

| |1|2|3| |
|:---:|:---:|:---:|:---:|:---:|
|4|?|.|?|7|
|5|／|／|.|8|
|6|＼|／|?|9|
| |10|11|12| |

그리고 2 에서 8로 가는 경로를 보자.<br/>

| | |1| |2| |3| | |
|:---:|:---:|:---:|:---:|:---:|
| | | | |｜| | | | |
|4| |?| |.| |?| |7|
| | | | |｜| | | | |
|5| |／|―|／|―|.|―|8|
| | |｜| |｜| | | | |
|6| |＼|―|／| |?| |9|
| | | | | | | | | |
| | |10| |11| |12| | |


## 문제 링크
https://www.acmicpc.net/problem/10725