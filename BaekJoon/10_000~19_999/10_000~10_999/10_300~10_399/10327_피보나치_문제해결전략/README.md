# C#

## 난이도 : 플레티넘 3

## 알고리즘 분류
  - 수학
  - 정수론
  - 확장 유클리드 호제법

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
피보나치 수열의 매력에 빠진 현욱이는 피보나치 수열을 너무나도 사랑한 나머지 '피보나치 문제해결전략' 책을 사서 읽다가 Gabonacci 수열의 존재에 대해 알게 된다.<br/>
당연히 피보나치 수열에 대해서 알고 있을 것이다. 만약 모른다면  2747번 문제를 풀어 보는 것을 권장한다. n번째 피보나치 항을 Fn이라 할 때 F1 = 1, F2 = 2이며, 그 이후의 항들은 모두 바로 전 2개 항의 합이다. 이러한 귀납적 정의에 따라 피보나치 수열은 1, 1, 2, 3, 5, 8, 13, . . .. 으로 이어진다.<br/>
이제 이를 좀 더 일반화해 보자. 어떤 수열이 피보나치 수열과 같은 재귀적 정의<br/>
G i = Gi-1 + Gi-2 for i > 2<br/>
를 따르지만, 처음 두 항을 G 1 ≤ G2 를 만족하게 하면서 임의로 설정할 것이다. 이를 Gabonacci 수열이라고 한다. 만약 G1 = 1, G2 = 3이면, 널리 알려진 수열인 Lucas numbers(1, 3, 4, 7, 11, 18, 29, . . ..)를 얻을 수 있다.<br/>
적절한 두 개의 첫 항을 골라서, 당신이 원하는 어떤 자연수를 반드시 Gabonacci 수열에서 등장하게 할 수 있다. 예를 들면, n은 1, n-1로 시작하는 Gabonacci 수열에서 등장한다. 그러나 현욱이는 이건 너무 쉽다고 생각했다. 그래서 가능한 한 작은 항으로 시작해 n이 등장하게 하고 싶다.<br/>


## 입력
첫 번째 줄에는 테스트 케이스의 개수 T가 주어진다. (T ≤ 100) 두 번째 줄부터 각 테스트 케이스에 대해 나타나게 해야 할 정수 n이 주어진다. (2 ≤ n ≤ 10^9)<br/>


## 출력
각 테스트 케이스마다 한 줄에 두 자연수 a, b를 출력한다. (0 < a ≤ b) G1 = a, G2 = b, 그리고 어떤 자연수 k에 대해 Gk = n 이다. a, b는 가능한 한 제일 작아야 하며, 이는 어떤 자연수 a', b'에 대해서 a', b'로 시작하는 Gabonacci 수열에서 n이 등장하고, b' < b 이거나 b' = b 이고 a' < a 인 a', b' 가 존재하면 안 된다는 뜻이다.<br/>


## 예제 입력
5<br/>
89<br/>
123<br/>
1000<br/>
1573655<br/>
842831057<br/>


## 예제 출력
1 1<br/>
1 3<br/>
2 10<br/>
985 1971<br/>
2 7<br/>


## 풀이
i번째 피보나치 수를 F(i)라 하자. 피보나치 수열의 점화식으로 모든 자연수 k에 대해 F(k) + F(k + 1) = F(k + 2)가 성립한다.<br/>
그리고 x, y의 최대공약수를 찾는 유클리드 호제법은 x = qy + r (0 ≤ r < y)의 형태로 만들면서 r = 0이 될 때까지 찾아간다. 그리고 r = 0일 때 y가 최대 공약수이다.<br/>


F(k), F(k + 1)의 최대 공약수는 각 i에 대해 F(i + 2) = F(i + 1) + F(i)의 형태로 진행되어 가고 F(k), F(k + 1)의 최대 공약수는 F(1) = 1을 반환함을 알 수 있다.<br/>
즉, 모든 자연수 k에 대해 F(k), F(k + 1)의 최대공약수는 1이다.<br/>


베주 항등식으로 aF(k) + bF(k + 1) = 1인 정수 a, b가 항상 존재함을 알 수 있다.<br/>
그리고 aF(k) + bF(k + 1) = 1인 a, b는 확장된 유클리드 호제법으로 찾는다.<br/>


양변에 n를 곱하면 naF(k) + nbF(k + 1) = n이다.<br/>
여기서 u = na + tF(k + 1), v = nb - tF(k)라 하자.<br/>
그러면 마찬가지로 uF(k) + vF(k + 1) = naF(k) + nbF(k + 1) + tF(k)F(k + 1) - tF(k)F(k + 1) = naF(k) + nbF(k + 1) = n이다.<br/>



그리고 F(k + 1) > 0이므로 t가 커질수록 v = nb - tF(k)의 값은 작아진다.<br/>
그래서 u ≤ v인 가장 작은 v는 t의 u ≤ v인 가장 큰 t를 찾는 것과 같다.<br/>


u = na + tF(k + 1), v = nb - tF(k)이고 u ≤ v이므로, t(F(k + 1) + F(k)) ≤ nb - na이다.<br/>
그래서 F(i) > 0 이므로 t ≤ (nb - na) / (F(k + 1) + F(k))를 만족하는 가장 큰 t를 찾는다.<br/>
이제 찾은 t를 대입하면 u ≤ v인 가장 작은 v가 된다.<br/>
이후 0 < u인지 확인하면 된다.<br/>


이렇게 각 i에 대해 aF(i) + bF(i + 1) = 1인 a, b를 확장된 유클리드 호제법으로 찾는다.<br/>
그리고 u = na + tF(i + 1), v = nb + tF(i)에 대해 u ≤ v인 t ≤ (nb - na) / (F(k + 1) + F(k))를 이용해 가장 작은 v를 찾는다.<br/>
마지막으로 0 < u라면 후보에 넣는다.<br/>
이렇게 모든 후보를 조사해 정답을 찾을 수 있다.<br/>


u, v가 양수가 되어야하므로 F(i + 1) ≤ n인 i에 대해서만 조사하면 된다.<br/>
n의 범위가 10억이므로 전처리로 확인한 결과 44개를 넘기지 않는다.<br/>
그리고 각 경우 유클리드 호제법으로 log n의 시간을 넘기지 못한다.<br/>
이외 연산은 O(1)에 해결된다.<br/>
그래서 모든 경우를 확인해도 유효함을 알 수 있다.<br/>


그런데, 그리디로 가장 큰 i에서 0 < u ≤ v인 가장작은 v를 찾았다면 해당 값을 정답으로 해도 된다.<br/>
이는 우리가 찾은 값이 uF(i) + vF(i + 1) = n이고 F(i) ≤ F(i + 1)이므로 i의 값이 클수록 v의 값이 작아짐을 알 수 있기 때문이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/10327