# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 그리디 알고리즘
  - 정렬
  - 스위핑

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 256 MB

## 문제
국경을 따라 순환 도로를 건설한 국가가 있다. 이 순환 도로에는 N개의 위치에 버스 정류소가 있으며, 버스 정류소에는 0부터 N-1까지 번호가 시계방향 순서로 지정되어 있다. 현재 여러 개의 버스 노선들이 이 순환 도로에서 운행되고 있다. 각 버스 노선은 [a, b]로 표시된다. 이 노선의 버스는 버스 정류소 a부터 b까지를 시계방향으로, b부터 a까지는 반시계방향으로 운행한다. 순환 도로 상의 모든 정류소를 포함하는 버스 노선은 존재하지 않는다.<br/>
국가 교통행정부에서 비용 절감을 위해서 버스 노선 중 일부를 취소하려고 한다. 취소되는 노선은 다른 노선에 포함되어 있는 노선이다. 예를 들어, N=10일 때, 5개의 버스 노선이 다음과 같이 있다고 하자.<br/>
\[0, 4\], \[2, 6\], \[5, 0\], \[7, 9\], \[9, 4\]<br/>
위 그림에서 버스 노선 ①은 ⑤에 포함되고, 버스 노선 ④는 ③에 포함된다. 버스 노선 ②, ③, ⑤를 포함하는 노선은 없다. 따라서 취소되는 버스 노선은 ①과 ④이다.<br/>
버스 노선에 대한 정보가 주어질 때, 취소되지 않고 계속 운행되는 버스 노선을 모두 출력하는 프로그램을 작성하시오.<br/>


## 입력
첫 번째 줄에는 버스 정류소의 개수 N(3 ≤ N ≤ 1,000,000,000)이 주어지고 두 번째 줄에는 버스 노선의 수 M(2 ≤ M ≤ 500,000)이 주어진다. 각 버스 노선은 1부터 M까지의 번호로 구분된다. 그 다음 M개의 줄에는 1번 노선부터 순서대로 각 버스 노선 [a, b]를 나타내는 두 개의 정수 a와 b가 한 줄에 주어진다, 단, 0 ≤ a, b ≤ N-1이고 a ≠ b이며 동일한 버스 노선이 두 번 이상 입력으로 주어지는 경우는 없다. 또한 순환 도로 상의 모든 정류소를 포함하는 버스 노선은 존재하지 않는다.<br/>


## 출력
입력으로 주어진 버스 노선들 중에서 다른 노선에 포함되지 않은 노선들의 번호를 번호가 작은 것부터 순서대로 빈칸을 사이에 두고 출력한다.<br/>


## 예제 입력
20<br/>
4<br/>
14 17<br/>
18 3<br/>
8 6<br/>
9 13<br/>


## 예제 출력
3<br/>


## 풀이
간선을 두 가지로 구분한다.<br/>
0번 n - 1번 정류장을 지나지 않는 간선들 1번과 0번 정류장과, n - 1번 정류장을 지나는 간선들 2번으로 구분한다.<br/>


간선 1번에 한해서 포함되는 간선을 제거하자.<br/>
간선 1을 시작 지점으로 오름차순 정렬하고, 시작 지점이 같으면 끝지점을 내림차순이되게 정렬한다.<br/>
앞에서부터 하나씩 읽는데 매번 끝의 지점의 최댓값을 확인한다.<br/>
현재 간선의 끝지점이 이전 모든 간선들의 끝지점의 최댓값보다 작은 경우 앞지점이 오름차순이므로 해당 최댓값을 갖는 간선에 포함되게 된다.<br/>
그래서 포함여부를 확인하고 끝지점의 최댓값을 갱신한다.<br/>


간선 2번에 한해서 포함되는 간선을 제거하자.<br/>
간선 2도 간선 1처럼 시작 지점으로 오름차순 정렬하고, 시작 지점이 같으면 끝 지점을 내림차순이 되게 정렬한다.<br/>
이제 앞에서부터 하나씩 읽는다. 다음 간선은 이전 간선의 시작지점에 포함됨은 자명하다.<br/>
여기서도 뒷 부분을 읽는데, 이전 뒷 부분의 최댓값보다 작은 경우 뒷부분도 포함되므로 해당 간선은 끝지점의 최댓값을 갖는 간선에 포함되게 된다.<br/>


간선 2는 0번과 n - 1번을 지나므로 간선 1에 포함되지 않는다.<br/>
반면 간선 1은 간선 2에 포함될 수 있다.<br/>
간선 1의 시작지점이 간선 2의 0번 인덱스 즉 가장 작은 시작지점보다 작은 경우 해당 간선은 간선 2의 어느 간선에도 포함될 수 없다.<br/>
또한 간선 1의 끝 지점이 간선 2의 가장 큰 끝지점보다 큰 경우 포함되지 않는 부분이 존재하므로 해당 간선 역시 포함이 안된다.<br/>
반면 이외의 경우는 간선 2에 포함되게 된다.<br/>


먼저 간선 1의 시작지점이 간선 2의 0번 인덱스의 시작 지점보다 작은 경우 간선 2는 n - 1과 0을 지나고, 간선 1은 n - 1과 0을 지나지 않으므로 포함될 수 밖에 없다.<br/>
또한 간선 2의 가장 큰 끝지점이 간선 1의 끝지점보다 작은 경우 간선 2의 특징으로 포함됨은 자명하다.<br/>
이렇게 포함되는 간선을 찾으면 모든 포함되는 간선을 찾은 것이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/10165