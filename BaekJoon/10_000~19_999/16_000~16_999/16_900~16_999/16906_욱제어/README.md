# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 자료 구조
  - 그래프 이론
  - 그래프 탐색
  - 정렬
  - 트리
  - 깊이 우선 탐색
  - 트라이

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
욱제어는 욱제가 사용하는 언어이고, 알파벳으로 0과 1만 사용한다. 욱제어에는 N개의 단어가 있는데, 각 단어의 길이는 L1, L2, ..., LN이다. 욱제어를 사용하는 사람들은 단어를 끝까지 말하지 않아도, 서로 어떤 단어인지 이해하는 경우가 많다. 그 이유는 한 단어가 다른 단어의 접두어(Prefix)가 되는 경우가 없기 때문이다.<br/>
욱제어를 공부하고 싶었던 동탄 주민 준오는 욱제어에 대한 정보를 몰래 입수했다. 하지만, 단어는 입수하지 못하고 단어의 길이만 입수하는데 성공했다. N개의 단어 길이 L1, L2, ..., LN이 주어졌을 때, 한 단어가 다른 단어의 접두어가 되지 않게 단어를 만들 수 있는지 알아보자.<br/>


## 입력
첫째 줄에 단어의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄에는 L1, L2, ..., LN이 주어진다. 단어 길이의 총합은 1,000보다 작거나 같은 자연수이다.<br/>


## 출력
욱제어 단어를 N개 만드는 것이 가능하면, 첫째 줄에 1을 출력하고, 둘째 줄부터 N개의 줄에 욱제어의 단어를 한 줄에 하나씩 출력한다. 단어는 입력으로 주어진 순서를 만족해야 한다. 즉, 길이가 L1인 단어, 길이가 L2인 단어, ..., 길이가 LN인 단어를 출력해야 한다.<br/>
욱제어 단어를 N개 만드는 것이 불가능하면 -1을 출력한다.<br/>


## 예제 입력
3<br/>
1 2 3<br/>


## 예제 출력
1<br/>
0<br/>
10<br/>
110<br/>


## 풀이
한 단어가 다른 단어의 접두어가 되면 안된다.<br/>
길이가 짧은거부터 만드는 경우 이전 단어가 만들었던 방법으로 앞부분을 만드는 경우 접두어가 된다.<br/>
그래서 앞 부분과는 다른 길로 단어를 만들어가는데 모든 수를 만들 수 있는지 확인하면 된다.<br/>


이제 수를 만드는 방법은 트라이 자료구조의 방법을 응용했다.<br/>
연결리스트 형태로 노드를 만들고, 각 사용한 단어를 하나씩 노드로 표현하고 이어주는 식으로 단어를 표현했다.<br/>
노드가 향하는 길은 0 또는 1이고, 0을 우선으로 가려고 한다.<br/>


0의 길이 아직 다 사용안되었다면 0의 길로 들어가며 값을 채워간다.<br/>
그리고 0의 길이 막혔다면 1의 길로 간다.<br/>
둘 다 막혔을 경우 어느 문자가 접두어로 쓰였다는 의미와 동치이고 이는 생성이 불가능한 경우다.<br/>


해당 노드의 길을 다 사용했는지 확인하는 block 변수를 노드에 넣었다.<br/>
block 노드는 문자열의 끝인 경우 true이고, 다음 루트의 노드들이 모두 block인 경우 현재 노드도 block이 되게 했다.<br/>
이는 DFS 방식으로 구현했다.<br/>


이렇게 확인하는 경우 사용되는 노드는 많아도 3000개를 넘지 못한다.<br/>
가장 많이 사용될 때는 모두 길이가 최대일 때인데, 이 경우 끝 노드로 향하는 길이 모두 다르게 된다. 끝 노드 1000개이다.<br/>
나머지 부모노드들은 이진 트리 형태로 보면 자식의 갯수 2배인 2000개를 넘지 못하고 3000개 이하이다.<br/>
그래서 노드의 길이는 3000으로 했다.<br/>


노드에 끝을 확인하고 해당 문자열의 길이를 len 변수에 기록했다.<br/>
이는 출력을 위해서이다.<br/>
문자열의 길이가 i인 경우 길이 i인 노드를 찾는다.<br/>
찾은 경우 중복해서 찾지 않기 위해 길이를 비활성화 시키면 된다.<br/>
그리고 이전 값으로 이동해야 하기에 prev 변수를 둬서 이전 노드를 기록했다.<br/>
이렇게 prev길을 타면서 첫 노드로 올 때까지 이동하면 경로는 찾는 문자열의 역순이 된다.<br/>
그래서 스택을 이용해 출력하면 된다.<br/>


최대 문자열의 길이가 1000이다. 그래서 노드의 갯수는 3000개 이하이다.<br/>
N의 최댓값이 1000으로 1000 x (노드의 갯수 + 최대 문자열의 길이) = 1000 x 4000 = 4_000_000만으로 충분히 유효하다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/16906