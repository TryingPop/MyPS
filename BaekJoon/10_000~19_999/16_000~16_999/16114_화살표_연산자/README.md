# C#

## 난이도 : 실버 2

## 알고리즘 분류
  - 구현
  - 많은 조건 분기

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
NOTE: 이 문제의 내용은 C++11 이후의 표준을 따릅니다.<br/>
새내기들을 위해 C++ 스터디를 준비하던 키파는 인터넷에서 신기한 연산자를 발견했다. 바로 화살표 연산자(\<\-\-)이다.<br/>

	// 프로그램
	#include <iostream>
	
	int main(){
	  int x = 10;
	
	  while( 0 <-- x ){
	    std::cout << x << std::endl;
	  }
	  return 0;
	}
	
	// 출력
	9
	8
	7
	6
	5
	4
	3
	2
	1

위와 같이 화살표 연산자를 사용하면 연산자 오른쪽에 있는 변수가 연산자 왼쪽의 값을 향해 다가간다! 심지어 이 연산자는 화살표의 길이(-의 개수)를 늘려서 값이 바뀌는 속도를 더 빠르게 할 수도 있다.<br/>


	// 프로그램
	#include <iostream>
	
	int main(){
	  int x = 10;
	
	  while( 0 <---- x ){
	    std::cout << x << std::endl;
	  }
	  return 0;
	}
	
	// 출력
	8
	6
	4
	2

화살표의 길이가 2인 첫 번째 코드에서는 수가 9개 출력되었으나, 길이를 4로 늘린 두 번째 코드에서는 수가 4개밖에 출력되지 않았다. 변수가 2배 빠르게 값으로 다가간 것이다!<br/>
사실 이 화살표 연산자는 전위 감소 연산자(prefix decrement operator, -\-x)를 이용한 농담으로, 0 \<\-\- x은 \-\-x \> 0을 화살표처럼 보이도록 눈속임한 것이다. 따라서 첫 번째 코드의 반복문은 아래와 같이 동작한다.<br/>

  1. x의 값을 1 감소시킨다.
  2. 만약 x의 값이 0보다 크지 않다면 프로그램을 종료한다.
  3. x의 값을 출력하고 처음으로 돌아간다.

감소 연산자는 아래와 같은 특징이 있다.<br/>
	
  - \-가 여러 개 연속되어 있을 때는 반드시 앞에서부터 두 개씩 끊어서 해석된다. 예를 들어 \-\-\-\-\-\-x는 \-\- \- \-\- \-x 또는 \- \-\- \- \-\-x 등이 아니라 반드시 \-\- \-\- \-\-x로 해석된다.
  - 감소 연산자는 단항 부정 연산자(unary minus operator, -x)가 적용된 식에는 적용할 수 없다. 예를 들어 \-\-\-\-\-x는 \-\- \-\- \-x로 해석되고, 감소 연산자가 \-x에 적용되었으므로 컴파일에 실패한다.

두 번째 코드의 0 \<\-\-\-\- x는 \-\- \-\-x \> 0과 같고, 감소 연산자가 두 번 적용되었으므로 x의 값이 한번에 2씩 줄어든다.<br/>
위의 코드에서 x의 초기값과 화살표의 길이를 바꿨을 때, 몇 개의 수가 출력될지 예상해 보자.<br/>


## 입력
첫 줄에 변수 x의 초기값을 뜻하는 정수 X와 화살표의 길이를 뜻하는 정수 N(-100 ≤ X ≤ 100, 0 ≤ N ≤ 10)이 주어진다.<br/>


## 출력
첫째 줄에 프로그램의 실행 결과를 출력한다.<br/>

  - 만약 프로그램이 정상적으로 종료된다면 프로그램이 출력한 수의 개수를 출력한다.
  - 만약 프로그램이 무한히 많은 수를 출력한다면 INFINITE를 출력한다.
  - 만약 프로그램이 지문에 주어진 조건에 의해 컴파일에 실패할 경우 ERROR를 출력한다.


## 예제 입력
10 4<br/>


## 예제 출력
4<br/>


## 풀이
m이 1개인 경우 음의 부호로 볼 수 있다.<br/>
반면 m이 2개 이상인 홀수라면 문제 조건에서 컴파일 실패한다고 한다.<br/>
그래서 ERROR처리를 해준다.<br/>


그리고 m이 음수 부호로 쓰이고 n이 음수인 경우 항상 참이되므로 무한히 실행된다.<br/>
혹은 n이 양수이고 m이 0인 경우도 무한히 실행된다.<br/>
해당 경우 INFINITE 처리를 한다.<br/>


이렇게 반례 처리를 먼저 했다.<br/>
이외의 경우는 프로그램이 실행되고 적당한 횟수에 끝난다.<Br/>


남은 부분은 n, m의 크기가 작아 직접 실행하는 코드를 구현한 뒤 실행시켜 찾았다.<br/>
1회당 n에서  m / 2의 몫 만큼 값이 떨어진다.<br/>
그리고 m % 2 == 1인 경우 n은 음수 처리 해줘야한다.<br/>


남은 부분은 while문을 만들고 n -= m / 2 연산을 먼저 실행한다.<br/>
n <= 0인지 조건식을 확인한다.<br/>
마지막으로 탈출안했다면 실행횟수를 1 추가 시킨다.<br/>
이후 다시 n -= m / 2를 실행시키고 반복된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/16114