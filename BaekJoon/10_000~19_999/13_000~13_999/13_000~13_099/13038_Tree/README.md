# C#

## 난이도 : 플레티넘 1

## 알고리즘 분류
  - 자료 구조
  - 트리
  - 세그먼트 트리
  - 최소 공통 조상
  - 오일러 경로 테크닉
  - heavy-light 분할

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
닉은 생일 선물로 n개의 정점이 있는 뿌리가 있는 나무를 받았습니다.<br/>
루트가 있는 트리는 연결된 무향 그래프이며, 한 정점이 루트로 선택됩니다. 각 정점에서 루트 이웃에 가장 가까운 정점을 이 정점의 부모라고 하며, 다른 이웃은 자식입니다. 루트에는 부모가 없습니다. Nick의 트리는 1에서 n까지 번호가 매겨진 정점을 가지고 있으며, 번호가 1인 정점이 트리 루트입니다.<br/>
Nick은 자신의 트리로 놀기로 했습니다. 그는 어떤 정점 u를 선택하여 제거하고, 그 자식이었던 정점을 u의 이전 부모 정점에 연결합니다. 루트는 결코 제거되지 않습니다. 하지만 정점을 그냥 제거하는 것은 흥미롭지 않으므로, 때때로 그는 현재 트리에서 한 정점에서 다른 정점까지의 경로 길이를 묻습니다. Nick의 질문에 대한 답변입니다.<br/>


## 입력
입력의 첫 번째 줄에는 정수 n(1 ≤ n ≤ 100 000)이 들어 있습니다. 이는 초기 트리의 정점 수입니다. 두 번째 줄에는 n - 1개의 정수 p i (1 ≤ p i ≤ n)가 들어 있습니다. 이는 정점 2, 3, ..., n의 부모입니다.<br/>
세 번째 줄에는 정수 q(1 ≤ q ≤ 100 000)가 들어 있습니다. 이는 쿼리의 개수입니다. 그 다음 q개 줄에는 각각 쿼리가 들어 있습니다. 각 쿼리는 쿼리 유형(1 또는 2와 같은 정수)으로 시작합니다. 쿼리 유형이 1이면 그 뒤에 a와 b(1 ≤ a, b ≤ n)가 옵니다. 이는 거리를 찾아야 하는 정점의 개수입니다. 쿼리 유형이 2이면 정수 v(1 ≤ v ≤ n)가 옵니다. 이는 제거할 정점의 개수입니다.<br/>
초기 트리가 올바르게 주어지고, 쿼리의 정점이 아직 제거되지 않고, 루트가 제거되지 않는다는 것이 보장됩니다.<br/>


## 출력
유형 2의 각 쿼리에 대해 줄마다 하나씩 해당 정점 사이의 거리를 인쇄합니다.<br/>


## 예제 입력
8<br/>
1 5 2 1 2 5 5<br/>
7<br/>
2 4<br/>
1 7 6<br/>
2 5<br/>
1 3 8<br/>
1 8 6<br/>
2 2<br/>
1 8 6<br/>


## 예제 출력
4<br/>
2<br/>
3<br/>
2<br/>


## 풀이
노드를 제거하지 않은 경우 해당 노드간 거리는 LCA로 공통 조상을 찾고 공통조상까지 가는데 건너가는 간선의 갯수를 세어 거리를 구할 수 있다.<br/>
거리를 간선으로 구하는게 아닌, 각 노드에 가중치 1을 줘서 LCA를 제외한 노드들의 가중치의 합과 같은 결과를 낸다.<br/>


A 노드를 제거하는 경우 A의 자식들은 A의 부모랑 간선이 연결된다. 이는 A에서 A의 부모로 가는 간선을 무시하는 것과 같다.<br/>
이는 A에 가중치를 0으로 바꾸는 것과 같다.<br/>


세그먼트 트리로 노드의 가중치를 관리하면 log N으로 A에서 B로 가는 가중치의 합을 구할 수 있다.<br/>
이에 HLD 알고리즘을 노드를 간선 단위로 묶은 뒤 쿼리를 진행했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/13038