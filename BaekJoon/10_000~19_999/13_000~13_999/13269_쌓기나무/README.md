# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 확률론

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 128 MB

## 문제
11 살 근우는 쌓기 나무를 좋아한다. 근우는 수학 교과서의 문제를 풀다가 재미있는 것을 찾았다. 바로 쌓기 나무가 쌓인 모양을 위, 앞, 오른쪽 옆에서 바라보고 쌓기 나무가 쌓인 모양을 유추하는 문제를 푸는 것이다.<br/>
근우는 똑똑하기 때문에 수학 교과서에 있는 쌓기 나무 문제를 모두 푸는 것은 어려운 일이 아니었다. 근우는 혹시 이러한 쌓기 나무 문제를 푸는 프로그램이 존재하는지 궁금해졌지만, 프로그램을 찾지는 못했다. 그래서 여러 분들에게 이러한 프로그램을 만들어 달라고 요청하였다. 근우를 위해 프로그램을 만들어보자!<br/>
답이 여러 개가 있을 수 있는데, 답으로 가능한 것들 중에서 쌓기 나무를 가장 많이 사용하는 것을 출력하면 된다.<br/>


## 입력
첫째 줄에 세로 길이 N 과 가로 길이 M 이 띄어쓰기로 구분되어 주어진다. (1 ≤ N, M ≤ 500)<br/>
둘째 줄부터 N+1 번째 줄까지 위에서 바라본 모양이 주어진다. 쌓기나무가 있는 위치는 1, 그렇지 않은 위치는 0 으로 표시된다.<br/>
N+2 번째 줄에 앞에서 바라본 모양(0 ≤ 높이 ≤ 100)이 한 줄로 주어진다.<br/>
N+3 번째 줄에 오른쪽 옆에서 바라본 모양(0 ≤ 높이 ≤ 100)이 한 줄로 주어진다.<br/>


## 출력
주어진 데이터를 바탕으로, 가능한 쌓기 나무 모양 중에서 가장 쌓기 나무를 많이 사용하는 경우를 출력하여라. 주어진 데이터를 만족하는 쌓기나무가 존재하지 않는 경우에는 -1 을 출력하라.<br/>


## 예제 입력
2 3<br/>
0 1 0<br/>
1 1 1<br/>
1 4 3<br/>
3 4<br/>


## 예제 출력
0 4 0<br/>
1 3 3<br/>


## 풀이
나무쌓인 윗면에 갯수가 보인다.<br/>
여기서 0인 경우는 나무가 없으므로 0으로 한다.<br/>
이외의 경우는 나무를 무수히 쌓는다. 여기서는 높이의 최댓값이 100이므로 100으로 했다.<br/>


이제 정면에 봤을 때 가장 많이 쌓인 것을 알 수 있다.<br/>
그래서 나무가 무수히 쌓여있다면 해당 갯수로 줄인다.<br/>
위 예제에서 맨 왼쪽의 1열이다. 그래서 1열에 있는 모든 나무가 있는 곳을 1로 만든다.<br/>
이렇게 모든 열을 변환한다.<br/>


이제 오른쪽에서 봤을 대이다.<br/>
이 경우 해당 행을 모두 행의 최솟값보다 작거나 같게 바꿔주는 연산을 한다.<br/>
위 예제에서 3 4가 오른쪽에서 봤을 때이다.<br/>
여기서 3은 2행에 있는 최댓값이 3개를 뜻한다.<br/>
그래서 2행에 3개보다 많은게 있다면 3개로 줄인다.<br/>


마지막으로 존재하지 않는 경우를 검증해준다.<br/>
위에서 봤을 때 1이 있는 곳에는 나무가 있고 0인 곳에 나무가 없음을 확인하면 된다.<br/>


앞면의 경우는 각 열을 조사하는데 각 열에 최댓값이 존재하는지만 확인하면 된다.<br/>
넘는 요소는 만들 때 제거했기 때문이다.<br/>


오른쪽 역시 맞는 행에 최댓값이 존재하는지만 보면 된다.<br/>
이렇게 모두 진행하면 검증 된다면 최소한으로 제거했기에 가장 큰 것이 보장된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/13269