# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 그리디 알고리즘
  - 정렬

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
선종이는 최근에 배열을 정렬하는 새로운 알고리즘을 이길흥 교수님의 강의에서 배웠습니다. 그 알고리즘은 배열의 숫자들을 반복적으로 삭제, 삽입을 수행하여 배열을 정렬합니다. 선종이는 이 정렬 알고리즘을 삭삽 정렬이라 이름 붙였습니다. 삭삽 정렬은 다음과 같은 과정을 수행합니다.<br/>

  1. 배열의 요소 하나를 선택합니다.
  2. 배열에서 해당 요소를 삭제합니다.
  3. 해당 요소를 배열의 맨 뒤에 삽입합니다.

선종이는 호기심이 많은 학생이기 때문에, 삭삽 정렬을 수행하여 배열을 정렬 할 때 가장 적게 위와 같은 삭삽 과정이 얼마나 수행되는지 알아보고 싶어졌습니다.<br/>


## 입력
입력의 첫 번째 줄에는 테스트케이스를 나타내는 P(1 ≤ P ≤ 100)가 주어집니다. 이후 이어지는 행에서 각각 테스트케이스에 해당하는 데이터 세트가 주어집니다.<br/>
각각 데이터 세트는 조건에서 주어진 대로 삭삽 정렬을 수행해야하며, 독립적으로 처리되어야 합니다. 각 데이터 세트는 최소 두 행 이상이 주어집니다.<br/>
첫 번째 행에서 데이터 세트의 번호인 K와 공백 이후 정렬 할 배열의 길이인 N(1 ≤ N ≤ 1000)이 주어집니다.<br/>
그 이후 행에서 정렬 할 배열을 구성하는 N개의 양의 정수가 주어지는데, 마지막 행을 제외한 모든 행에서 10개로 이루어진 109 보다 작은 숫자들이 주어집니다. (마지막 행은 10개 보다 적은 숫자들이 주어집니다.)<br/>
주어지는 숫자들은 동일한 숫자가 여러 번 주어질 수 있습니다.<br/>


## 출력
각각의 데이터 세트의 번호를 나타내는 K와 공백 이후 최소 삭삽 정렬 과정 수행 횟수를 한 행으로 출력합니다.<br/>


## 예제 입력
3<br/>
1 3<br/>
1 3 2<br/>
2 6<br/>
1 5 2 4 3 6<br/>
3 23<br/>
67890 56312 999999999 12345 23456 38927 45632 100345 98765 23456<br/>
87654 43278 23456 117654 321899 25432 54326 217435 26845 31782<br/>
33456 41234 56213<br/>


## 예제 출력
1 1<br/>
2 3<br/>
3 15<br/>


## 힌트
예제 입력의 첫 번째 데이터 세트인,<br/>
1 3<br/>
1 3 2<br/>
는 다음과 같은 삭삽 정렬 과정을 거칩니다.<br/>
3을 선택하여 삭제하고, 배열의 맨 뒤에 삽입하여<br/>
1 2 3<br/>
으로 1번의 삭삽 정렬 과정을 수행하여 정렬을 종료하여<br/>
1 1<br/>
을 출력합니다.<br/>


## 풀이
길이 4 이하의 모든 경우를 확인해 규칙성을 찾아 풀었다.<br/>
길이 2인 최소 경우부터 확인했다.<br/>
경우는 2가지가 존재하고 2 경우 모두 가장 작은 원소는 이동하지 않는다.<br/>
여기서 이동은 삭제, 삽입 대상이 아니라는 뜻으로 썼다.<br/>
2번째 원소는 가장 작은 원소다음에 나온 경우 이동하지 않는다.<br/>
반면 가장 작은 원소보다 앞에 오는 경우 삭삽의 대상 즉, 이동 대상이 된다.<br/>


길이 3인 경우도 마찬가지로 가장 작은 원소는 이동하지 않는다.<br/>
그리고 두 번째로 작은 원소는 가장 작은 원소보다 뒤에 올 시 이동 대상이 되지 않는다.<br/>
세 번째 원소도 두 번째 원소보다 뒤에 오는 경우 이동대상이 되지 않는다.<br/>


그래서 i번째로 작은 원소 뒤에 i + 1번째 원소가 있으면 해당 원소는 이동의 대상이 되지 않음을 확인했다.<br/>
해당 경우가 최대한 원소를 이동 시키지 않는 방법이고, 이는 최소한으로 이동 시키는 방법과 같다.<br/>


고정된 이외 원소는 이동하지 않으면 정렬된 상태가 안되므로 규칙에 따라 최소 1번은 이동해야 한다.<br/>
그리고 이동할 원소들은 적절히 분배하면 각 원소를 1회씩 이동시켜 정렬할 수 있음을 확인했다.<br/>


해당 방법이 각 j의 길이에서 최소 이동횟수로 정렬된 함수를 만드는 것이다.<br/>
그리디로 n의 길이에서 최소 이동이 보장된다.<br/>


그래서 데이터가 주어지면 기존 배열과 정렬된 배열 두 군대에 넣는다.<br/>
그리고 두 포인터 알고리즘으로 이동 시키지 않는 즉, 고정 시킬 최대 원소의 갯수를 찾는다.<br/>
이제 전체 원소에서 고정 시킨 최대 원소의 수를 빼서 제출하니 이상없이 통과한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/13884