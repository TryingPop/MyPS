# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 정수론

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
민호는 1부터 N까지의 숫자를 사용해 길이 L인 수열을 만들려고 한다. 이럴 경우 경우의 수는 N^L이 된다.<br/>
하지만 이렇게 수열을 만드는 경우는 너무 재미가 없다고 생각한 민호는 아래 두가지 규칙을 지키면서 두열을 만들려고 한다.<br/>

  1. 수열의 수는 비 내림차순이여야 한다. 즉 수열은 뒤로 갈수록 감소하지 않아야 한다.
  2. 수열의 모든 수는 서로 배수 관계여야 한다.

이렇게 만든 수열의 전체 경우의 수를 계산해 출력하자. 단 경우의 수가 많아질 수 있으니 10^9 + 7으로 나눈 나머지를 출력한다.<br/>


## 입력
첫 번째 줄에 N, L (1 ≤ N, L ≤ 2,000) 이 공백을 구분으로 주어진다.<br/>


## 출력
위에 두가지 조건을 지키면서 수열을 만드는 경우의 수를 10^9 + 7으로 나눈 나머지를 출력한다.<br/>


## 예제 입력
6 4<br/>


## 예제 출력
39<br/>


## 풀이
6 4의 39가지 경우를 찾아보면 다음과 같이 있다.<br/>


	1 1 1 1,	1 1 1 2,	1 1 1 3,	1 1 1 4,	1 1 1 5,	1 1 1 6,
	1 1 2 2,	1 1 2 4,	1 1 2 6,	1 1 3 3,	1 1 3 6,	1 1 4 4,
	1 1 5 5,	1 1 6 6,	1 2 2 2,	1 2 2 4,	1 2 2 6,	1 2 4 4,
	1 2 6 6,	1 3 3 3,	1 3 3 6,	1 3 6 6,	1 4 4 4,	1 5 5 5,
	1 6 6 6,	2 2 2 2,	2 2 2 4,	2 2 2 6,	2 2 4 4,	2 2 6 6,
	2 4 4 4,	2 6 6 6,	3 3 3 3,	3 3 3 6,	3 3 6 6,	3 6 6 6,
	4 4 4 4,	5 5 5 5,	6 6 6 6


작성하면서 보니, 점화식을 찾았다.<br/>
dp[lenth][num]에 경우의 수를 담는다 치면,<br/>
dp[lenth][num] = ∑dp[lenth-1][i], i는 num의 배수<br/>
규칙을 찾을 수 있다.<br/>
시간복잡도는 L x N x log N 이므로 시도해볼만하다 생각했다.<br/>
그래서 해당 방법으로 풀었다. 코드는 L x N 의 크기의 배열을 할당하는 대신<br/>
배열을 초기화하며 2개로 풀었다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/13003