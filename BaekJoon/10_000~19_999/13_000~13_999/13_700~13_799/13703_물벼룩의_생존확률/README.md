# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 5초
  - 메모리 제한 : 512 MB

## 문제
수면에서 k 센티미터 아래에 있는 물벼룩은 1초마다 각각 1/2의 확률로 위 또는 아래로 1 센티미터 이동한다.  물벼룩은 수면에 닿자마자 기다리고 있던 물매암이들에 의해 먹혀 없어진다.  예를 들어, 수면아래 2 센티미터에 있던 물벼룩은 3초동안 "위위위, 위위아래, 위아래위, ..., 아래아래아래"의 8가지 방법으로 움직일 수 있고, 이 방법들의 확률은 모두 1/8로 같다.  이 중, "위위위, 위위아래"의 경우 2초만에 수면에 닿자마자 먹혀 없어진다.  그리고 나머지 6가지 경우에는 수면아래에 살아있게 되어, 3초후 생존확률은 6/8이다.  수면아래 k 센티미터에 있는 물벼룩이 n초후 생존할 확률이 S/2^n일때 S를 계산하시오.<br/>


## 입력
첫째 줄에 k와 n이 주어진다. (0 ≤ k ≤ n ≤ 63)<br/>


## 출력
첫째 줄에 S를 출력한다.<br/>


## 예제 입력
2 3<br/>


## 예제 출력
6<br/>


## 요약

  - 목표: 물벼룩이 지하 k(> 0)칸에서 시작해 가 위 아래로 높이 1칸씩 이동하면서 이동 경로간에 지하 0칸에 도달하지 않는 경우의 수 찾기

  - 정의:
    - dp[i][j] = i번 이동을 했을 때 j장소에 물벼룩이 존재하는 경우의 수

  - 초기값:
    - dp[0][k] = 1, 이외는 dp[0][i] = 0

  - 점화식:
    - j = 0인 경우 물벼룩이 죽으므로 j > 0에 대해
      - dp[i + 1][j - 1] += dp[i][j]
      - dp[i + 1][j + 1] += dp[i][j]

  - 정답:
    - ∑dp[n][j], j > 0

  - 시간 복잡도: O(n^2)


## 풀이
물벼룩이 지하 k(> 0)칸에서 시작해 가 위 아래로 높이 1칸씩 이동하면서 이동 경로간에 지하 0칸에 도달하지 않는 경우를 찾아야 한다.<br/>


매 이동마다 물벼룩은 위 또는 아래로 갈 수 있으므로, 단순 브루트포스로 모든 경로를 탐색하면 경우의 수가 2^n으로 기하급수적으로 증가한다. 따라서 n이 30만 넘어도 2^30 ≒ 10억으로 시간 초과가 발생한다.<br/>
그래서 브루트포스 방법을 쓸 수 없다.<br/>


이동 횟수를 기준으로 물벼룩의 위치를 경우의 수로 표현할 수 있다.<br/>
그래서 dp의 방법으로 접근했다.<br/>


dp[i][j] = val를 다음과 같이 정의한다.<br/>

  - i : i번째 이동을 뜻한다.
  - j : 물벼룩이 있는 j위치를 뜻한다.
  - val : 물벼룩이 존재할 수 있는 경우의 수이다.<br/>


단, j가 0이 되면 죽으므로 항상 j > 0이 유지돼야 한다.<br/>
그러면 i + 1이동에서 j > 0에서 위 아래로 1칸씩 이동하므로 다음과 같은 점화식을 얻는다.<br/>


  - 위로 이동한 경우: dp[i + 1][j - 1] += dp[i][j]
  - 아래로 이동한 경우 : dp[i + 1][j + 1] += dp[i][j]


초기 위치는 지하 k에만 존재하므로 dp[0][k] = 1로 하고 나머지 값은 0으로 한다.<br/>
그리고 i = 0부터 n - 1까지 각 i에 대해 j > 0인 위치만 점화식을 적용해 dp를 채워간다.<br/>


이렇게 dp를 채워나갈 경우 우리가 찾는 정답은 ∑dp[n][j]인데, j > 0이다.<br/>


그러면 이동가능한 범위는 초기 위치 k, 이동횟수 n에 대해 k ≤ n ≤ 63이므로 최대 경우의 수는 2^63을 넘지 않아 long 범위 내에 있다.<br/>


그리고 가능한 지하 이동 범위는 최대 n + k ≤ 63 + 63 = 126이다. 여유 있게 200까지 잡아도 충분하다.<br/>
그러면 dp의 크기는 n x 200 = 12_600이고 dp 탐색은 dp 크기를 넘지 않아 유효한 방법이다.<br/>


dp 테이블 크기가 (n + 1) × (n + k)이므로 전체 시간 복잡도는 O(n(n + k)) = O(n^2)이다.<br/>


dp의 점화식을 보면 i번째 이동에서 i + 1번 이동으로만 넘어가므로, 매번 이전 상태만 참조하면 된다.<br/>
따라서 2차원 배열 대신, 1차원 배열 2개를 번갈아 사용하여 메모리 사용을 줄일 수 있다.<br/>

  - 현재 상태를 나타내는 cur[j] = dp[i][j]
  - 다음 상태를 나타내는 next[j] = dp[i + 1][j]


## 문제 링크
https://www.acmicpc.net/problem/13703