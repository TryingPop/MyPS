# C#

## 난이도 : 실버 4

## 알고리즘 분류
  - 자료 구조
  - 문자열
  - 해시를 사용한 집합과 맵
  - 집합과 맵
  - 파싱

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 32 MB

## 문제
최근에 진솔이는 로봇 공학을 하기 시작했다. 그래서 포커 카드가 완전한 세트인지 확인하는 로봇을 만들기로 결심했다.<br/>
그는 프로그램을 작성하는 일을 분담했다. 그 프로그램은 카드의 모양(스페이드(♠), 하트(♡), 다이아몬드(♢), 클럽(♣))을 인식하는 것이다. 문제를 간단하게 하기 위해서 모든 카드는 하나의 모양과 하나의 숫자를 가진다고 가정한다.<br/>
여기서 그 모양은 실제 그림 대신 문자로 대체한다. P,K,H,T에 해당한다. 그리고 숫자는 1~13에 해당하는 정수이다. 로봇은 각각의 카드를 TXY의 형태로 '카드 이름'을 정하는데 T는 모양에 해당하고 XY는 숫자에 해당한다. 만약 만약 숫자가 1자리 숫자이면 X=0에 해당한다. ex) 01.<br/>
만약에 모양이 P이고 숫자가 9이면 P09이다.<br/>
완벽한 카드 한 세트는 52개로 이루어져 있다. (4 (모양)x 13(숫자))<br/>
로봇은 모든 카드의 '카드이름'을 읽고 문자열 S로 결합한다.<br/>
이제 진솔이가 프로그래밍 하는 것을 도와주자.  문자열을 읽어 얼마나 많은 카드를 잃어버렸는지 세면 된다.<br/>
만약에 2개의 같은 카드가 존재한다면 GRESKA이라고 출력하면 된다.<br/>


## 입력
오직 1줄만 문자열 S(1 ≤ |S| ≤ 1000)가 들어온다. 이것은 현재 가지고 있는 카드 이름에 해당한다.<br/>


## 출력
만약 똑같은 카드가 존재한다면 GRESKA을 출력한다.<br/>
그렇지 않으면 4개의 정수를 공백 문자로 구분하여 출력한다. 각각 P, K, H, T에 해당한다.<br/>


## 예제 입력
P01K02H03H04<br/>


## 예제 출력
12 12 11 13<br/>


## 힌트
12 12 11 13은 잃어버린 P카드 :  12개, K : 12개, H : 11개, T : 13라는 뜻이다.<br/>


## 풀이
카드 입력은 3개의 문자로 표현되며, 이를 3글자씩 끊어 읽는다.<br/>
첫 글자는 카드의 문양(P, K, H, T)을 나타내고, 다음 두 글자는 카드 번호(01~13)를 의미한다.<br/>


중복된 카드가 등장했는지를 확인하기 위해 bool 배열 dp[i][j]를 사용한다.<br/>
여기서 i는 카드 문양에 대응되는 인덱스, j는 카드 번호를 의미하며 dp[i][j]는 해당 카드가 등장한 적 있는지를 저장한다.<br/>
카드 번호는 1~13까지 존재하므로 j는 14 크기로 잡아 j=1부터 사용했다.<br/>


입력 문자열을 3글자씩 파싱하며, dp[i][j]가 false인 경우 true로 바꾼다.<br/>
이미 true인 카드가 다시 등장하면 중복이므로 문제 조건에 따라 GRESKA를 출력하고 종료한다.<br/>


중복이 없는 경우, 각 문양별로 등장하지 않은 카드(false)의 개수를 세어서 출력한다.<br/>


총 카드 수는 52장이며, 중복된 카드가 있을 경우 중간에 종료되므로 비둘기집 원리로 최대 53장까지만 확인하면 된다.<br/>
문자열 전체 길이는 최대 53 × 3 = 159자 정도이므로, 시간 복잡도는 O(1)이라 볼 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/11507