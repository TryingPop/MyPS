# C#

## 난이도 : 플레티넘 2

## 알고리즘 분류
  - 트리
  - 최소 공통 조상

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
알고리즘에 푹 빠진 동관이가 트리에 심취한 나머지 트리에서 외심을 정의하려 한다. 트리란, 모든 정점이 연결되어 있으면서 사이클이 존재하지 않는 그래프이다. 하지만 동관이는 트리에서 외심을 정의하기 위해서는 "트리에서 두 정점 사이의 거리"도 정의해야 한다는 사실을 깨달았다!<br/>
트리에서 두 정점 사이의 거리는 한 정점에서 다른 정점으로 가기 위해 거쳐야 하는 최소한의 간선의 개수로 정의된다. 이 때 트리의 세 정점에 대해, 트리의 외심은 세 정점으로부터 거리가 같으면서, 그 거리를 최소로 하는 정점이 존재한다면 해당 정점으로 정의된다. 수학적으로 트리의 세 정점에 대해 외심이 존재한다면, 유일하다는 것을 보일 수 있다.<br/>
자명하게도, 외심을 정의하는 3개의 정점이 달라지면 같은 트리라 해도 외심이 달라진다. 동관이는 다양한 외심들을 찾아보고 싶지만 코딩에 귀찮음을 겪고 있다......동관이를 위해 여러분들이 대신 코드를 짜주도록 하자.<br/>


## 입력
첫 번째 줄에 정점의 개수 N이 주어진다. (1 ≤ N ≤ 100,000) 이 트리는 1번 정점, 2번 정점, ..., N번 정점으로 구성된다.<br/>
두 번째 줄부터 N번째 줄까지, 트리의 간선 정보를 의미하는 두 자연수 X, Y가 공백으로 구분되어 주어진다. 이는 X번 정점과 Y번 정점이 연결되어있음을 의미한다. (1 ≤ X, Y ≤ N, X ≠ Y)<br/>
주어지는 연결관계는 트리를 구성한다.<br/>
N+1 번째 줄에는 쿼리의 개수 Q가 주어진다. (1 ≤ Q ≤ 100,000)<br/>
다음 Q개의 줄에 걸쳐, 외심을 정의하기 위한 세 개의 정점 번호를 뜻하는 세 자연수 A, B, C가 공백으로 구분되어 주어진다. (1 ≤ A, B, C ≤ N)<br/>


## 출력
Q개의 줄에 걸쳐 각 쿼리마다 입력으로 주어진 세 정점에 대해 트리의 외심이 존재하면 외심의 정점 번호를, 존재하지 않으면 -1을 출력한다.<br/>


## 예제 입력
4<br/>
1 2<br/>
1 3<br/>
1 4<br/>
2<br/>
2 3 4<br/>
1 2 3<br/>


## 예제 출력
1<br/>
-1<br/>


## 풀이
트리 그래프의 가장 큰 특징으로 A노드에서 B노드로 가는 최단 경로는 유일하다.<br/>
그리고 트리의 외심은 세 정점으로부터 거리가 같고 최소인 점이다.<br/>
이 두 사실을 이용하면 세 노드의 트리의 외심은 각 노드의 중심 중에서만 나올 수 있다.<br/>


귀류법으로 A, B, C의 외심 M은 어느 두 노드의 중심이 아니라고 가정하자.<br/>
그러면 A에서 M으로 B에서 M으로의 거리는 같고, 트리의 최단 경로의 유일성으로 A에서 M과 B에서 M은 A에서 B로가는 경로를 포함하게 된다.<br/>
그리고 가정에서 M은 A, B의 중심이 A에서 A와 B의 중심으로 가는 간선의 아니므로 끝에 간선이 추가된 형태뿐이다.<br/>
B, C의 경우, C와 A의 경우도 마찬가지로 중심에 포함된 경로의 끝에 간선이 추가된 형태다.<br/>
이제 끝부분이 모두 겹치는 경우라면 이는 외심의 최소성에 모순이므로 마지막 간선은 적어도 다른 두 끝 간선이 존재한다.<br/>
그런데 이는 트리의 최단 경로의 유일성으로 부터 불가능하다.<br/>
그래서 가정에 모순이고 중심 중 하나가 됨을 알 수 있다.<br/>
그래서 A, B의 중심, B, C의 중심, C, A의 중심을 찾고 각각 나머지 점과 거리를 비교해 같아지는지 확인했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/17399