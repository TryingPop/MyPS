# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 구현
  - 브루트포스 알고리즘

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
십자가는 가운데에 '*'가 있고, 상하좌우 방향으로 모두 같은 길이의 '*'가 있는 모양이다. 십자가의 크기는 가운데를 중심으로 상하좌우 방향으로 있는 '*'의 개수이다. 십자가의 크기는 0보다 크거나 같아야 한다.<br/>
아래 그림은 크기가 0, 1, 2, 3인 십자가이고, 빈 칸은 '.'이다.<br/>


	                  ...*...
	          ..*..   ...*...
	    .*.   ..*..   ...*...
	*   ***   *****   *******
	    .*.   ..*..   ...*...
	          ..*..   ...*...
	                  ...*...


십자가의 넓이는 포함된 '*'의 개수이다. 크기가 0, 1, 2, 3인 십자가의 넓이는 1, 5, 9, 13이다.<br/>
크기가 N×M이고, '.'과 '#'로 이루어진 격자판이 주어진다. 격자판에 두 개의 십자가를 겹치지 않게 놓으려고 한다. 십자가는 '#'가 있는 칸에만 놓을 수 있다. 놓인 십자가 넓이의 곱의 최댓값을 구해보자.<br/>


## 입력
첫째 줄에 격자판의 크기 N, M (2 ≤ N, M ≤ 15)이 주어진다. 둘째 줄부터 N개의 줄에 격자판의 상태가 주어진다. 항상 두 개의 십자가를 놓을 수 있는 경우만 입력으로 주어진다.<br/>


## 출력
첫째 줄에 놓은 십자가 넓이의 곱의 최댓값을 출력한다.<br/>


## 예제 입력
5 6<br/>
\######<br/>
\#...#.<br/>
\######<br/>
\##..#.<br/>
\######<br/>


## 예제 출력
5<br/>


## 힌트
아래와 같이 넓이가 1, 5인 십자가를 놓을 수 있다.<br/>
십자가를 놓은 위치는 *이다.<br/>

	######
	#...*.
	#*#***
	##..*.
	######


## 풀이
중심이 되는 서로 다른 두 좌표를 정한다.<br/>
서로 다른 두점을 찾는데 최대 경우는 ((NM)^2) / 2이다.<br/>


그리고 각 두점에 대해 가능한 십자가를 찾는다.<br/>
이는 (min(N, M) / 2)^2이다.<br/>


최악의 경우 225^2 x 64 < 400만이다.<br/>
그래서 브루트포스 방법이 유효하다 판단했다.<br/>


이제 두 십자가를 확인하는데 십자가는 #인 곳에만 놓을 수 있다.<br/>
첫 점에 십자가를 놓은 곳에 1로 표기한다.<br/>


이후 두 번째 십자가를 길이를 늘여가며 놓을 때 이미 십자가가 있거나 맵을 벗어나면 중단한다.<br/>
그리고 가능한 십자가에 대해 두 넓이의 곱 연산을 하며 최댓값을 저장했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/17085