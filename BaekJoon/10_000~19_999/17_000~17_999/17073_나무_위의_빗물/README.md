# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 그래프 이론
  - 그래프 탐색
  - 트리

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
트리란, 사이클이 없는 연결 그래프를 의미한다. 위 그림은 1번 정점을 루트로 하는 어떤 트리를 나타낸 모습이다.<br/>
사실 이 트리는 영훈이가 뒷마당에서 기르고 있는 나무이다. 어제는 비가 왔기 때문에, 트리의 1번 정점에는 W만큼의 물이 고여 있다. 1번 정점을 제외한 모든 정점에는 아직 물이 고여 있지 않은 상태이다.<br/>
이제 매초마다 모든 정점은 아래의 작업을 순서대로 반복한다.<br/>

  - 물을 가지고 있으며, 자식 정점이 있다면 자식 정점 중 하나를 골라 물을 1 준다. 자식 정점이 여러 개라면 동일한 확률로 그 중 하나를 고른다.
  - 만약 부모 정점이 자신에게 물을 흘려보냈다면 받아서 쌓아 둔다.

이때, 위 작업은 순서대로 진행되므로 부모 정점에게 받은 물을 즉시 자식 정점에게 줄 수는 없다.<br/>
영훈이는 나무를 바라보면서 더 이상 물이 움직이지 않는 상태가 되었을 때 각 정점에 어느 정도의 물이 있게 될지 궁금해졌다. 더 이상 물이 움직이지 않을 때, i번 정점에 쌓인 물의 양의 기댓값을 Pi라 하자. 이때, Pi가 0보다 큰 정점들에 대해서 Pi들의 평균은 어느 정도가 될까?<br/>


## 입력
첫째 줄에 트리의 노드의 수 N과 1번 노드에 고인 물의 양을 의미하는 정수 W가 주어진다. (2 ≤ N ≤ 500,000, 1 ≤ W ≤ 10^9)<br/>
다음 N-1줄에 걸쳐, 트리에 존재하는 간선의 정보가 U V의 형태로 주어진다. (1 ≤ U, V ≤ N​​​​, U ≠ V)<br/>
이는 양 끝 정점이 각각 U와 V인 간선이 트리에 존재한다는 의미이다.<br/>
입력으로 주어지는 트리는 항상 올바른 연결 트리임이 보장되며, 주어지는 트리의 루트는 항상 1번 정점이다.<br/>


## 출력
문제의 정답을 출력한다. 정답과의 차이가 10^-3 이하인 값은 모두 정답으로 인정된다.<br/>


## 예제 입력
5 20<br/>
5 3<br/>
3 4<br/>
2 1<br/>
1 3<br/>


## 예제 출력
6.6666666667<br/>


## 풀이
찾아야할 것은 리프의 갯수이다.<br/>
처음에는 루트에서 BFS 탐색을 시작했다.<br/>
그리고 간선을 따라가면서 다음 노드가 존재하지 않으면 리프로 판별했다.<br/>
해당 방법은 모든 간선을 확인하고 큐이기에 메모리도 많이 먹었다. 메모리는 56mb, 시간은 572ms이 나왔다.<br/>
DFS로 접근하기에는 노드가 50만이고 50만개의 재귀호출으로 시간초과나 메모리 초과가 날거 같아 BFS로 했다.<br/>


다른 사람의 풀이를 보니, 리프의 특징으로 빠르게 찾았다.<br/>
리프의 특징을 보면, 이어진 간선이 1개 뿐이다.<br/>
그래서 각 노드에 이어진 간선의 갯수를 카운팅해서 루트를 제외한 간선이 1개인 노드들의 갯수를 세면 된다.<br/>
해당 방법으로 푸니 메모리 9mb, 시간은 100ms이 나왔다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/17073