# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 그리디 알고리즘
  - 문자열

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 256 MB

## 문제
작년에 소수나라에 다녀온 하나는, 올해는 문자열나라로 관광을 가려고 한다. 문자열나라에서는 특이하게 알파벳 대문자로 구성된 문자열을 화폐로 사용한다.<br/>
문자열나라에서 'A'는 1의 가치, 'B'는 2의 가치, ..., 'Z'는 26의 가치를 가지고 있으며, 이 알파벳들을 붙여 화폐로 쓰일 문자열을 만든다. 예를 들어, "HONGIK"의 가치는 8 + 15 + 14 + 7 + 9 + 11 = 64가 된다.<br/>
소수나라에서 특이한 화폐 때문에 큰 스트레스를 받았던 하나는, 이번에는 정확한 소비 계획을 세워 미리 문자열 화폐로 돈을 환전해가려고 한다. 하나가 가져갈 문자열은 딱 하나이며, 길이는 N이고, 가치는 X여야 한다. 그리고 물론 알파벳 대문자로만 이루어져 있어야 한다.<br/>
그런데 환전소에서는 사전 순으로 앞서는 문자열을 우선적으로 환전해준다고 한다! 여행 준비에 정신이 없는 하나를 위해, 조건을 만족하면서 사전 순으로 가장 앞서는 문자열 구해주자.<br/>


## 입력
첫 번째 줄에 문자열의 길이 N(1 ≤ N ≤ 5,000,000)과, 문자열의 가치를 나타내는 정수 X(1 ≤ X ≤ 500,000,000)가 공백으로 구분되어 주어진다.<br/>


## 출력
첫 번째 줄에 조건을 만족하는 문자열 중, 사전 순으로 가장 앞서는 것을 출력한다. 만약 그런 문자열이 하나도 존재하지 않으면, "!"(따옴표 없이)를 출력한다.<br/>


## 예제 입력
6 64<br/>


## 예제 출력
AAAIZZ<br/>


## 풀이
가장 큰 값을 최대한 할당하는게 최소값을 최대한 많이 할당할 수 있다.<br/>
그러면 A의 개수가 최대니 작은 값들을 앞에 우선 세우면 사전식으로 가장 앞서게 된다.<br/>


불가능한 경우는 Z로만 N의 길이만큼 채움에도 X가 0보다 큰 경우거나 A로 N개 채울 수 없는 경우가 불가능한 경우다.<br/>
그래서 처음에 불가능여부 판별하고 최대한 Z, A의 갯수를 연산으로 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/17828