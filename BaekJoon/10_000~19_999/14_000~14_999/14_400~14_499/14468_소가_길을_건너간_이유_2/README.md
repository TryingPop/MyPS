# C#

## 난이도 : 실버 4

## 알고리즘 분류
  - 구현
  - 문자열

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
존의 농장에는 원형 목초지가 있고, 그 둘레에 길이 둘러져 있다. 존의 소는 매일 아침 이 길을 건너가 풀을 먹고 저녁에 다시 길을 건너가 헛간으로 돌아간다.<br/>
이 소들은 자신의 습관대로 매일 똑같은 방법으로 길을 건넌다. 각각의 소는 원형 길의 정해진 한 점을 지나 들어오고, 다른 점을 지나 나간다. 어떤 두 소도 길 위의 같은 점을 지나가지 않는다. 이걸 지켜본 존은 이 점들을 분석해 보기로 했다. 소는 총 26마리고, A, B, ... Z라는 이름이 붙는다. 존은 52개의 점을 시계방향으로 보면서 각 점을 어떤 소가 지나가는지 기록했다. 이렇게 만들어 낸 52글자의 문자열에는 각 알파벳이 두 번씩 나타날 것이다.<br/>
어떤 두 소는 어떤 방법으로 걷든 그 경로가 어딘가에서 만나야 될 수도 있다. 그런 소가 총 몇 쌍인지 구해 보자.<br/>

## 입력
첫 줄에 52글자의 문자열이 주어진다. 각 글자는 알파벳 대문자이며, 각 알파벳이 정확히 두 번씩 나타난다.<br/>

## 출력
경로가 무조건 만나는 소가 몇 쌍인지 출력한다.<br/>

## 예제 입력
ABCCABDDEEFFGGHHIIJJKKLLMMNNOOPPQQRRSSTTUUVVWWXXYYZZ<br/>

## 예제 출력
1<br/>

## 힌트
A와 B의 경로는 무조건 만난다.<br/>

## 풀이
? 1 ? 2 ? 1 ? 2 ? 인 1, 2 쌍이 몇 개인지 찾는 문제다.<br/>
여기서 ?는 문자가 있어도 되고 없어도된다.<br/>

그래서 1 -> 1로 가는데, 중간에 끼인 문자들을 chk[1][?] 들에 여부를 저장했다.<br/>
위 예제로보면 A -> A로 가는데 사이에 있는 것은 B, C이다. chk['A']['B'] = true, chk['A']['C'] = true이다.<br/>
이외 chk['A']['E'] = false이다. 단 자기자신은 fale로 했다. chk['A']['A'] = false이다.<br/>
'A' 탐색이 끝나면 다음인 'B'를 탐색하고 chk['B']['A'] = true이다. 이렇게 문자열의 끝 'Z'까지 탐색했다.<br/>
이렇게 쭉 찾은 뒤 chk[i][j] = chk[j][i]인 i, j의 쌍이 정답이 된다.<br/>

## 문제 링크
https://www.acmicpc.net/problem/14468