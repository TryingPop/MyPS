# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 그래프 이론
  - 그래프 탐색
  - 너비 우선 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
은하는 술과 게임과 술 게임을 좋아한다. 그중에서도 가장 좋아하는 술 게임은 “홍삼 게임”이다. 이 게임은 N명의 사람이 테이블에 원형으로 둘러앉은 상태에서 하는 게임이고, 규칙은 다음과 같다.<br/>

  1. 은하가 서로 다른 두 사람을 지목한다.
  2. 지목당한 두 사람이 동시에 테이블에 앉은 사람들 중 한 사람씩을 골라서 지목한다.
  3. 만약 두 사람이 같은 사람을 지목했을 경우 게임이 끝난다. 그렇지 않을 경우 2번으로 돌아간다.

SNUPC가 끝난 뒤 참가자들은 근처 술집으로 뒤풀이를 하러 갔고, 은하의 주도 아래 홍삼 게임을 하게 되었다. 하지만 사람이 너무 많이 모이는 바람에 누가 누굴 지목하는지 잘 보이지 않아서 게임이 수시로 중단되었다. 이 상황을 보다 못한 은하의 친구 은서는 홍삼 게임의 규칙을 수정한 “질서 있는 홍삼 게임”을 제안하였다. 이 게임의 규칙은 다음과 같다.<br/>

  1. 은하가 서로 다른 두 사람을 순서대로 지목한다. 먼저 지목당한 사람은 지목권 A, 두 번째로 지목당한 사람은 지목권 B를 갖는다.
  2. 지목권 A를 가진 사람이 자신의 왼쪽 또는 오른쪽으로 정확히 DA만큼 떨어진 사람 한 명을 지목하여 자신의 지목권을 넘긴다.
  3. 만약 지목당한 사람이 이미 지목권 B를 가지고 있었을 경우 게임이 끝난다.
  4. 지목권 B를 가진 사람이 자신의 왼쪽 또는 오른쪽으로 정확히 DB만큼 떨어진 사람 한 명을 지목하여 자신의 지목권을 넘긴다.
  5. 만약 지목당한 사람이 이미 지목권 A를 가지고 있었을 경우 게임이 끝난다. 그렇지 않을 경우 2번으로 돌아간다.

은서의 제안 덕분에 참가자들은 질서 있게 홍삼 게임을 즐길 수 있게 되었다. 하지만 은하가 몇 시간 내내 계속 홍삼 게임을 돌리자 참가자들은 지쳐 갔고, 은하가 누구를 지목하고 지목 간격을 어떻게 설정하든 최대한 게임을 빠르게 끝내려고 하게 되었다. 불쌍한 뒤풀이 참가자들을 홍삼 지옥에서 구해 주자.<br/>
편의를 위해 참가자들에게는 1번부터 N번까지 반시계방향으로 번호가 붙어 있다고 가정한다. 즉 i번 참가자의 바로 왼쪽에는 i − 1번, 바로 오른쪽에는 i + 1번 참가자가 앉아 있다. 예외로 1번 참가자의 바로 왼쪽에는 N번 참가자가, 마찬가지로 N번 참가자의 바로 오른쪽에는 1번 참가자가 앉아 있다.<br/>


## 입력
첫 번째 줄에 “질서 있는 홍삼 게임”의 참가자의 수 N(2 ≤ N ≤ 500, 000), 은하가 먼저 지목한 사람의 번호 A와 두 번째로 지목한 사람의 번호 B(1 ≤ A, B ≤ N, A ≠ B), 각 지목권의 지목 간격을 나타내는 정수 DA, DB(1 ≤ DA, DB ≤ N − 1)이 공백을 사이에 두고 순서대로 주어진다.<br/>


## 출력
첫 번째 줄에 입력된 게임을 최대한 빠르게 끝내고자 할 때 필요한 최소 지목 횟수를 출력한다. 만약 끝낼 수 없는 게임일 경우 Evil Galazy를 출력한다.<br/>


## 예제 입력
6 5 1 1 2<br/>


## 예제 출력
3<br/>


## 힌트
예시는 다음과 같은 순서로 진행하면 3번의 지목으로 끝낼 수 있다.

  1. 지목권 A를 가진 5번 참가자는 4번 또는 6번 참가자를 지목할 수 있다. 이 중 4번 참가자를 지목하여 지목권을 넘긴다.
  2. 지목권 B를 가진 1번 참가자는 5번 또는 3번 참가자를 지목할 수 있다. 이 중 3번 참가자를 지목하여 지목권을 넘긴다.
  3. 지목권 A를 가진 4번 참가자가 3번 참가자를 지목하여 지목권을 넘기고 게임이 끝난다.


## 풀이
전체 경우의 수가 50만으로 작고 이동 간격이 일정하다.<br/>
그래서 BFS로 탐색하면 브루트포스 알고리즘이 유효하다 생각했다.<br/>


현재 좌표를 서로 이동 방향을 바꿔 2번 이동하면 재방문이 가능하다.<br/>
그래서 방문을 홀수와 짝수로 나눠서 했다.<br/>
여기서 홀수, 짝수는 자신이 이동한 횟수다.<br/>


그래서 방문배열은 visit?[i][j] = val인데, i는 홀수번 이동한 경우 1, 짝수번 이동한 경우 0을 뜻한다.<br/>
j는 방문한 좌표이고, 최소 지목권 val를 담았다.<br/>


그렇게 BFS로 진행하며 각각의 visita, visitb를 채웠다.<br/>
이후 최소 턴을 찾는다.<br/>
a가 끝나는 기준으로 만나는 최소턴과 b가 끝나는 기준으로 만나는 최소 턴을 모두 찾았다.<br/>


먼저 a가 끝나는 기준으로 만나는 최소턴을 찾는 방법이다.<br/>
a의 홀수번 이동이 끝난 경우는 b는 짝수번 이동했고, a가 짝수번 이동이 끝난 경우는 b는 홀수번 이동했다.<br/>

그래서 visita[idx][j]라 하면 우선 방문을 해야 한다.<br/>
그리고 visitb[idx ^ 1][j]를 방문했는지 확인한다.<br/>
여기서 idx ^ 1은 idx = 0인 경우 idx ^ 1 = 1이되고, idx = 1인 경우 idx ^ 1 = 0이되게 해주는 연산이라 보면 된다.<br/>


만약 visita[idx][j]의 값이 visitb[idx ^ 1][j]보다 큰 경우 b의 경우 j에 먼저 도착했다는 뜻이고, 자기 자신으로 이동하는 연산을 하면 visita[idx][j]에서 만남을 알 수 있다.<br/>
반면 visitb[idx ^ 1][j]의 값이 큰 경우를 보면 a가 자기 자신으로 이동하면서 만나야 한다.<br/>
그러면 만나는 턴은 visitb[idx ^ 1][j] < visita[idx][j] + 4k인 가장 작은 k에 대해 visita[idx][j] + 4k턴이 된다.<br/>
그리고 이는 visitb[idx ^ 1][j] + 1임을 알 수 있다.<br/>


이제 b가 끝나는 기준으로 만나는 최소턴을 찾는 방법이다.<br/>
b는 a보다 뒤에 하므로 b가 홀수번 이동했다는 말은 a도 홀수번 이동한 것과 같다.<br/>
그래서 visitb[idx][j]에 대해 비교 대상은 visita[idx][j]이다.<br/>
그리고 visitb[idx][j]와 visita[idx][j] 둘다 방문해야 한다.<br/>


visitb[idx][j] > visita[idx][j]인 경우 b의 이동에서 만나는 턴이므로 visitb[idx][j]가 된다.<br/>
반면 visita[idx][j] > visitb[idx][j]인 경우 b는 j에 도착한 뒤 j로 되돌아 오는 중에 만나는 것이다.<br/>
그래서 visita[idx][j]의 턴이 아니고 visitb[idx][j] + 4k > visita[idx][j]인 가장 작은 k에 대해 visitb[idx][j] + 4k이다.<br/>
이는 visita[idx][j] + 1임을 알 수 있다.<br/>


이렇게 최소 턴을 찾았다.<br/>


이제 방문 저장방법이다.<br/>
먼저 a가 이동한다.<br/>
4i + 1인 턴들은 a가 홀수로 이동하는 턴이다.<br/>
즉, visita[1][j]의 값은 4i + 1의 형태다.<br/>


이후 b가 이동한다.<br/>
4i + 2 인 턴들은 b가 홀수로 이동하는 턴이다.<br/>


4i + 3은 a가 짝수로 이동하는 턴이고, 4i는 b가 짝수로 이동하는 턴이다.<br/>
그리고 홀수 짝수 구분했으므로 현재와 다음을 나타내는 2개의 큐를 이용했다.<br/>


초기에는 시뮬레이션 방법으로 bool 배열로 방문 처리를 접근했으나, 구현이 어려워졌다.<br/>
visita가 끝나는 경우 visitb만 이동해야 하는데, 검증을 visitb에서만 한다.<br/>
그런데 visita에서 만나는 경우도 체크해줘야 하는데 코드가 많이 복잡해져 해당 방법을 보류했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/14705