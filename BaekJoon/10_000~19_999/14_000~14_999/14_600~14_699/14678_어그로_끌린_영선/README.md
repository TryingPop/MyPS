# C#

## 난이도 : 골드 1

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 그래프 이론
  - 그래프 탐색
  - 트리
  - 깊이 우선 탐색
  - 트리에서의 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
영우는 운동장에 크게 ‘트리’ 그림을 그려 놓으며 공부를 하고 있었다. ‘트리’ 란, 사이클이 없는 그래프를 뜻한다. 우연히 지나가던 영선이는 트리의 정점 크기가 정확히 자신의 발 사이즈와 일치 하는 것을 알게 되었고, 그걸 본 영우는 영선이에게 게임을 제안했다. 게임의 방식은 다음과 같다.<br/>
영선이가 임의의 한 정점에서 시작해서 왼 발, 오른 발을 번갈아 걷다가 더 이상 갈 수 없을 때까지 게임을 진행한다. 영선이는 왼 쪽 발을 디딘 채로 시작한다. 더 이상 진행할 수 없을 때 정점을 밟고 있는 발이 왼 발이면 영선이가 이기고, 오른 발이면 영우가 이긴다. 단, 영선이가 한 번 밟은 정점은 영선이의 발자국으로 인해 운동장에서 지워진다.<br/>
영선이는 운동장이 너무 커서 트리에 대한 정보를 하나도 모르기 때문에, 게임을 시작 할 정점을 찍어야 한다. 자신이 불리하다고 생각한 영선이가 게임을 하지 않으려고 하자, 영우는 영선이에게 “어떤 점 x에서 영선이가 이기는 경우의 수”를 알려주며 어그로를 끌어보려고 한다. 최대한 큰 값을 얘기하고 싶은 영우를 위해 트리 정보를 다 알고있는 여러분이 계산해주자. <br/>



## 입력
프로그램의 입력은 표준 입력으로 받는다. 입력의 첫 줄에는 정점의 개수 N이 주어진다. (1 ≤ N ≤ 1,000,000) 두 번째 줄부터 N-1개의 줄에 정점 a와 정점 b가 주어진다. (1 ≤ a, b ≤ N) 정점 a와 정점 b가 연결 되어 있다는 것을 의미한다.<br/>


## 출력
프로그램의 출력은 표준 출력으로 한다. 경우의 수가 최대인 위치에서의 경우의 수를 출력한다.<br/>


## 예제 입력
5<br/>
1 2<br/>
1 3<br/>
2 4<br/>
2 5<br/>


## 예제 출력
2<br/>


## 힌트
1번에서 왼 발을 디딘 채로 시작해서 영선이가 이길 수 있는 경우의 수는 2다.<br/>
(1왼 -> 2오 -> 4왼) (1왼 ->2오 -> 5왼)<br/>


2번에서 왼 발을 디딘 채로 시작해서 영선이가 이길 수 있는 경우의 수는 1이다.<br/>
(2왼 -> 1오 -> 3왼)<br/>


## 요약
  - 목표 : 각 노드를 루트로 할 때 리프 노드와 거리가 짝수인 개수가 최대인 루트노드에 대해 거리가 짝수인 리프노드 개수 찾기

  - 정의:
    - dp[i][j] = 리프노드와 j노드의 거리가 i % 2인 개수

  - 초기값
    - 리프노드 a에 대해 dp[0][a] = 1, dp[1][a] = 0, 이외 노드 b는 dp[i][b] = 0

  - 점화식
    - dp[0][p] += dp[1][c]
    - dp[1][p] += dp[0][c]

  - 정답:
    - N == 1 → 1
    - N == 2 → 0
    - 루트의 자식이 모두 리프일 경우 → 정답은 dp[1][root] - 1
    - 그 외 → 정답은 max(dp[0][root], dp[1][root])

  - 시간 복잡도: O(N) (N : 노드의 수)


## 풀이
A노드에서 영선이가 이길 수 있는 경우는 루트에서 리프까지 최단 경로로 이동할 때, 지나가는 간선의 개수가 짝수인 리프 노드의 개수와 같다.<br/>
즉, 루트와 리프 사이의 거리가 짝수인 리프의 개수다.<br/>


해당 A노드에서 각 노드들간의 거리를 찾는 경우 dp를 이용면서 찾는다.<br/>
dp[i][j] = val를 다음과 같이 정의한다.<br/>

  - i : 리프노드와 거리가 홀수? 짝수 판별
    - i = 0 : 짝수
    - i = 1 : 홀수

  - j : 현재 탐색 노드
  - val : 리프 노드의 개수


그러면 부모를 p, 자식을 c라 하자.<br/>
자식 노드 c와 리프 노드의 거리가 짝수면, 부모 노드 p와의 거리는 홀수(짝수+1)가 되고,<br/>
자식 노드 c와 리프 노드의 거리가 홀수면, 부모 노드 p와의 거리는 짝수(홀수+1)가 된다.<br/>
그래서 다음과 같은 점화식을 얻는다.<br/>

  - dp[1][p] += dp[0][c] → 자식 c 기준 짝수 거리였던 리프는 부모 p 기준 홀수 거리
  - dp[0][p] += dp[1][c] → 자식 c 기준 홀수 거리였던 리프는 부모 p 기준 짝수 거리


그리고 리프 노드 l의 경우 자신과 거리가 0으로 잡기 때문에 dp[0][l] = 1이고 DFS 탐색 상 홀수인 노드는 없으므로 dp[1][l] = 0으로 한다.<br/>
리프 노드의 판별은 간선의 개수가 1개인지 확인으로 판별할 수 있다.<br/>
그러면 A와 거리가 홀수인 리프노드의 개수는 dp[0][A]가 된다.<br/>


해당 방법으로 찾는 경우 탐색하는 노드는 많아야 N 개이므로 O(N)에 찾을 수 있다.<br/>


A를 탐색하는 방법을 알았으니 브루트포스로 접근하는 경우를 고려해봤다.<br/>
A이외에 모든 노드에 대해서 조사해야 하므로 거리를 찾는 연산을 N번 하므로 시간 복잡도는 O(N^2)이 된다.<br/>
N이 100만까지 들어올 수 있으므로 시간초과가 자명하다.<br/>


직접 크기가 작은 트리들을 그려보며 규칙성을 찾았다.<br/>
그러니 다음과 같은 특이 케이스들을 찾았다.<br/>


  - 루트에 연결된 간선이 1개인 경우


해당 경우 거리가 홀수인 간선들을 세는데, 루트도 상황에 따라 루트의 1 값을 세야 하는 경우가 있다.<br/>
만약 루트와 거리가 2인 노드 중 리프가 아닌게 존재하면 1값을 세어 정답후보에 넣는다.<br/>
반면 그런 노드가 없는 경우 1값을 세지 않고 정답후보에 넣는다.<br/>
그래서 식이 다소 복잡해질 수 있다.<br/>


이에 루트의 조건으로 간선이 2 이상인 경우 제한을 주었다.<br/>
트리에 노드가 3개 이상인 경우 모든 노드는 다른 노드로 이동하는 경로가 존재하므로 간선이 2 이상인 노드의 존재성을 귀류법으로 증명할 수 있다.<br/>
그래서 루트노드가 2이하인 경우는 따로 처리한다.<br/>
두 경우 모두 그래프 개형은 유일하고 1개인 경우 정답은 1, 2개인 경우 정답은 0임을 알 수 있다.<br/>


이제 노드의 개수가 3 이상인 경우에 한해서 본다.<br/>
그러면 루트노드 root에 한해 정답 후보 중 하나는 dp[0][root]임을 알 수 있다.<br/>


그리고 다음과 같은 엣지 케이스를 발견했다.<br/>


  - 루트노드의 자식들이 모두 리프 노드인 경우


이 경우 자식 노드 수 - 1가 정답이 되고 자식노드의 수는 dp의 정의로 dp[1][root]와 일치한다.<br/>
이외 경우는 dp[1][root]와 dp[0][root] 중 정답이 됨을 알 수 있었다.<br/>


이렇게 규칙성을 찾아 푸는 경우 DFS 탐색을 1번만 하므로 전체 시간 복잡도는 O(N)이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/14678