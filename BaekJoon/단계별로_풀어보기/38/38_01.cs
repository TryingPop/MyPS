using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

/*
날짜 : 2024. 1. 18
이름 : 배성훈
내용 : 상근이의 여행
    문제번호 : 9372번

    연결 그래프의 정의를 알고 있는지 묻는 문제 같다
        1. 모든 간선은 양방향 간선이다
        2. 그리고 모든 노드들은 연결 그래프라 한다

    모든 노드를 지날 수 있게 하는 간선 개수의 최소값을 찾는거다!
    즉, 찾을껀 연결 그래프가 되는 간선들의 최소값을 찾으면 된다

    단원을 봐서 의도는 아래 알고리즘을 쓰는 것인 줄 알았다
        크루스칼(Kruskal) 알고리즘 문제?
            최소 가중치의 간선을 이용해 모든 노드들을 연결 시키는 알고리즘이다
            그리디 알고리즘이 적용됨
            사이클이 없어야 최소값이 보장되기에 사이클이 없는 경우 해당 경우가 최소 경우의 수가 된다
            시간은 간선의 개수를 E라하면
            O(E log E)

        프림 알고리즘 문제?
            하나의 정점을 선택하고, 인접한 간선 중 최소 가중치로 이동하면서 노드들을 채우는 형식이다
            사이클이 없어야 최소 값이 보장된다
            시간은 정점의 개수를 N이라 하면
            O(N^2)

    프림 알고리즘 아이디어를 활용했다
    임의의 두 노드 A, B에 대해 모든 노드가 연결 그래프이므로 A -> B로 가는 경로가 존재한다
    만약 경로가 A -> C -> D -> E -> C -> B인 경우
    C -> D -> E -> C의 경로로 돌아가는게 아닌
    A -> C -> B로 바로 이동 가능하다
    이렇게 경로를 압축하자

    그러면 경로에 포함된 모든 서로 다른 점들의 집합을 Set(B)라 하면 Set(B)는 하나의 연결 그래프가 된다

    예를 들어 경로가 A -> B 인 경우 A, B는 연결 그래프이고 사용된 경로는 1개이다
        여기서 Set(B)는 A, B
    경로가 A -> C -> B 인 경우 A, C, B는 연결 그래프이다 그리고 이때 사용된 경로는 2(3 - 1)개이다
        여기서 Set(B)는 A, B, C
    
    그리고 이제 Set(B)이외의 점 D를 아무거나 잡자
    모든 노드들이 연결 그래프이므로 Set(B)의 임의의 점에서 D로 가는 경로는 항상 존재하고
    그 경로는 앞처럼 압축한다

    그리고 Set(B)의 점에서 D로 가는 경로 중에 Set(B)의 점 1개 만을 지나는 경로로 만들 수 있다
        예를들어 Set(B)의 점 두 개 이상  시작지점을 A1, 이 중에 가장 뒤에 있는 점을 B1이라 하자
            경로는 A1 -> ... -> B1 -> ... -> D가 된다
        이를 경로에서 A1 -> ... -> B1부분을 잘라내면 B1 -> ... -> D이고 Set(B)의 점 하나만 지나가는 경로이다!

    그러면, Set(B)의 노드들의 개수를 n개, 
    B1 -> ... -> D에 있는 서로 다른 노드(B1 포함)의 개수를 m + 1개라 하면 경로는 m개이다
    그러면 Set(B)를 연결된 노드로 하는데 n - 1개의 경로가 들었음을 알 수 있고,
    Set(B)와 B1 -> ... -> D 경로의 점들을 합집합한 집합을 Set(D)라 하자
    그러면 Set(D)의 점의 개수는 n + (m + 1) - 1 = n + m개이다 그리고 연결집합이 되는데 사용한 간선의 개수는 n - 1 + m = n + m - 1개이다

    이렇게 전체 노드가 될때까지 확장해가면, 연결 집합을 만드는 경로는 (전체 노드의 개수) - 1개가 되게 할 수 있다
    
    다시 문제로 돌아와서 연결 그래프가 되는 간선들의 최소값은 (전체 노드의 개수) - 1보다 작거나 같아야한다    ....... -1
    ...... -1은 정답은 N - 1 이하이다라는 말과 같다!

    이제 N - 1이 최소값임을 보이자

    전체 집합의 개수가 N(>= 2)개이고 N개의 노드가 연결 그래프일 때, 간선의 개수가 N - 2 이하인 경우는 존재할 수 없다
        귀류법으로 적당한 N이 존재해 전체 집합의 개수가 N이고, 노드 N개가 N - 2의 간선으로 연결 그래프가 된다고 가정하자
        N들을 모아 놓은 집합 중 가장 작은 수를 N0라 하자 (정렬정리에 의해 최소값의 존재성은 보장!)
        N0는 고정된 자연수이다!

        N0에는 간선이 적어도 하나 존재한다!
            없다면 경로가 없다는 말이므로 연결 그래프에 모순이 된다!

        그러면 간선은 1개 이상이고, 
        조건에 의해 자연스레 노드의 개수 >= 간선의 개수 + 2이므로 노드의 개수는 3개 이상이 보장된다

        아무 간선을 간선을 편의상 A - B라 하자
            A, B 이외의 점 C에 대해 모든 노드가 연결 그래프이므로 A -> C인 경로가 존재한다
            그러면 A - B에서는 A, B만 왔다갔다 하므로 A 또는 B에서 새로운 점으로 가는 A - B 이외의 다른 간선이 필요하다
            그래서 간선의 개수는 2개 이상이 된다
            해당 간선을 편의상 A - D라 하자
            다른 노드를 경유할 수도 있으므로 D라 표현했다(D = C인 경우도 존재한다)
            그리고 B -> D인 경우면 A, B를 스왑해서 보면 된다

        그러면 간선이 2개가 보장되고,
        노드의 개수 - 2 >= 간선의 개수 = 2이므로 노드의 개수는 4개 이상이 되어버리고
        A, B, D를 제외한 다른 점 E가 보장된다
            모든 노드는 연결 그래프이므로 A -> E인 경로가 존재하고, A - B, A - D 에서는 E로 갈 수 없다
            그래서 A, B, D에서 시작해서 다른 노드 F로 향하는 간선의 존재성이 보장되어 버린다
        그래서 간선은 3이고, 노드의 개수는 5 이상이다

        이러한 방법을 계속하면 노드의 개수는 계속해서 증가 가능하고, 이는 최소값 N0가 존재한다는 가정에 모순이 된다
        따라서 귀류법에 의해 전체 노드의 수가 N개일 때, 연결 그래프가되는 간선들의 최소 값은 N - 1이다 ...... - 2 

    ...... -2는 정답이 N - 1 이상이라는 말과 같다!

    ...... -1과 ....... -2에 의해 연결 그래프가 되는 간선들의 최소값은 (전체 노드의 개수) - 1개가 된다!

    조건에서 연결 그래프가 되게 입력해주므로, 따로 경로 연산을 할 필요가 없다
    그래서 바로 전체 노드의 개수 - 1개를 출력하게 했다!
*/

namespace BaekJoon._38
{
    internal class _38_01
    {

        static void Main1(string[] args)
        {

            const int MAX_TEST = 100;
            const int MAX_VERTEX = 1_000;
            const int MAX_LINE = 10_000;

            int[] ufBoard = new int[MAX_VERTEX + 1];
            List<int>[] lines = new List<int>[MAX_VERTEX + 1];

            StreamReader sr = new StreamReader(new BufferedStream(Console.OpenStandardInput()));
            StreamWriter sw = new StreamWriter(new BufferedStream(Console.OpenStandardOutput()));

            int test = int.Parse(sr.ReadLine());

            for (int t = 0; t < test; t++)
            {

                int[] info = Array.ConvertAll(sr.ReadLine().Split(' '), int.Parse);

                // 풀이에서 쓰지도 않으니 읽고 바로 버린다
                for (int i = 0; i < info[1]; i++)
                {

                    sr.ReadLine();
                }

                sw.WriteLine(info[0] - 1);
            }
            sw.Close();
            sr.Close();
        }
    }
}
