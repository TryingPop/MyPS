# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학
  - 해 구성하기

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
길이가 N인 수열 A = {a_1, a_2, a_3, ..., a_N}는 초항이 a이고 공차가 d인 유한 등차수열이다.<br/>
양의 정수 M에 대하여 합이 M인 A의 부분 수열 중 가장 긴 것을 구하시오.<br/>
부분 수열이란 주어진 수열에서 원래 순서를 유지하며 0개 이상의 원소를 제거하여 얻은 수열이다.<br/>


## 입력
첫째 줄에 네 정수 N, a, d, M이 공백으로 구분되어 주어진다. (1 ≤ N, a, d ≤ 10^6; 1 ≤ M ≤ 10^18) <br/>


## 출력
첫째 줄에 합이 M인 A의 부분 수열 중 가장 긴 것의 길이 L을 출력한다.<br/>
둘째 줄에 그러한 부분 수열의 원소 L개를 공백으로 구분하여 출력한다. 가능한 답이 여러 가지라면 그중 아무거나 출력한다.<br/>
만약 그런 부분 수열이 존재하지 않는다면 첫째 줄에 −1을 대신 출력한다.<br/>


## 예제 입력
5 2 2 10<br/>


## 예제 출력
2<br/>
4 6<br/>


## 힌트
예제 입력 1에서 주어진 수열은 A = {2, 4, 6, 8, 10}이다. 길이 조건을 제외하면 가능한 B의 후보는 {10}, {2, 8}, {4, 6}이다. 이 중 길이가 가장 긴 수열은 {2, 8}과 {4, 6}이므로 둘 중 아무거나 출력하면 된다.


## 풀이
등차수열로 만들 수 있는 수 s를 보면 다음과 같다.<br/>
s = ia + jd<br/>


여기서 i는 선택된 원소의 갯수와 같다.<br/>
그래서 s - ia = jd이므로 i개를 택해서 s가 된다면 s - ia는 d로 나눠떨어져야 한다.<br/>
i는 최대 1 ~ 100만개 선택 가능하므로 유효한 방법이다.<br/>


이제 s - ia = jd에서 j에 초점을 맞춰보자.<br/>
우리는 i개를 선택했음을 안다.<br/>
그러면 최소 i개는 a, a + d, a + 2d, ..., a + (i - 1)d이다.<br/>
그래서 가능한 경우라면 0 + 1 + 2 + ... + (i - 1) ≤ j여야 한다.<br/>


똑같이 가장 큰 것을 고르는 경우 a + (n - 1)d, a + (n - 2)d + ... + a + (n - i)d를 선택한다.<br/>
그래서 j ≤ n - 1 + n - 2 + ... + n - i를 만족해야 한다.<br/>


이 둘을 이용하면 0 + 1 + 2 + ... + (i - 1) ≤ j ≤ n - 1 + n - 2 + ... + n - i이다.<br/>
이제 해당 범위의 j의 경우 0, 1, 2, ..., n에서 i개를 선택해 만들 수 있음을 보이자.<br/>


그리디로 접근했다.<br/>
먼저 0부터 선택하려고 시도한다.<br/>


남은 것은 i - 1개이다.<br/>
남은 것 중 가능한 최소는 1 + 2 + ... + i - 1 ≤ j - 0이다.<br/>
0 + 1 + 2 + ... + i - 1 ≤ j이므로 이는 확인할 필요가 없다.<br/>


그리고 남은 것 중 가능한 최대는 n - 1 + n - 2 + ... + n - (i - 1)이다.<br/>
만약 n - 1 + n - 2 + ... + n - (i - 1) < j이면 0을 선택할 수 없다.<br/>
반면 j ≤ n - 1 + n - 2 + ... + n - (i - 1)인 경우 0을 선택해도 된다.<br/>
그래서 0을 선택한다.<br/>


다음으로 이전에 비교한 값 +1인 1을 비교한다.<br/>
먼저 1을 선택하려고 시도한다.<br/>
만약 앞에서 0을 선택했다면 남은 것은 i - 2개이다.<br/>
남은 것 중 가능한 최소는 2 + 3 + ... + i - 1 ≤ j - 0 - 1이다.<br/>
0 + 1 + 2 + ... + i - 1 ≤ j이므로 이는 확인할 필요가 없다.<br/>


남은 것 중 최대는 n - 1 + n - 2 + ... + n - (i - 2)이다.<br/>
j - 0 - 1 ≤ n - 1 + n - 2 + ... + n - (i - 2)인 경우 1을 선택해도 된다.<br/>
반면 n - 1 + n - 2 + ... + n - (i - 2) < j - 0 - 1인 경우 1을 선택하지 않는다.<br/>


앞에서 0을 선택하지 않는 경우 1을 선택 시도하는 경우를 본다.<br/>
이는 n - 1 + n - 2 + ... + n - (i - 1) < j인 경우다.<br/>


1을 선택시도하려 한다.<br/>
남은 것은 i - 1개이므로 최소는 2 + 3 + ... + i이다.<br/>
0 + 1 + 2 + ... + (i - 1) ≤ j ≤ n - 1 + n - 2 + ... + n - i이고 n - 1 + n - 2 + ... + n - (i - 1) < j이다.<br/>
그래서 2 + 3 + ... + i ≤ j - 1이 항상 성립한다.<br/>


이는 작은것부터 접근하고 j의 범위와 앞의 과정으로 해당 경우로 푸는 경우 확인할 필요가 없다.(그리디)<br/>
최대만 확인하면 된다.<br/>


최대의 경우만 본다.<br/>
남은 것은 i - 1개이므로 최대는 n - 1 + n - 2 + ... + n - (i - 1)이다.<br/>
n - 1 + n - 2 + ... + n - (i - 1) < j인 경우 1을 선택할 수 없다.<br/>
반면 j ≤ n - 1 + n - 2 + ... + n - (i - 1)인 경우 1을 선택해도 된다.<br/>


이렇게 1씩 올려가면 결국 n이전에 i개를 모두 찾을 수 있다.<br/>


그래서 먼저 가능한 길이 중 가장 큰 길이를 찾는다.<br/>
그리고 가장 긴 길이에 대해 위와 같은 방법으로 원소들을 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/33940