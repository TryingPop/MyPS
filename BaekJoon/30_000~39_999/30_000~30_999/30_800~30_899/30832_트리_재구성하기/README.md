# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 그래프 이론
  - 그래프 탐색
  - 트리
  - 해 구성하기
  - 깊이 우선 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
정점의 개수가 N인 두 트리 A, B가 주어진다. 다음의 시행을 2N번 이하로 하여 A를 B와 똑같이 만들어 보자.<br/>
 
  1. A의 서로 다른 세 정점 a, b, c를 고른다. a와 b, b와 c는 각각 간선으로 연결되어 있어야 한다.
  2. a와 b 사이의 간선을 제거하고 a와 c 사이에 간선을 추가한다.

2N번 이하의 시행으로 A와 B를 똑같이 만드는 것이 항상 가능함을 증명할 수 있다. 시행의 횟수를 최소화할 필요가 없음에 유의하라.<br/>


## 입력
첫 번째 줄에 트리의 정점 개수 N이 주어진다.(4 ≤ N ≤ 1,000)<br/> 
다음 N-1개의 줄에 트리 A의 두 정점 u_i, v_i가 공백으로 구분되어 주어진다. u_i와 v_i는 간선으로 연결되어 있다.(1 ≤ u_i,v_i ≤ N; u_i ≤ v_i)<br/>
다음 N-1개의 줄에 트리 B의 두 정점 u_i, v_i가 공백으로 구분되어 주어진다. u_i와 v_i는 간선으로 연결되어 있다.(1 ≤ u_i,v_i ≤ N; u_i ≤ v_i)<br/>


## 출력
첫 번째 줄에 시행 횟수 k를 출력한다. k는 2N 이하인 음이 아닌 정수여야 한다.<br/>
다음 k개의 줄에 각 시행에서 고른 A의 정점 a, b, c를 공백으로 구분하여 출력한다. 각 시행을 순서대로 출력해야 한다.<br/>


## 예제 입력
4<br/>
1 2<br/>
1 3<br/>
1 4<br/>
2 3<br/>
3 1<br/>
1 4<br/>


## 예제 출력
1<br/>
2 1 3<br/>


## 힌트
두 트리 A와 B가 같다는 것은 A의 a번 정점과 b번 정점을 연결하는 간선이 존재할 때, B에도 a번 정점과 b번 정점을 연결하는 간선이 존재함을 의미한다.


## 풀이
루트를 제외한 모든 노드들이 루트의 자식이라 가정하자.<br/>
그러면 해당 트리에서 임의의 트리로 위 규칙을 지키며 만드는데 많아야 노드의 갯수 - 1번에 해당 트리로 만들 수 있다.<br/>
임의의 트리에서 깊이가 가장 깊은게 k라 하자. 여기서 A노드의 깊이는 A노드와 루트와의 최단 거리다.<br/>
그러면 깊이가 k인 노드들 A에 대해 각 A의 임의의 트리의 부모 노드를 B라하면 a = A b = 1 c = B의 방법으로 연결을 하자.<br/>
그러면 1과 A의 노드는 끊어지고 A는 B와 연결된다.<br/>
해당 방법 깊이 k인 노드들을 연결하고, 이후 깊이 k - 1에 대해 해당 노드의 부모들에 똑같이 앞과 같은 방법으로 연결한다.<br/>
이렇게 깊이 2까지 진행하면 임의의 트리로 변하고 시행횟수는 1을 제외한 모든 노드들에 1번씩 연산했으므로 전체 노드 - 1번으로 임의의 트리를 만들었다.<br/>
이로 모두 1의 자식노드로 만든다면 원하는 트리로 전체 노드의 갯수 - 1회에 만들 수 있다.<br/>


이제 주어진 트리의 1이 아닌 모든 노드를 1의 자식으로 만들자.<br/>
다음과 같은 방법으로 하면 전체 노드 - 1번에 완료할 수 있다.<br/>
1의 자식 중 하나를 A라 하자. 이제 A의 자식 노드 B에 대해 a = B, b = A, c = 1라 하자.<br/>
그러면 B와 A의 간선은 끊어지고, 1과 B와 이어지게 된다.<br/>
즉, B가 1의 자식노드가 된다.<br/>
A의 모든 자식들에 해당 방법을 적용한다.<br/>
그리고 B에 대해 다시 B의 모든 자식들에 앞과 같은 방법을 적용하면 된다.<br/>
이는 DFS 탐색으로 이어주는 것과 같다.<br/>
이역시 각 노드들에 1회 연산을 해서 1의 자식으로 만든 것이므로 전체 노드 - 1회 이하로 1이 아닌 모든 노드들을 1의 자식으로 만들 수 있다.<br/>


이렇게 하는 경우 O(N)에 해결할 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/30832