# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 정렬
  - 애드 혹
  - 값 / 좌표 압축

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
숫자가 적힌 종이로 된 띠가 있다. 띠에는 N개의 서로 다른 수가 적혀 있다.<br/>
이때, 이 띠에 적힌 수 사이에 가위질을 하여 하나의 띠를 여러개의 띠로 분리할 수 있으며, 여러개의 띠가 있을 때 각 띠간의 순서를 자유롭게 바꿀 수 있다.<br/>
또한, 각 띠에 대해 띠에 적힌 수를 모두 지우고 원래 적혀있던 수의 역순으로 수를 적을 수 있다.<br/>
띠에 적힌 수가 주어질 때, 띠에 적힌 수를 왼쪽부터 오름차순으로 정렬된 상태로 표시하기 위해 필요한 최소한의 가위질 횟수를 구하는 프로그램을 작성하시오.<br/>


## 입력
첫 번째 줄에 띠에 적힌 수의 개수 N이 주어진다.<br/>
두 번째 줄에 왼쪽부터 순서대로 띠에 적힌 수 a1, a2, … aN이 주어진다.<br/>


## 출력
띠에 적힌 수들을 왼쪽부터 오름차순으로 표시하기 위해 필요한 가위질 횟수의 최솟값을 출력한다.<br/>


## 제한
  - 2 ≤ N ≤ 200,000
  - 1 ≤ ai ≤ 10^9
  - 띠에 적혀있는 수들은 모두 다른 수이다.


## 예제 입력
7<br/>
94 14 9 54 4 8 60<br/>


## 예제 출력
4<br/>


## 풀이
최소한으로 자른다는 것은 최대한으로 자를 필요가 없다면 안자르는게 좋다.<br/>
그래서 자를 필요가 없는 조건을 찾았다.<br/>


기존 인덱스를 i, 정렬했을 때 i번의 인덱스를 s_i라 하자.<br/>
모든 수는 다르므로 i ≠ j이면 s_i ≠ s_j가 성립한다.<br/>


그러면 i와 i + 1에 대해 s_(i+1) = (s_i) + 1인 경우 정렬된 상태이므로 묶는게 좋다.<br/>
또한 i와 i + 1에 대해 s_(i+1) = (s_i) - 1인 경우 역순으로 숫자를 배치할 수 있으므로 이 역시 묶는게 좋다.<br/>
이렇게 묶을 수 있는 만큼 묶고 구간의 갯수 - 1는 최소 자르는 횟수와 같다.<br/>


그래서 기존 수열을 정렬한다.<br/>
다음 인접한 항에 대해 기존 인덱스의 차이가 1인지 확인하고 1이 아닌 경우 자르는 횟수를 추가해 정답을 찾았다.<br/> 


## 문제 링크
https://www.acmicpc.net/problem/30644