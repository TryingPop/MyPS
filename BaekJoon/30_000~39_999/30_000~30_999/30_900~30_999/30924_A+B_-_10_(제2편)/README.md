# C#

## 난이도 : 실버 5

## 알고리즘 분류
  - 수학
  - 사칙연산
  - 무작위화

## 제한조건
  - 시간 제한 : 3초
  - 메모리 제한 : 1024 MB

## 문제
1 이상 10,000 이하의 정수 A, B에 대해 A+B의 값을 출력해야 한다. 단, 이 문제는 인터랙티브 (상호작용) 문제이다. 이 문제에서는 A와 B의 값이 바로 주어지지 않고, 채점기와의 상호작용을 통해 그 값을 알아내야 한다.<br/>
상호작용 문제에 대해 잘 모른다면, 제1편을 먼저 풀어보자.<br/>


## 출력
[제1편](https://github.com/TryingPop/MyPS/tree/main/BaekJoon/30_000~39_999/30_000~30_999/30_900~30_999/30917_A%2BB_-_10_(%EC%A0%9C1%ED%8E%B8))과 같은 방식으로 상호작용하면 된다. 단, 이 문제에서는 최대 19,997번 질문할 수 있다.<br/>
이 문제의 채점기는 적응하지 않는다. 자세한 설명은 아래 노트 란을 참조하자.<br/>


## 예제 입력
0<br/>
0<br/>
1<br/>
0<br/>
1<br/>


## 예제 출력
? A 123<br/>
? A 2517<br/>
? A 3150<br/>
? B 1342<br/>
? B 205<br/>
! 3355<br/>


## 노트
이 문제는 예제를 포함하여 10개의 테스트케이스를 사용한다.<br/>
상호작용 문제의 채점기는 적응하는 (adaptive) 채점기와 적응하지 않는 (non-adaptive) 채점기로 나뉜다. 둘의 구분은 다음과 같다.<br/>


  - 적응하는 채점기는 사용자의 질문에 맞춰서 문제의 값을 (모순이 일어나지 않는 선에서) 조정한다. 예를 들어, 만약 이 문제가 적응하는 채점기를 쓴다면, 채점기는 사용자가 질문하거나 A+B를 출력할 때 그에 맞춰서 A와 B의 값을 결정할 것이다. 그렇다고 해서 ? A 1과 ? A 2에 모두 "예"라고 답하는 등의 모순적인 답변은 하지 않는다.
  - 적응하지 않는 채점기는 채점을 시작할 때 문제의 값을 미리 정해 놓는다. 예를 들어, 이 문제의 채점기는 A와 B의 값을 바로 정해 놓고, 사용자가 질문할 때도 맨 처음에 정해 놓은 값에 따라 답변한다.


A와 B의 값을 정하는 시점이 사용자에게 보이지 않는데, 채점기가 적응하든 아니든 무슨 차이가 있을까? 그 차이는 다음과 같다. 만약 이 문제의 채점기가 적응한다면 이 문제는 풀 수 없는 문제였을 것이다. 다음과 같은 채점기를 사용하면 A와 B를 알아내는 데 항상 19,998번의 질문이 필요한데, 실제로는 19,997번까지만 질문할 수 있기 때문이다.<br/>


  1. 채점기가 A의 후보 집합과 B의 후보 집합을 관리한다. 처음에는 두 집합 모두 \{1,2, ...,10000\}이다.
  2. 프로그램이 질문할 때, 후보 집합에 원소가 두 개 이상 있다면 "아니요"라고 답한 뒤, 질문한 값이 집합에 있을 경우 이를 제거한다. 후보 집합에 원소가 하나만 있다면 질문에 따라 "예" 또는 "아니요"라고 답한다.
  3. 프로그램이 A+B의 값을 출력할 때, 두 후보 집합 중 하나라도 원소가 두 개 이상 있다면 오답으로 판정하고, 아니라면 정답으로 판정한다.


두 후보 집합에서 총 19,998개의 원소를 제거해야 정답을 받는데, 질문 하나당 한 원소만 지울 수 있으므로 최소 19,998번의 질문이 필요한 것이다.<br/>
하지만 이 문제의 채점기는 적응하지 않기 때문에, 위와 같은 방식을 사용하지 않고 A와 B의 값을 처음부터 정해 놓는다. 이 경우에는 랜덤을 잘 활용하면 각 테스트케이스에 대해 99.999999%의 확률로 정답을 낼 수 있다. 정답 확률이 정확히 100%가 아니니까 틀린 풀이가 아닌지 의문이 들 수 있다. 하지만 실제로 제출했을 때 틀렸습니다를 받을 일은 사실상 없다고 보아도 무방하고, 이렇게 랜덤을 사용하여 푸는 문제가 온라인 저지는 물론 대회에도 가끔 등장한다는 점을 고려하면 충분히 인정되는 풀이라고 할 수 있다.<br/>


## 풀이
A, B의 범위는 1부터 10,000까지이다.<br/>
이 값을 정확히 알기 위해서는 A와 B 각각에 대해 1부터 9,999까지 차례로 질의해보아야 한다.<br/>
마지막 값까지 모두 아니라고 판별되면, 결국 10,000이라는 결론에 도달할 수 있다.<br/>
즉, 최악의 경우 A, B 각각을 정확히 찾기 위해 9,999 + 9,999 = 19,998번의 질의가 필요하다.<br/>


하지만 문제에서 허용하는 질의 횟수는 최대 19,997번이다.<br/>
19_997 < 9_999 + 9_999 = 19_998이므로, 완전 탐색 방식은 사용할 수 없다.<br/>


문제의 노트를 보면, 채점기는 ‘적응형 채점기’가 아니며, 즉 A, B의 값이 이미 고정되어 있다고 명시되어 있다.<br/>
또한 랜덤을 이용하면 확률적으로 매우 높은 성공률을 가진다고 언급되었기에, 랜덤 방식을 고려했다.<br/>


1부터 9,999 사이의 수 중 하나를 무작위로 제외하고, 나머지 9,998개의 수에 대해 질의함으로써 A, B를 추측했다.<br/>
이 과정은 A와 B 각각에 대해 총 9,998번씩, 19,996번의 질의를 사용한다.<br/>
이는 최대 19,997번의 질의 제한에 부합한다.<br/>


랜덤을 찾는 것은 System 네임스페이스의 Random 클래스를 이용해 찾았다.<br/>
시드는 자주쓰는 7777로 고정해 랜덤값을 찾았다.<br/>


이 방식이 실패할 확률은 다음과 같다.<br/>

  - 생략된 1개의 값이 A나 B 중 하나일 확률: 2 × (1 / 9,999) × (9,998 / 9,999)
  - 생략된 값이 A, B 모두일 확률: (1 / 9,999) × (1 / 9,999)


생략된 값이 A, B 모두일 확률 중에는 정답이 되는 경우가 존재하나 매우 낮고 연산의 편의상 0으로 잡았다.<br/>
총 실패 확률은 대략 0.0005 이하로, 매우 낮다.<br/>
따라서 이 방법은 확률적으로 매우 유효하며, 실제로 이 방식을 통해 정답을 맞췄다.<br/>


해당 경우 질의 횟수 N이라 하면 N에 근접하게 질의를 하므로 시간복잡도는 O(N)이 된다.<br/>
그러나 문자열 생성이 많고 입출력 연산이 많아 실제 통과시간은 1초 가까이 소요되었다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/30924