# C#

## 난이도 : 플레티넘 4

## 알고리즘 분류
  - 수학
  - 정수론
  - 조합론
  - 확률론
  - 모듈로 곱셈 역원
  - 기댓값의 선형성

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
크기가 1, 2, ..., N인 피자가 각각 a_1, a_2, ..., a_N개씩 있다. 이 피자들을 중심이 서로 겹치도록 쌓으려고 한다.<br/>
이때 가능한 모든 순서에 대해, 위에서 내려다봤을 때 보이는 피자의 개수의 합을 구해보자. 어떤 피자가 "보인다"는 것은, 그 피자 위에 쌓인 모든 피자들보다 크다는 것이다.<br/>
크기가 같은 피자들은 구분되지 않는다. 즉 크기가 같은 피자들끼리의 순서는 고려하지 않는다.<br/>


## 입력
입력은 다음과 같이 주어진다.<br/>

	N
	a_1 a_2 ... a_N


첫째 줄에 가장 큰 피자의 크기 N이 주어진다.<br/>
다음 줄에는 크기가 i인 피자의 개수 a_i가 공백으로 구분되어 주어진다.<br/>


## 출력
가능한 모든 순서에 대해, 위에서 내려다봤을 때 보이는 피자의 개수의 합을 1,000,000,007으로 나눈 나머지를 출력한다.<br/>


## 제한
  - 1 ≤ N ≤ 300,000
  - 1 ≤ a_i ≤ 500,000
  - ∑a_i ≤ 500,000


## 예제 입력
2<br/>
1 2<br/>


## 예제 출력
4<br/>


## 힌트
1번 예제에서 가능한 모든 순서와 각각의 경우에서 보이는 피자의 수는 다음과 같다. 위에 있는 피자부터 순서대로 표기하였다.<br/>

  - (1, 2, 2): 2개
  - (2, 1, 2): 1개
  - (2, 2, 1): 1개

보이는 피자 개수의 합은 2+1+1=4개이다.<br/>


## 풀이
i크기의 피자가 보이는 경우를 확인했다.<br/>


i ≤ j일 때 j피자들을 모두 모아놓았을 때 맨 위에 크기 i의 피자가 있어야 한다.<br/>
그래서 전체 중에 맨 위에 있는 비율은 a_i / ∑a_j이 된다.<br/>
이렇게 각 a_i가 보이는 경우누적하면 우리가 찾는 값이 된다.<br/>


전체 경우를 s라 하고, f(j) = a_j + a_(j+1) + a_(j+2) + ... + a_n이라 하자.<br/>
그러면 우리가 찾는 값은 s * (a_1/f(1) + a_2/f(2) + ... + a_n/f(n))이 된다.<br/>


이를 위해서는 전체 경우 s를 찾아야 한다.<br/>
이는 조합론에서 (∑a_i)! / ((a_1)!(a_2)!...(a_n)!)이다.<br/>


p = 1_000_000_007은 소수이고, 페르마 소정리로 (a_k)!^-1 = (a_k)!^(p-2)라는 사실을 이용했다.<br/>
그러면 s = (∑a_i)! * (a_1!)^-1 * ... * (a_n!)^-1 = (∑a_i)! * (a_1!)^p-2 * (a_2!)^p-2 * ... * (a_n!)^p-2<br/>
그래서 이들을 빠른 모듈러 연산으로 곱하면서 전체 경우를 찾았다.<br/>


마찬가지로 f(j)^-1 역시 페르마 소정리로 찾고 이들을 곱하면서 정답을 구했다.<br/>
그래서 우리가 찾는 값은 s * (a_1 * (f(1)^(p-2)) + a_2 * (f(2)^(p-2)) + ... + a_n * (f(n)^(p-2)))<br/>


## 문제 링크
https://www.acmicpc.net/problem/30687