# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 애드 혹
  - 해 구성하기

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
Small 버전에서는 가능한 방법 중 아무거나 1가지만 출력한다.<br/>
'커플 파괴자 민욱이'는 솔로이기 때문에 커플끼리 함께 있는 모습을 보기 싫어한다. 그러한 민욱이가 사람들 N명이 일렬로 서 있는 대기 줄 하나를 발견했다. 민욱이는 이 대기 줄을 M개의 묶음으로 나눈 뒤, 묶음의 순서를 바꾸어 어떠한 커플끼리도 이웃하지 않게 할 것이다. 단, 같은 묶음에 있는 사람들끼리의 순서를 바꾸거나 거꾸로 뒤집을 수는 없다. 각 묶음의 사람 수는 일정하지 않고 서로 달라도 된다.<br/>
M이 크다면 묶음의 순서를 바꾸는 민욱이의 머리가 아플 것이기 때문에 M이 최소가 되게 하려고 한다. 그리고 민욱이는 M이 최소일 때의 가능한 여러 가지 방법 중 아무거나 1가지만 구하려고 한다.<br/>


## 입력
1번째 줄에 사람들의 수를 나타내는 정수 N(1 ≤ N ≤ 10^3)이 주어진다.<br/>
2번째 줄에 각 사람의 정보를 나타내는 정수 a_1, a_2, a_3, ..., a_N (0 ≤ a_i ≤ 10^3)이 공백으로 구분되어 주어진다. a_i는 대기 줄의 앞에서부터 i번째에 서 있는 사람의 정보를 나타낸다. a_i = 0이라면 그 사람이 솔로임을, a_i = a_j이고 a_i ≠ 0이라면 두 사람이 커플임을 의미한다. 0이 아닌 수가 a_1, a_2, a_3, ..., a_N에 존재한다면 그 수는 무조건 두 번 존재한다.<br/>


## 출력
각 묶음의 번호를 대기 줄의 앞에서부터 1, 2, 3, ..., M이라고 매길 때, 아래의 형식에 맞춰 가능한 방법을 출력한다.<br/>
1번째 줄에는 M의 최솟값을 출력한다.<br/>
2번째 줄에는 1번 묶음, 2번 묶음, 3번 묶음, ..., M번 묶음의 사람 수를 공백으로 구분하여 출력한다.<br/>
3번째 줄에는 묶음의 순서를 바꿨을 때 대기 줄의 앞에서부터 묶음의 번호를 출력한다.<br/>
만약 대기 줄을 몇 묶음으로 나누고 어떻게 배열하더라도 항상 한 커플 이상이 이웃한다면 1번째 줄에 -1을 출력하고 그다음 줄부터는 아무것도 출력하지 않는다.<br/>


## 예제 입력
6<br/>
3 1 1 3 2 2<br/>


## 예제 출력
3<br/>
2 3 1<br/>
1 3 2<br/>


## 풀이
수열에서 0이 아닌 숫자들 사이에 인접한 동일한 숫자쌍이 없어야 한다.<br/>
이를 위해 수열을 여러 그룹으로 나눈 뒤 각 그룹을 재배열하여 인접한 동일 숫자가 없도록 만들 수 있는 최소 그룹의 수 m을 구해야 한다.<br/>


핵심은 0이 아닌 숫자 x가 인접한 횟수 k보다 그룹 수 m이 커야, x가 인접하게 등장하지 않도록 분할 및 재배치할 수 있다는 점이다.<br/>
즉, 모든 0이 아닌 숫자 x에 대해 k < m을 만족해야 한다.<br/>


다음 세 가지 경우로 분할해서 각각의 경우를 찾자.<br/>

  1. k = 0인 경우
  2. 2 ≤ k인 경우
  3. k = 1인 경우


먼저 k = 0인 경우를 보자.<br/>
수열에서 어떤 숫자도 인접하게 등장하지 않는 경우이다.<br/>
이 경우 수열 전체를 하나의 그룹으로 처리해도 인접한 같은 숫자가 생기지 않기 때문에 그룹 수 m = 1이 최소값이자 정답이다.<br/>



다음 2 ≤ k인 경우를 보자.<br/>
이제 0이 아닌 숫자가 인접한 지점으로 나눠서 그룹을 나누자.<br/>
예를들어 0 1 2 2 1 4 3 3 4 라하자.<br/>
여기서 인접한 것은 2 2, 3 3 뿐이다.<br/>


그러면 그룹은 인접한 곳을 기준으로 왼쪽과 오른쪽으로 나눈다.<br/>
그러면 0 1 2 / 2 1 4 3 / 3 4 다음과 같이 3개로 나뉜다.<br/>
그룹 1은 0 1 2, 그룹 2는 2 1 4 3, 그룹 3은 3 4가 된다.<br/>


i번 그룹의 시작 지점을 s_i, 끝 지점을 e_i라 하자.<br/>
앞의 예제에서 2번 그룹의 s_2 = 2, e_2 = 3이 된다.<br/>


그러면 그러면 자르는 조건에 의해 e_i = s_(i+1)이 성립한다.<br/>
실제로 e_1 = 2 = s_2, e_2 = 3 = s_3이다.<br/>


여기서 0이 아닌 숫자는 오로지 2개만 존재하므로 각 1 < i에대해  s_i = e_(i-1)이므로 s_i는 모두 달라야 한다.<br/>
실제로 예제의 s_1 = 0 != 2 = s_2이다. 비슷하게 s_2 != s_3, s_3 != s_1을 알 수 있다.<br/>


이로 e_(i+1) != s_i임을 알 수 있다.<br/>
그래서 역으로 이어붙이는 경우 인접한 것이 없다.<br/>


예제로 보면 그룹 3인 3 4 를 맨 앞에, 다음으로 그룹 2인 2 1 4 3을, 마지막으로 그룹 1인 0 1 2를 이어 붙이는 것이다.<br/>
그래서 3 4 / 2 1 4 3 / 0 1 2가 된다.<br/>
여기서 인접한 것은 없다.<br/>


이렇게 이어붙이는 경우 최소 그룹의 수 m ≤ k + 1이 성립한다.<br/>
최소 그리고 k < m 이므로 m = k + 1이 된다.<br/>


이제 3번 k = 1인 경우를 보자.<br/>
먼저 원소 갯수 n = 2인 경우를 보자.<br/>
그러면 i > 0 에대해 i, i의 형태이다.<br/>
이에 어떻게 나누고 재배치해도 인접한 것을 제거할 수 없음을 알 수 있다.<br/>
그래서 -1이다.<br/>


이제 n ≥ 3에 대해 k = 1이라 하자.<br/>
먼저 a_1 != a_n이거나 a_1 = 0 또는 a_n = 0인 경우 인접한 곳을 나누고 뒤집는 경우 인접한 것이 없다.<br/>


예를들어 2 0 1 1 2 0인 경우가 해당된다.<br/>
인접한 것은 1 1 이다.<br/>
그래서 인접한 곳을 기준으로 나누면 그룹 1은 2 0 1이 되고 그룹 2는 1 2 0이 된다.<br/>


이를 그룹 2, 그룹 1 순서로 나타내면 1 2 0 / 2 0 1이므로 인접한 것이 없게 된다.<br/>


그룹의 수는 2개이고, m ≤ 2이다.<br/>
그래서 k = 1 < m이므로 m = 2가 된다.<br/>


마지막으로 k = 1, n > 2, a_1 != 0이고 a_1 = a_n인 경우를 보자.<br/>
그러면 인접한 경우로 나눈다.<br/>
이를 어떻게 배치해도 인접한 경우를 제거할 수 없다.<br/>
0이 아닌 숫자에 대해서는 존재하는 경우 오로지 2개만 존재하므로 원소의 갯수는 4개이상이 보장된다.<br/>
그래서 2 < m이 된다.<br/>


예를들면 1 0 2 2 1이 있다.<br/>
인접한 곳은 2 2다.<br/>
그래서 그룹을 분할 하면 1 0 2 / 2 1로 그룹 1은 1 0 2, 그룹 2는 2 1이 된다.<br/>
해당 경우 그룹 2 그룹 1순으로 나타내면 2 1 1 0 2로 1 1 이 인접하게 되어 버린다.<br/>
그대로 배치하면 1 0 2 2 1 로 2가 인접한다.<br/>
가능한 모든 경우에 인접한게 존재한다.<br/>


만약 2 2 가 아닌 다른 곳을 기준으로 분할한다면 2 2 는 연달아 있고 인접한 것을 제거할 수 없다.<br/>


뒤의 그룹에서 마지막 원소만 떼어내 새로운 그룹을 만든다.<br/>
예제로 보면 그룹 2의 2 1에서 1을 분할해 그룹 2는 2 그룹 3은 1로 한다.<br/>


그리고 그룹 1 그룹 3 그룹 2 형태로 그룹을 배치하면 인접한 경우가 없다.<br/>
예제로 보면 그룹 1은 1 0 2, 그룹 2 는 2, 그룹 3은 1이다.<br/>
그룹 1 그룹 3 그룹 2 순서로 나타내면 1 0 2 1 2 이고 인접한 것은 없다.<br/> 


그래서 2 < m ≤ 3이므로 m = 3이 된다.<br/>


이렇게 경우를 나눠서 정답을 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/30516