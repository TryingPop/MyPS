# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 수학

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
크기가 무한한 정사각 격자가 있다. 이 격자 위에 N개의 1 x 1 정사각형들을 각각 서로 다른 칸에 배치하려고 한다.<br/>
다음 조건들을 만족하는 도형 중 둘레가 최소인 도형을 최소 경계 직사각형이라고 하자.<br/>

  - 도형은 모든 변이 격자와 평행한 직사각형이다.
  - 도형은 배치한 정사각형들을 모두 포함한다.

N개의 정사각형을 배치하는 방법들 중 최소 경계 직사각형의 둘레가 가장 짧은 경우는 어떤 경우일까?<br/>


## 입력
첫 번째 줄에 테스트 케이스의 개수 T가 주어진다. (1 ≤ T ≤ 2 x 10^5)<br/>
두 번째 줄부터 T개의 줄에 걸쳐 각 줄에 하나씩, 배치하고자 하는 정사각형의 개수 N이 주어진다. (1 ≤ N ≤ 10^9)<br/>


## 출력
각 테스트 케이스마다 최소 경계 직사각형의 둘레가 가장 짧은 경우의 둘레를 출력한다.<br/>


## 예제 입력
3<br/>
9<br/>
14<br/>
33<br/>


## 예제 출력
12<br/>
16<br/>
24<br/>


## 노트
이 문제는 입력 데이터의 용량이 커서, 시간 초과를 받지 않으려면 빠른 입출력 방법을 사용해야 할 수 있다.<br/>

  - C++을 사용하고 있고 cin/cout을 사용하고자 한다면:
    - cin.tie(nullptr)와 ios::sync_with_stdio(false)를 main 함수 안의 맨 위에 적는다.
    - endl 대신 개행 문자(\n)를 사용한다.
    - 단, 이렇게 할 경우 scanf/printf/puts/getchar/putchar 등 C의 입출력 방식을 사용하면 안 된다.

  - Java를 사용하고 있다면:
    - Scanner와 System.out.println 대신 BufferedReader와 BufferedWriter를 사용한다.
    - BufferedWriter.flush를 마지막에 한 번 수행한다.

  - Python을 사용하고 있다면:

    - input 대신 sys.stdin.readline을 사용한다. 단, 이 함수는 맨 끝의 개행 문자까지 같이 입력받음에 유의한다.
    - 개행 문자를 제외한 문자열을 저장하고 싶을 경우 .rstrip()을 추가로 해 주는 것이 좋다.


## 풀이
N개의 정사각형을 둘러싸는 둘레가 가장 짧은 경우를 찾아야 한다.<br/>


가로 x, 세로 y인 사각형을 보자.<br/>
산술 기하 평균으로 x + y ≥ 2√(xy)가 성립한다.<br/>
산술 기하 평균에 따라 x = y일 때 x + y가 최소가 되므로, 즉, 가로와 세로의 길이 차이가 작을수록 최소 둘레를 만들 수 있다.<br/>


그래서 가로 세로 길이의 합을 z라 하면 가로의 길이 x를 z // 2로 y를 z - x로 잡는다.<br/>
그러면 두 수가 정수이면서 차이가 최소임을 알 수 있다.<br/>


가로 세로 길이의 합이 z일 때, 해당 길이로 만들 수 있는 면적은 x1 × y1 ≥ n이면 n개의 정사각형을 담을 수 있다.<br/>
z + 1의 경우, 가로와 세로 길이는 각각 x2 = (z + 1) // 2, y2 = (z + 1) - x2가 되며, 이때 x2 ≥ x1, y2 ≥ y1가 성립하므로 x2 × y2 ≥ x1 × y1 ≥ n이다.<br/>
각 길이에 따라 가능한 경우를 1, 불가능한 경우를 0이라 하면 정렬된 집합이고 이분 탐색을 적용할 수 있다.<br/>
그래서 보관할 수 있음을 이분 탐색으로 n을 둘러쌀 수 있는 가장 작은 가로 세로 길이를 찾았다.<br/>


n의 범위가 10억까지 오므로 가로 세로의 합 2√(xy) ≤ 2√10억이고 √(10억) = 31,622..이므로 2√(xy) < 63_247이다.<br/>
그래서 이분 탐색의 범위는 최소 1에서 최대 63_246으로 잡았다.<br/>


각 케이스마다 값을 찾는데 범위를 M이라 하면 이분 탐색을 logM 번 연산을 한다.<br/>
그리고 비교는 O(1)에 되므로 각 케이스 시간 복잡도는 O(log M)이다.<br/>
그리고 테스트 케이스 개수를 T라 하면 전체 시간복잡도는 O(T log M)이된다.<br/>
각 케이스별로 log(63_246) ≒ 16이므로 O(1)에 가까운 연산을 한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32629