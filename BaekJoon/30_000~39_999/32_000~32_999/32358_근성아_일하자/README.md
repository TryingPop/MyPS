# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 구현
  - 자료 구조
  - 정렬
  - 이분 탐색
  - 시뮬레이션
  - 트리를 사용한 집합과 맵
  - 두 포인터

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
근성은 나무에 관심이 많다.<br/>
평소 나무를 깨끗이 관리해 온 근성은 그 능력을 인정받아 북구청 청소행정과에 근무하게 되었다. 어느 날, 민규는 근성을 일하게 하기 위해 나무가 있는 위치에 쓰레기를 버리려고 한다. 나무는 수직선과 같은 일직선상에 있고 근성의 현재 위치는 원점이다. 아래의 두 가지 쿼리를 수행할 때 근성의 총 이동거리를 구하는 프로그램을 작성하시오.<br/>

  - 1 x : 민규가 정수 좌표 x에 있는 나무에 쓰레기를 버린다.
  - 2 : 근성은 현재 위치에서 시작하여 쓰레기가 있는 나무 중 가장 가까운 나무로 이동하여 쓰레기를 수거하고, 모든 쓰레기를 수거할 때까지 이 행동을 반복한다. 만약 현재 위치에서 가장 가까운 나무가 두 그루 이상이라면, 좌표가 가장 작은 나무로 이동한다.<br/>


## 입력
첫 번째 줄에 쿼리의 개수 N이 주어진다.<br/>
두 번째 줄부터 N개의 줄에 걸쳐 본문에 주어진 것과 같은 형식의 쿼리가 한 줄에 하나씩 주어진다.<br/>


## 출력
근성의 총 이동거리를 출력한다.<br/>


## 제한
  - 1 ≤ N ≤ 200,000
  - -10^8 ≤ x ≤ 10^8
  - 입력으로 주어지는 모든 수는 정수이다.
  - 2번 쿼리가 하나 이상 주어진다.


## 예제 입력
7<br/>
1 4<br/>
1 2<br/>
1 -2<br/>
2<br/>
1 0<br/>
2<br/>
1 5<br/>


## 예제 출력
12<br/>


## 풀이
쿼리의 갯수는 20만개이다.<br/>
그리고 쿼리당 많아야 쓰레기는 1개씩만 늘어난다.<br/>


2번 쿼리의 갯수를 m이라하고 2번 쿼리 간격간 원소의 갯수를 x_i라 하자.<br/>
N을 쿼리의 전체 갯수라 하면 그러면 ∑x_i = N - m이다.<br/>


그리고 2번 쿼리당 정렬하는 경우 ∑x_i * log(x_i)이다.<br/>
gpt에 물어보니 라그랑주 승수법을 이용해 최댓값을 찾는다.<br/>
이때 ∑x_i * log(x_i)의 최댓값은 x_i가 모두 같을 때 최댓값을 갖는다고 한다.<br/>


각 ∑x_i = N - m이므로 x_i가 모두 같은 값을 x라 하면 x = (N - m) / m 이된다.<br/>
∑x_i * log(x_i) ≤ ∑x * log(x) = m * x * log(x) = (N - m) * log((N - m) / m) ≤ (N - 1) * log(N - 1)이다.<br/>
N이 20만이므로 쓰레기를 매번 정렬해도 된다.<br/>


이제 쓰레기를 찾는 것은 두 포인터 알고리즘을 이용하면 O(N - m)에 찾을 수 있다.<br/>
근상이의 현재 위치에서 가장 가까운 쓰레기를 찾는다. 거리가 같은게 있다면 좌표 값이 낮은쪽으로 이동 하고 인덱스를 기록한다.<br/>
가장 가까웠던 인덱스에서 이제 왼쪽 인덱서 lIdx와 오른쪽 인덱스 rIdx와의 거리를 확인한다.<br/>
현재위치에서 lIdx가 가리키는 위치 거리를 lDis와 rIdx가 가리키는 위치 거리를 rDis라 하자.<br/>


lDis ≤ rDis이면 lIdx가 가리키는 위치로 이동하고 lIdx의 값을 1감소 시킨다.<br/>
반면 lDis > rDis인 경우면 rIdx가 가리키는 위치로 이동하고 rIdx의 값의 1 증가시킨다.<br/>


이렇게 이동하는데 lIdx가 없는 경우 -1을 가리키면 rIdx로만 이동한다.<br/>
반면 rIdx가 없는 경우면 lIdx로만 이동한다.<br/>
이렇게 쓰레기를 주워가면 쓰레기의 갯수만에 찾을 수 있다.<br/>


1 ≤ i ≤ 150,000인 i에 대해 ∑i 는 21억보다 크다.<br/>
그래서 이동 거리는 int 범위를 벗어날 수 있어 정답은 long 자료형으로 해야 한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32358