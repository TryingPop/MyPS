# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 브루트포스 알고리즘
  - 정렬

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
한별이는 길이 N의 이진수를 모두 모은 뒤 특별한 방식으로 정렬하여 사용하려 한다.<br/>
정렬 기준은 다음과 같다.<br/>

  - 이진수 내의 1의 개수로 오름차순 정렬한다.
  - 1의 개수가 같다면 이진수를 뒤집었을 때의 오름차순으로 정렬한다.

예를 들어, N이 3일 때 이진수는 다음 순서로 정렬된다.<br/>

  - 000
  - 100
  - 010
  - 001
  - 110
  - 101
  - 011
  - 111

어느날 친구 선린이가 찾아와 길이가 N인 이진수 하나를 주며 몇 번째 위치에 있는지 알려달라고 했다. 하지만 한별이는 다른 일이 많아 아직 이진수들을 정렬하지 못했다. 한별이를 도와주자!<br/>


## 입력
첫째 줄에 이진수의 길이 N이 주어진다.<br/>
둘째 줄에 길이 N의 이진수 S가 주어진다.<br/>
이진수는 0으로 시작할 수 있다.<br/>


## 출력
주어진 이진수와 길이가 같은 모든 이진수를 정렬하였을 때, 주어진 이진수는 몇 번째 위치에 있는지 출력한다.<br/>
위치는 0번부터 시작한다.<br/>


## 제한
  - 1 ≤ N ≤ 10


## 예제 입력
5<br/>
01101<br/>


## 예제 출력
22<br/>


## 풀이
자릿수가 증가할수록 가능한 이진수의 개수는 기하급수적으로 늘어난다.<br/>
문제에서 최대 10자리까지 가능하고 10자리의 이진수는 2^10 = 1024개 존재한다. 이는 모든 이진수를 배열에 담아 처리해도 감당할 수 있는 크기다.<br/>


이제 각 이진수에 대해 1의 갯수를 계산하고, 해당 갯수와 정수값을 기준으로 정렬한다.<br/>
이때 정렬 연산의 시간 복잡도는 전체 원소의 수의 갯수 2^n이므로 힙 정렬할 시 2^n x log 2^n = (2^n) x n이다.<br/>
그런데 비교를 시작할 때 각 자릿수별로 1의 갯수를 세어야 하므로 n의 연산을 하게 된다.<br/>
그래서 시간 복잡도는 O(n^2 x 2^n)이다.<br/>


그리고 정렬한 뒤 몇 번 인덱스와 값이 같은지 판별하면 n번 비교하는 연산이 추가로 필요하다.<br/>
n ≤ 10인 조건에서는 많아야 100 x 1024 + 1024 = 103_424 < 100만연산안으로 해결된다.<br/>
따라서 모든 이진수를 생성한 뒤 조건에 맞게 정렬하고, 인덱스와 값이 일치하는 위치를 브루트포스로 탐색해서 해결했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32283