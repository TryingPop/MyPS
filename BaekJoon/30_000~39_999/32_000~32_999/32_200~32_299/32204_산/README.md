# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 스위핑

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
온조는 산 오르는 것을 좋아하는 등반가이다. 그래서 온조는 길이가 N인 수열 A_1, ..., A_N에서 산 모양을 최대한 많이 찾으려고 한다.<br/>
만약 A의 부분수열 A_l, ..., A_r (l ≤ r)에 대해서, 어떤 정수 l ≤ k ≤ r가 존재하여 A_l ≤ A_{l+1} ≤ ... ≤ A_k ≥ ... ≥ A_{r-1} ≥ A_r을 만족한다면 이 부분수열이 산 모양이라고 하자.<br/>
온조를 도와 수열 A가 주어지면 A의 부분수열 중 산 모양인 것의 개수를 구하여라.<br/>


## 입력
첫째 줄에 수열 A의 길이 N이 주어진다.<br/>
둘째 줄에 N개의 정수 A_1, ..., A_N이 공백을 사이에 두고 주어진다.<br/>


## 출력
첫째 줄에 A의 부분수열 중 산 모양인 것의 개수를 출력하라.<br/>


## 제한
  - 1 ≤ N ≤ 500,000
  - 각 i(1 ≤ i ≤ N)에 대해, 1 ≤ A_i ≤ 1,000,000,000


## 예제 입력
5<br/>
1 2 3 2 3<br/>


## 예제 출력
12<br/>


## 힌트
부분수열 A_l, ..., A_r을 [l, r]로 표현하자. 산 모양인 부분수열은 [1, 1], [2, 2], [3, 3], [4, 4], [5, 5], [1, 2], [2, 3], [3, 4], [4, 5], [1, 3], [2, 4], [1, 4]로 모두 12개이다.<br/>


## 풀이
i번을 오른쪽 끝으로 하는 산의 갯수를 찾고 누적하면 정답이 된다.<br/>
i번을 오른쪽 끝으로 하는 산이되는 가장 긴 길이를 찾는다면 해당 길이가 산의 갯수와 일치한다.<br/>
실제로 산이 되는 경우는 크게 3가지 이다.<br/>

  - 증가 수열인 경우
  - 감소 수열인 경우
  - 증가와 감소가 섞인 경우

증가인 경우 시작 항만 제거해도 증가 수열이므로 산이 된다.<br/>
마찬가지로 감소 수열인 경우 시작항만 제거해도 감소 수열이므로 산이 된다.<br/>
마지막 증가와 감소가 섞인 경우를 보자. 시작 항을 l, 끝항을 r이라하면 A_l ≤ A_{l+1} ≤ ... ≤ A_k ≥ ... ≥ A_{r-1} ≥ A_r인 l, r이 아닌 k가 존재한다.<br/>
시작항을 제거해도 l + 1 = k인 경우 감소수열이므로 산이 된다.<br/>
k != l + 1인 경우 A_{l+1} ≤ ... ≤ A_k ≥ ... ≥ A_{r-1} ≥ A_r이 성립하므로 산이 된다.<br/>
그래서 i번을 오른쪽 끝으로 하는 산이되는 가장 긴 길이를 찾는다면 해당 길이가 산의 갯수와 일치함을 알 수 있다.<br/>


이제 가장 긴 경우를 찾으면 된다.<br/>
해당 지점을 끝으로하는 증가, 감소하는 수열의 길이를 찾는다.<br/>
만약 감소하는 경우면 감소하는 수열의 시작 지점에 증가하는 수열의 길이를 더하면 그리디로 가장 긴 산이 된다.<br/>
반면 증가하는 경우면 증가하는 길이가 가장 긴 산의 길이가 된다.<br/>


끝을 기준으로 산의 갯수를 찾기에 서로 다른 지점간 겹치는 것이 없다. 이렇게 가장 긴 산의 길이를 누적해주면 정답이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32204