# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 수학
  - 브루트포스 알고리즘
  - 조합론

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
한별이는 길이 N의 M진수를 모두 모은 뒤 특별한 방식으로 정렬하려 한다.<br/>
정렬 기준은 다음과 같다.<br/>

  - M진수 내 M-1인 자릿수의 개수로 오름차순 정렬한다.
  - M-1의 개수가 같다면 M-2인 자릿수의 개수로 오름차순 정렬한다.
  - ...
  - 2의 개수가 같다면 1인 자릿수의 개수로 오름차순 정렬한다.
  - M진수 내 모든 숫자의 개수가 같다면 M진수를 뒤집었을 때의 오름차순으로 정렬한다.

예를 들어, N이 2이고 M이 3일 때 M진수는 다음 순서로 정렬된다.<br/>

  - 00
  - 10
  - 01
  - 11
  - 20
  - 02
  - 21
  - 12
  - 22

어느날 친구 선린이가 찾아와 길이가 N인 M진수 하나를 주며 몇 번째 위치에 있는지 알려달라고 했다. 하지만 한별이는 다른 일이 많아 아직 M진수들을 정렬하지 못했다. 한별이를 도와주자!<br/>


## 입력
첫째 줄에 N과 M이 공백을 사이에 두고 주어진다.<br/>
둘째 줄에 길이 N의 M진수 S가 주어진다.<br/>
M진수는 0으로 시작할 수 있다.<br/>


## 출력
주어진 M진수와 길이가 같은 모든 M진수를 정렬하였을 때, 주어진 M진수는 몇 번째 위치에 있는지 출력한다.<br/>
위치는 0번부터 시작한다.<br/>


## 제한
  - 1 ≤ N ≤ 10
  - 2 ≤ M ≤ 10


## 예제 입력
2 3<br/>
12<br/>


## 예제 출력
7<br/>


## 풀이
예제를 보면 정답은 7이다.<br/>
문제를 보면 8번째에 있다.<br/>
시작 인덱스를 0번째부터라 생각해야 한다.<br/>


0, 1, 2, ..., m-1의 숫자에 대해 n개를 선택하는 방법은 m H n = (n + m - 1) C n이다.<br/>
n과 m이 각각 10 이하이므로 커봐야 전체 경우는 19C9를 넘지 않는다.<br/>
이는 200만을 넘지 않는 경우다.<br/>


그리고 각 선택된 경우에 대해서 i가 선택된 갯수를 cnt[i]라 하자.<br/>
그러면 해당 조합으로 나오는 수들은 n! / (∏cnt[i]!)이 된다.<br/>
여기서 ∏a_i = a_i * a_(i - 1) * ... * a_0이다.<br/>


그래서 S의 수 조합에 대해 앞에 있는 경우의 수를 찾았다.<br/>
이제 S의 수 조합을 보면 10! < 400만을 넘지 않는다.<br/>
그래서 S의 수조합으로 숫자를 만들면서 S보다 앞서는 것의 갯수를 찾아줬다.<br/>


수를 뒤집어서 오름차순 해줘야 한다.<br/>
그런데 기존 수에서 내림차순 해주니 1번 틀렸다.<br/>


이후 모든 경우를 만들고, 각 경우 뒤집어진 쌍이 유일하게 존재한다.<br/>
그래서 S를 뒤집어서 수 S'를 만들고 S'보다 작은 것의 갯수를 세어 더해줬다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32287