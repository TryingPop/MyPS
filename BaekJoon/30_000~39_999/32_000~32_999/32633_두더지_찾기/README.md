# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 정수론

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
근수 앞에 N개의 두더지 구멍이 순서대로 놓여 있다. 현재 시각 T가 A_i의 배수라면 i번째 구멍에 두더지가 나타나고 그렇지 않다면 i번째 구멍에는 두더지가 나타나지 않는다. 또한 근수는 두더지들의 상태가 배열 B를 만족하기를 바란다. B_i = 1이면 i번째 구멍에 두더지가 있어야 하고 B_i = 0이면 i번째 구멍에는 두더지가 없어야 한다. (이 문제에서의 시각은 정수 시각만 고려한다.)<br/>
근수는 시각 1부터 L까지 두더지들을 관찰하였을 때 배열 B를 만족하는 시각이 있는지 알고 싶다. 근수가 두더지들을 관찰하는 동안 배열 B를 만족하는 시각이 있는지 구하고, 있다면 이를 만족하는 가장 작은 정수 시각 T를 구해보자.<br/>


## 입력
첫 번째 줄에 정수 N과 L이 주어진다.(1 ≤ N ≤ 10^5, 1 ≤ L ≤ 10^12)<br/>
두 번째 줄에 정수 A_1, A_2, ..., A_N이 주어진다.(1 ≤ A_i ≤ 10^5)<br/>
세 번째 줄에 정수 B_1, B_2, ..., B_N이 주어진다.(B_i ∈ {0, 1})<br/>


## 출력
배열 B를 만족하는 가장 작은 정수 시각 T를 출력한다. 만약 그러한 T가 없다면 -1을 출력한다.<br/>


## 예제 입력
3 30<br/>
2 3 5<br/>
1 0 1<br/>


## 예제 출력
10<br/>


## 풀이
i번째와 j번째가 동시에 일어나는 가장 작은 시간은 LCM(A_i, A_j)이다.<br/>
또한, i와 j가 동시에 일어나는 시점은 해당 최소공배수의 배수들이 된다.<br/>
여기서 LCM은 최소 공배수이다.<br/>


이 개념을 바탕으로 다음과 같은 방식으로 접근했다.<br/>
초기 lcm 값을 1로 두고, B_i = 1인 경우에 한해 lcm = LCM(A_i, lcm)을 반복적으로 갱신해 나갔다.<br/>
이렇게 구한 lcm은 B_i = 1인 모든 이벤트가 동시에 일어나는 가장 빠른 시간이며, 이는 그리디하게 전체에서 가장 이른 공통 발생 시점을 구한 것이라 볼 수 있다.<br/>


예를 들어, 소수 집합인 {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53}의 최소공배수는 long 자료형의 범위를 가볍게 초과한다.<br/>


문제에서 A_i의 범위는 최대 10^5이고, 제한 시간 L은 최대 10^12이다.<br/>
최댓값끼리 곱하면 10^17 정도가 되어 long.MaxValue보다는 작기 때문에, 계산 시 오버플로우가 발생하지 않도록 주의만 한다면 long 타입으로 처리할 수 있다.<br/>
따라서 매 연산 시 lcm이 L을 초과하는지를 확인하여 오버플로우를 방지했고, 이는 곧 L 시간 이내에 모든 이벤트가 발생할 수 없다는 판단 기준이 되었다.<br/>


이제 불가능한 경우를 살펴보자.<br/>
B_j = 0인 j에 대해 lcm % A_j == 0이라면, j는 lcm 시간에 반드시 발생하게 되므로 B_j는 1이어야 한다.<br/>
따라서 B_j = 0인데 lcm % A_j == 0인 경우는 모순이며, 문제 조건상 불가능한 경우다.<br/>


반면, lcm % A_j ≠ 0이라면 j는 해당 시간에 발생하지 않기 때문에 B_j = 0인 것과 일치한다.<br/>


결론적으로, B_j = 0인 경우에 대해 lcm % A_j ≠ 0인지 여부로 문제 조건 충족 여부를 판단할 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32633