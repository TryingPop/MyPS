# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 그래프 이론

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
민정이는 현재 수직선의 원점 (위치 0)에 있다. 민정이는 매 시점 수직선 상에서 왼쪽 또는 오른쪽으로 1초에 1의 속도로 이동할 수 있다. 물론, 정지해 있을 수도 있다.<br/>
민정이는 다음과 같은 사건이 N번 발생할 것이라는 걸 알고 있다.<br/>
T초 뒤에 민정이가 위치 A 초과 위치 B 미만에 있으면, 카리나의 body bang을 맞게 된다. 위치 A와 위치 B는 안전하다는 점에 유의하라.<br/>
민정이는 카리나의 body bang을 맞지 않기 위해 적절히 움직이려 한다. 민정이가 움직여서 카리나의 body bang을 피할 수 있는지 판별하고, 피할 수 있다면 이동 거리를 최소화하라.<br/>


## 입력
첫째 줄에, 사건이 발생하는 횟수 N이 주어진다.<br/>
이후 N개의 줄에, 각 사건의 T, A, B가 공백을 사이에 두고 주어진다.<br/>


## 출력
민정이가 카리나의 body bang을 피할 수 없다면, -1을 출력한다.<br/>
민정이가 카리나의 body bang을 피할 수 있다면, 민정이의 최소 이동거리를 출력한다.<br/>


## 제한
  - 주어지는 모든 수는 정수이다.
  - 1 ≤ N ≤ 100
  - 1 ≤ T ≤ 1,000
  - -1,000 ≤ A < B ≤ 1,000
  - 각 사건의 T는 모두 다르다.


## 예제 입력
3<br/>
10 -3 7<br/>
20 -8 2<br/>
25 3 9<br/>


## 예제 출력
8<br/>


## 풀이
사건의 시간 T는 1,000초 이하이다.<br/>
그리고 각 좌표는 -1,000 \~ 1,000까지이므로 2,000칸의 범위를 확인한다.<br/>
이동 경로는 왼쪽이나 오른쪽으로 1칸 이동과 정지하기가 있다.<br/>


dp의 방법으로 접근할 경우 연산은 대략 3 x 2,000 x 1,000 = 6,000,000이다.<br/> 
그리고 dp[i][j] = val를 i시간에 j + 1,000위치에 이동할 때 가장 작은 이동 거리 val를 담는다.<br/>
그러면 1,000 x 2,000 x 4 = 8,000,000(바이트)로 dp 방법이 유효하다고 판단했다.<br/>
j + 1,000인 이유는 가능한 위치의 값이 -1,000 \~ 1,000이고 인덱스는 음수가될 수 없기 때문이다.<br/>



그러면 다음과 같은 점화식을 얻는다.<br/>
dp[i][j]가 이동가능한 곳이라면 즉 카리나에게 body bang을 안당하는 곳과 같다.<br/>
이전 경우에서 왼쪽 1칸 이동, 이전 경우에서 오른쪽 1칸 이동, 가만히 있어서 오는 경우가 있으므로<br/>
dp[i - 1][j - 1] + 1, dp[i - 1][j + 1] + 1, dp[i - 1][j] 중에서 이동 했던 장소에 한해 가장 작은 값이 dp[i][j]가 된다.<br/>
방문하지 못하거나 body bang을 당하는 장소면 최솟값연산에서 제외해야 한다.<br/>


그리고 시작은 0에서 시작하고 앞에서 +1,000을 보정해줬다.<br/>
그래서 dp[0][1_000] = 0으로 설정하고 나머지는 미방문으로 처리한다.<br/>


이렇게 최대 시간 1_000까지 조사를 하고 body bang 시간이 지난 후 최솟값의 경우 가만히 있음으로 최솟값을 유지하기에 dp[1_000]중 방문 가능한 가장 작은 값을 정답으로 제출했다.<br/>


해당 방법의 경우 시간 복잡도는 O((시간) x (범위))이다.<br/>


현재 dp[i][j]의 원소의 갯수가 2,000,000개이다.<br/>
만약 10,000,000개를 넘겼다면, dp[i][j]에서 시간을 나타내는 i의 의미를 바꿀 것이다.<br/>
i = 0이면 이전, i = 1이면 현재로 둘 것이다.<br/>
그러면 dp[i][j]의 원소의 갯수는 A ~ B의 범위 x 2가 된다.<br/>


또한 body bang을 당하는 경우를 따로 저장할 것이다.<br/>
그리고 시간으로 정렬한 뒤 시간이 되면 확인해 못이동하는 장소를 표기하면 된다.<br/>
그러면 시간 복잡도는 변화가 없지만 메모리는 (범위) x (시간)에서 (범위) x 2 + N으로 많이 줄어듦을 알 수 있다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32198