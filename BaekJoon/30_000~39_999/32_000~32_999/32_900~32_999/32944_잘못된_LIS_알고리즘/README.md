# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 해 구성하기

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
정현이와 서준이는 정보과학 시간에 수열의 LIS(Longest Increasing Subsequence, 가장 긴 증가하는 부분 수열)의 길이를 구하는 알고리즘을 배웠다. 그런데 정현이는 이 알고리즘을 구현하는 게 너무 귀찮았던 나머지, 자신만의 (틀린) 알고리즘을 만들어 문제를 풀기 시작했다! 하지만, 당연히 이 알고리즘으로는 문제를 풀 수 없었고, 숙제로 나온 Baekjoon Online Judge 문제들에서 번번이 틀렸습니다를 받았다.<br/>
길이가 N이고 i번째 원소의 값이 A_i인 수열 A가 주어졌을 때, 정현이의 알고리즘은 수열 B를 다음과 같은 과정을 거쳐 생성한 후 반환한다:<br/>

	B=비어 있는 수열
	for i = 1부터 n까지:
		B가 비어 있거나, B의 마지막 원소가 A_i보다 작은 경우:
			B의 맨 뒤에 A_i를 추가


정현이의 알고리즘을 실제로 구현한 예시 코드는 노트를 참고하자.<br/>
정현이의 알고리즘이 반환하는 수열 B는 수열 A의 증가하는 부분 수열이지만, 가장 긴 증가하는 부분 수열은 아닐 수도 있기 때문에 잘못된 알고리즘이다. 서준이는 정현이의 알고리즘이 잘못되었다는 것을 눈치채고 그 사실을 알려 주려고 했으나, 정현이는 반례를 내놓으라면서 그 사실을 납득하지 않으려 하고 있다.<br/>
그래서 서준이는 정현이의 알고리즘이 잘못되었음을 보여 줄 수 있는 반례를 찾고자 한다. 구체적으로는, 1부터 N까지의 양의 정수들이 정확히 한 번씩 포함된 길이 N인 수열 중에서 가장 긴 증가하는 부분 수열의 길이가 M인데, 정현이의 알고리즘이 반환하는 증가하는 부분 수열의 길이는 K가 되는 수열을 하나 찾고자 한다. 서준이를 도와 이런 수열을 하나 찾아보자.<br/>


## 입력
정수 N, M, K가 공백으로 구분되어 주어진다. (2 ≤ N ≤ 300,000; 1 ≤ K < M ≤ N)<br/>


## 출력
문제의 조건을 만족하는 수열이 존재한다면, 그러한 수열 중 하나를 골라 수열을 이루는 N개의 원소를 순서대로 공백으로 구분하여 출력한다. 만약 존재하지 않는다면 그 대신 -1을 출력한다.<br/>


## 예제 입력
5 4 3<br/>


## 예제 출력
1 2 5 3 4<br/>


## 힌트
수열 [1, 2, 5, 3, 4]의 가장 긴 증가하는 부분 수열은 [1, 2, 3, 4]이며, 이 부분 수열의 길이는 4이다. 또한 [1, 2, 5, 3, 4]에 정현이의 알고리즘을 적용하게 된다면, i = 1, 2, 3, 4, 5에 대하여 for 문이 실행된 시점에서 B는 [1], [1,2], [1,2,5], [1,2,5], [1,2,5]가 된다. 따라서 정현이의 알고리즘이 반환하는 부분 수열의 길이는 3이다.<br/>


## 노트
  - 수열 A_i의 가장 긴 증가하는 부분 수열은 모든 A_i의 부분 수열 중 가장 긴 증가하는 수열을 의미한다.
  - 부분 수열이란 주어진 수열에서 1개 이상의 원소를 골라 원래 순서대로 나열하여 얻은 수열을 말한다.
  - 증가하는 수열이란 맨 처음 원소를 제외한 모든 원소가 바로 전 원소보다 큰 수열을 말한다. 다시 말해 길이가 N인 수열 C가 있을 때, C_{i-1} < C_i (2 ≤ i ≤ N) 를 만족하면 C는 증가하는 수열이다. 정의에 의해 길이가 1인 수열은 모두 증가하는 수열이다.
  - 다음은 정현이의 알고리즘을 C++, Python, Java로 구현한 예시 코드이다.

C++

	vector<int> b;
	for(int x : a){
	    if(b.empty() || b.back() < x){
	        b.push_back(x);
	    }
	}

Python 3

	b = []
	for x in a:
	    if not b or b[-1] < x:
	        b.append(x)

Java

	ArrayList<Integer> b = new ArrayList<Integer>();
	for(int x : a){
	    if(b.isEmpty() || b.get(b.size() - 1) < x){
	        b.add(x);
	    }
	}


## 풀이
먼저 정현이가 구현한 LIS 알고리즘의 문제점을 찾아야 한다.<br/>
가장 큰 것보다 큰 것만 뒤에 추가하는 수열을 만들었다.<br/>
정현이의 경우 만약 가장 큰수가 들어오면 더 이상 갱신되지 않는다.<br/>
이는 작은 값으로 갱신하는 LIS 알고리즘과 차이가 있다.<br/>

그래서 정현이의 LIS는 1부터 하나씩 오름차순으로 배치하다가 k번째에 가장 큰 수 n을 배치하면 길이가 k인 정현이의 LIS가 된다.<br/>
이제 잘 알려진 LIS의 길이를 m으로 만들어야 하는데, 이는 m - k + 1개의 수를 쓰는데 n - 1을 끝으로 하고 1씩 차이나는 수들을 오름차순으로 나열하면 된다.<br/>
그리고 나머지 수들을 내림차순으로 배열하면 정답이 된다.<br/>

해당 경우가 가장 긴 LIS를 만들 수 있음을 그리디로 알 수 있다.<br/>
이에 해당 조건으로 못만드는 경우를 -1로 출력하면 되는데, 이는 n < m + 1과 동치이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/32944