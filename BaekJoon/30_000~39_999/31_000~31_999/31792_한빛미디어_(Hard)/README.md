# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 자료 구조
  - 그리디 알고리즘
  - 이분 탐색
  - 트리를 사용한 집합과 맵

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
이 문제는 "한빛미디어(Easy)" 문제와 입력 조건과 출력 조건이 다르다.<br/>
한빛미디어(주)는 '책으로 여는 IT 세상'을 만들어 갑니다. IT 세상의 주역은 '우리' 입니다. 한빛미디어(주)는 IT 세상의 주역들을 위한 프로그래밍, 컴퓨터공학, IT 에세이, Make, 리얼타임(전자책), OA, 그래픽, 나와 내 아이를 위한 실용 등 다양한 분야의 책으로 IT 세상을 만들어 가고 있습니다.<br/>
대학원을 졸업한 산지니는 2022년부터 부산대학교 프로그래밍 대회의 후원사를 맡아온 한빛미디어의 의뢰를 받았다. 바로 한빛미디어가 출판한 책들의 데이터베이스를 이용한 웹사이트의 책 진열 프로그램을 개발해달라는 의뢰였다. 산지니는 기쁜 마음으로 의뢰를 승낙했고, 프로그램을 개발하기 시작했다. 데이터베이스의 책들은 아래 규칙에 따라 웹사이트의 페이지에 진열된다.<br/>

  - 웹사이트의 한 페이지에 책을 한 종류 이상 진열해야 한다.
  - 가격이 두 배 이상 차이 나는 책을 한 페이지에 함께 진열할 수 없다. 예를 들어 가격이 3,000원인 책은 5,000원인 책과 함께 진열할 수 있지만 6,000원인 책과는 함께 진열할 수 없다.

산지니는 책이 진열된 페이지가 많으면 고객이 책을 찾기 힘들 것으로 생각해 책이 진열될 페이지 수를 최소화하기로 했다. 그런데 한빛미디어는 다양한 책을 취급하기 때문에 신간이 추가되기도 하고 절판되어 더 이상 판매하지 않기도 한다. 산지니는 이 프로그램을 어떻게 구현해야 할지 고민 중이다. 산지니를 도와 얼마나 많은 페이지가 필요할지 구해주자.<br/>
산지니는 아래 질의를 Q개 처리하는 프로그램을 작성해야 한다. 질의를 처리하기 전 데이터베이스는 비어있다.<br/>


  - 1 S: 가격이 S인 책을 하나 추가한다.
  - 2 S: 가격이 S인 책을 하나 제거한다. 만약 가격이 S인 책이 없다면 실행되지 않는다.
  - 3: 모든 책을 진열하기 위해 필요한 페이지 수의 최솟값을 출력한다. 진열할 책이 없다면 0개의 페이지로 모든 책을 진열할 수 있다.


## 입력
첫 번째 줄에 질의의 개수를 나타내는 정수 Q가 주어진다. (2 ≤ Q ≤ 2 x 10^5)<br/>
두 번째 줄부터 Q + 1번째 줄까지 한 줄에 하나씩 질의가 주어진다. 질의로 들어오는 책의 가격 S의 범위는 10^3 이상 10^6 이하이다.<br/>
3번 질의는 한 번 이상 주어진다.<br/>


## 출력
3번 질의가 들어올 때마다 필요한 페이지 수의 최솟값을 한 줄에 하나씩 출력한다.<br/>


## 예제 입력
7<br/>
1 2000<br/>
3<br/>
2 2000<br/>
3<br/>
1 4000<br/>
1 2000<br/>
3<br/>


## 예제 출력
1<br/>
0<br/>
2<br/>


## 힌트
입출력의 양이 많으므로 빠른 입출력을 사용하는 것을 권장합니다. 대표적인 언어에 따른 빠른 입출력은 아래를 참고하세요.<br/>

  - C++: cin, cout을 사용하는 경우 입출력 전에 cin.tie(nullptr); ios::sync_with_stdio(false);를 한 번 적용해야 합니다. 줄 바꿈할 때는 endl 대신 '\n'을 사용해야 합니다.
  - Java: BufferedReader와 BufferedWriter를 사용해야 합니다.
  - Python3, PyPy3: input() 대신 sys.stdin.readline().rstrip()을 사용해야 합니다.<br/>


## 풀이
남아있는 가장 작은 값으로 페이지를 만든다.<br/>
그리고 해당 그룹에 들어갈 수 있다면 페이지에 책을 넣는다.<br/>
이렇게 남은 책이 없을 때까지 페이지를 만들면 그리디로 최소 페이지가 보장된다.<br/>


이에 먼저 가장 낮은 가격의 책을 찾는다.<br/>
그리고 가장 낮은 가격의 책의 2배 가격보다 크거나 같은 가장 낮은 가격의 책을 찾는다.<br/>
이렇게 가장 큰 책의 가격을 포함할 때까지 진행한다.<br/>
해당 경우 책의 가격이 2배씩 증가하므로 최소 1000이고 최대 100만이므로 많아야 11번 연산을 한다.<br/>


이제 각 경우를 찾는데 정렬된 집합이면 이분 탐색으로 log(해당 배열의 범위)에 찾을 수 있다.<br/>
정렬된 집합으로 저장해주는 자료 구조로 SortedList나 SortedDictionary가 있지만 여기에 이분 탐색을 적용하는 방법을 몰라 해당 자료구조를 사용하지 못했다.<br/>


값의 범위가 1000에서 100만이므로 세그먼트 트리로 해결했다.<br/>
세그먼트 트리는 갯수를 저장했다.<br/>


그리고 i보다 크면서 가장 작은 값을 찾는 것은 다음과 같이 찾았다.<br/>
찾는 범위가 폐구간 [s, e]라면 e < i이면 우리가 찾는 범위가 아니므로 확인할 필요가 없다.<br/>
이외의 범위 즉 i ≤ e에 한해서 경우 우리는 갯수를 기록했으므로 갯수가 없다면 만족하는 i가 존재하지 않는 것과 같으므로 INF를 반환한다.<br/>


i ≤ e에서 노드가 적어도 1개 있는 경우만 본다.<br/>
먼저 s, e의 중앙 mid를 찾고 구간을 반으로 나눈다.<br/>
이후 [s, mid]범위를 탐색한다. 여기서 INF가 아닌 값이 나온다면 해당 값이 정답이 된다.<br/>
그래서 [mid + 1, e]의 범위를 탐색하지 않고 해당 값을 반환한다.<br/>


반면 [s, mid]의 반환 값이 INF라면 [mid + 1, e]를 조사한다.<br/>
이렇게 조사하는데 count가 있고 리프까지 내려온 s = e에 오는 경우 해당 값 s를 반환하면 된다.<br/>


이렇게 탐색하면 그리디로 i를 넘는 가장 작은 값임을 알 수 있다.<br/>
그래서 이렇게 INF가 나오는지 확인하며 최소 페이지의 갯수를 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/31792