# C#

## 난이도 : 골드 1

## 알고리즘 분류
  - 그리디 알고리즘
  - 정렬
  - 두 포인터

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
용범이는 보라매컵에 문제를 출제하기 위해 서로 다른 N가지 종류의 알고리즘 문제들을 각각 K개씩, 총 N x K개의 문제를 만들었다. 그중 i번째 알고리즘의 j번째 문제의 난이도는 d_ij이다. 그러나 만든 문제를 모두 내기에는 대회 시간이 부족했기에, 서로 다른 N개의 알고리즘마다 각각 하나의 문제씩 총 N개의 문제만 내고자 한다.<br/>
또한 용범이는 문제의 난이도가 급격하게 상승하는 것을 방지하기 위해, 난이도 커브를 최소화하고자 한다. 난이도 커브는 대회의 i번 문제의 난이도를 x_i라 할 때 | x_1 - x_2 | + | x_2 - x_3 | + ... + | x_(N-1) - x_N |라고 정의한다. 단, N = 1일 때의 난이도 커브는 0으로 정의한다.<br/>
용범이를 도와 N개의 문제들의 순서를 적절히 배치할 때 난이도 커브의 최솟값을 구해주자.<br/>

## 입력
첫 번째 줄에 알고리즘의 개수 N과 알고리즘마다 만든 문제 개수 K가 공백으로 구분되어 주어진다. (1 ≤ N,K ≤ 1,000)<br/>
이후 N개의 줄에 걸쳐, i+1번째 줄에 i번째 알고리즘의 j번째 문제의 난이도를 의미하는 정수 d_i1, ..., d_iK가 공백으로 구분되어 주어진다. (1 ≤ d_ij ≤ 100,000)<br/>

## 출력
N개의 문제들의 순서를 적절히 배치할 때 난이도 커브의 최솟값을 출력한다.<br/>

## 예제 입력
3 3<br/>
7 2 3<br/>
6 9 5<br/>
1 4 3<br/>

## 예제 출력
2<br/>

## 힌트
첫 번째 알고리즘에서 세 번째 문제를 1번, 두 번째 알고리즘에서 세 번째 문제를 3번, 세 번째 알고리즘에서 두 번째 문제를 2번으로 내면 난이도 커브는 2로 최소가 된다.<br/>

## 풀이
1 ~ n 까지 하나씩 선택하고 오름차순으로 문제를 정렬한다.<br/>
그리고 연속된 범위로 문제를 선택한다.<br/>
선택되면 양 끝값을 빼서 최소값을 찾으면 된다.<br/>

## 문제 링크
https://www.acmicpc.net/problem/31411