# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 그리디 알고리즘
  - 누적 합

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
아래와 같이 좌우로 N개의 장소가 있다.<br/>

|9|9|4|1|4|9|9|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

장소들 중 서로 다른 두 곳을 골라서 벌을 한 마리씩 둔다. 또, 다른 한 장소를 골라서 벌통을 둔다. 아래 그림에서 동그라미 숫자 장소는 벌이 있는 장소이고 이탤릭체 숫자의 장소는 벌통이 있는 장소이다.<br/>

|⑨|⑨|4|1|4|9|*9*|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

두 마리 벌은 벌통으로 똑바로 날아가면서 지나가는 모든 칸에서 꿀을 딴다. 각 장소에 적힌 숫자는 벌이 지나가면서 꿀을 딸 수 있는 양이다.<br/>

  1. 두 마리가 모두 지나간 장소에서는 두 마리 모두 표시된 양 만큼의 꿀을 딴다. (벌통이 있는 장소에서도 같다.)
  2. 벌이 시작한 장소에서는 어떤 벌도 꿀을 딸 수 없다.

위의 그림과 같이 배치된 경우 두 마리의 벌 모두 4 + 1 + 4 + 9 + 9 = 27의 꿀을 따서, 전체 꿀의 양은 54가 된다.<br/>

|⑨|9|4|①|4|9|*9*|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

위의 그림과 같이 배치된 경우 왼쪽 장소에서 출발한 벌은 9 + 4 + 4 + 9 + 9 = 35의 꿀을 따고 오른쪽 장소에서 출발한 벌은 4 + 9 + 9 = 22의 꿀을 따므로, 전체 꿀의 양은 57이 된다.<br/>

|⑨|9|*4*|1|4|9|⑨|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

위의 그림과 같은 경우는 전체 꿀의 양이 31이 된다.<br/>
장소들의 꿀 양을 입력으로 받아 벌들이 딸 수 있는 가능한 최대의 꿀의 양을 계산하는 프로그램을 작성하라.<br/>


## 입력
첫 번째 줄에 장소의 수 N이 주어진다.<br/>
다음 줄에 왼쪽부터 각 장소에서 꿀을 딸 수 있는 양이 공백 하나씩을 사이에 두고 주어진다.<br/>


## 출력
첫 번째 줄에 가능한 최대의 꿀의 양을 출력한다.<br/>


## 제한
  - 3 ≤ N ≤ 100,000
  - 각 장소의 꿀의 양은 1 이상 10,000 이하이다.


## 예제 입력
7<br/>
9 9 4 1 4 9 9<br/>


## 예제 출력
57<br/>


## 풀이
벌통과 꿀벌의 위치 관계로 보면 3가지 경우로 나뉜다.<br/>

  1. 벌통이 꿀벌들보다 왼쪽에 위치하는 경우
  2. 벌통이 꿀벌들보다 오른쪽에 위치하는 경우
  3. 벌통이 꿀벌 사이에 있는 경우

먼저 1번의 경우를 보자. 벌통 왼쪽에 장소가 있다면 왼쪽에 두면 해당 장소의 꿀도 추가로 얻을 수 있다.<br/>
그래서 벌통을 1번에 놓는게 제일 좋다.<br/>
또한 꿀벌 중 오른쪽에 있는 꿀벌 r를 보자.<br/>
r의 오른쪽에 장소가 있다면 오른쪽에 두면 기존 벌이 있는 위치의 꿀을 추가로 얻을 수 있다.<br/>
그래서 r을 n번 장소에 놓는것이 좋다.<br/>


2번의 경우도 같은 이유로 벌통을 n번 장소에 놓고 꿀벌 1마리를 1번 장소에 놓는 것이 좋다.<br/>


3번의 경우도 마찬가지로 꿀벌들을 1번과 n번에 할당하는 것이 좋다.<br/>


이제 1, 2번의 경우 꿀벌을 2 ~ n - 1번 사이에 놓으면서 최대 꿀 획득량을 구한다.<br/>
3번의 경우 꿀통을 2 ~ n - 1번 사이에 놓으면서 최대 꿀 획득량을 구한다.<br/>


이렇게 찾은 각 경우의 최댓값 중에 정답 후보가 있다.<br/>


이제 구하는 과정을 1번의 경우 어떻게 비교하면 되는지 보자.<br/>
2 ~  n - 1번 사이에 놓는 꿀벌을 놓는 장소를 i라 하자.<br/>
그러면 j번 위치에 있는 꿀의 양을 arr[j]라 할 때, arr[1] + arr[2] + ... + arr[i - 1] + arr[i + 1] + arr[i + 2] + ... arr[n - 1]이 된다.<br/>
이는 누적 합을 이용하면 O(1)에 찾을 수 있다.<br/>


sum[i] = arr[1] + arr[2] + ... + arr[i]라 하면<br/>
(arr[1] + arr[2] + ... + arr[i - 1]) * 2 + arr[i + 1] + arr[i + 2] + ... arr[n - 1] = (sum[i - 1] - sum[0]) * 2 + sum[n - 1] - sum[i]가 된다.<br/>


2번, 3번의 경우도 누적합을 이용해 식을 표현하면 각각의 경우를 O(1)에 찾을 수 있다.<br/>
그래서 2 ~ n - 1번에 놓기 때문에 전체 시간 복잡도는 O(N)이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/21758