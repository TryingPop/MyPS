# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 브루트포스 알고리즘
  - 정수론
  - 소수 판정
  - 에라토스테네스의 체

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
0부터 9까지 K가지의 숫자를 한 번씩만 사용하여 만들 수 있는 수 중 아래 조건을 모두 만족하는 수들의 개수를 구해보자. 단, 수의 맨 앞에는 0이 올 수 없다. 즉, 0143는 불가능하다.<br/>

  1. 서로 다른 두 개의 소수의 합으로 나타낼 수 있는 경우
  2. M으로 나누어 떨어지지 않을때까지 나눈 수가 두 개의 소수의 곱인 경우, 이 때, 두 개의 소수가 같아도 된다.

예를 들어, K가 1이고 M이 11인 경우로 생각해보자. 한자리 수 중 1번 조건을 만족하는 수는 5, 7, 8, 9이고 2번 조건을 만족하는 수는 4, 6, 9가 있다. 이 두개의 조건을 둘다 만족하는 수는 9이므로 이 경우에는 1개이다.<br/>


## 입력
첫 번째 줄에 K와 M 주어진다.<br/>


## 출력
2가지 조건을 만족하는 수의 개수를 출력한다.<br/>


## 제한
  - 1 ≤ K ≤ 5
  - 2 ≤ M ≤ 10^9
  - K, M은 정수

## 예제 입력
1 11<br/>


## 예제 출력
1<br/>


## 힌트
2가지 조건을 동시에 만족하는 수는 9밖에 없다.<br/>


## 풀이
K는 5 이하이므로 나올 수 잇는 수는 커봐야 10만을 넘기지 못한다.<br/>
그래서 연산하는 소수는 10만 이하이고, 10만 이하의 소수를 에라토스테네스 체로 먼저 다 찾는다.<br/>


1번 조건의 경우 골드바흐의 추측으로 4 이상의 짝수는 소수 + 소수로 나타낼 수 있다.<br/>
그런데 찾는 짝수는 서로 다른 소수이므로 8 미만은 서로 다른 소수로 표현할 수 없음을 바로 확인할 수 있다.<br/>
Lemma 코드로 확인해보니 8 이상 10만 이하에서는 서로 다른 소수로 표현할 수 있었다.<br/>


그래서 홀수인 경우만 서로 다른 소수의 합으로 표현할 수 있는지 확인했다.<br/>
홀수인 경우는 홀수 + 홀수 = 짝수이므로 짝수 + 홀수일 수 밖에 없다.<br/>
짝수인 소수는 2로 유일하므로 2를 뺀값이 소수인지 확인하면 된다.<br/>


이후 기존 값을 M으로 나눠떨어지지 않게 기존 값을 M 나눈다.<br/>
그리고 몫으로 기존 값을 갱신한다.<br/>
이렇게 M으로 나눠떨어지지 않을때까지 기존 값을 갱신한다.<br/>


이후 2부터 기존값까지 조사하며 두 소수로 나눠떨어지는지 확인하고 경우의 수를 누적했다.<br/>

수를 만드는 것은 DFS로 하나씩 넣고 빼며 만들어갔다.<br/>
이렇게 브루트포스와 에라토스테네스 체이론으로 풀었다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/22943