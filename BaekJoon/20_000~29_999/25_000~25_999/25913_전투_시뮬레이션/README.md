# C#

## 난이도 : 플레티넘 2

## 알고리즘 분류
  - 자료 구조
  - 정렬
  - 세그먼트 트리
  - 누적 합
  - 머지 소트 트리

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
Cube219는 전투 시뮬레이션 게임을 즐겨한다. 이 게임에는 길이가 N인 공간에 일렬로 1번부터 N번까지 순서대로 병사들이 있다. i번째 병사는 a_i의 전투력을 가지고 있다. 전투력은 음수가 될 수도 있다.<br/>
Cube219는 Q번의 전투 시뮬레이션을 하려 한다. i번째 전투에는 l_i번째부터 r_i번째까지 연속된 구간을 선택하고, 이 구간을 [l_i, ..., k], [k+1, ..., r_i] 인 연속된 2개의 그룹으로 팀을 나누어 전투를 하려 한다. 팀의 전투력은 팀에 속한 병사들의 전투력의 합으로 결정된다.<br/>
Cube219는 전투가 치열하게 일어나는 것을 좋아해서, 두 그룹의 전투력 차이를 최소화하게 팀을 나누려고 한다. 다만 병사의 수가 너무 차이나는 것도 싫어서, 한 그룹의 크기가 전체 전투 구간의 2 / 3를 넘지 않도록 하려 한다. 위 조건을 만족하면서, 각 전투 시뮬레이션마다 팀의 전투력 차이의 최솟값을 구하시오.<br/>


## 입력
첫 번째 줄에 구간의 길이 N이 정수로 주어진다. (3 ≤ N ≤ 300,000)<br/>
두 번째 줄에 N개의 정수 a_1, ..., a_N이 공백으로 구분되어 주어진다. (-10^9 ≤ a_i ≤ 10^9) a_i는 i번째 병사의 전투력이다.<br/>
세 번째 줄에 전투 시뮬레이션 횟수 Q가 정수로 주어진다. (1 ≤ Q ≤ 300,000)<br/>
네 번째 줄부터는 Q개의 줄에 걸쳐 정수 l_i, r_i가 공백으로 구분되어 주어진다. (1 ≤ l_i ≤ r_i ≤ N; r_i-l_i+1은 3의 배수) l_i, r_i는 i번째 전투 시뮬레이션 구간의 왼쪽 끝과 오른쪽 끝 위치이다.<br/>


## 출력
Q개의 줄에 각 전투 시뮬레이션마다 팀의 전투력 차이의 최솟값을 출력한다.<br/>


## 예제 입력
10<br/>
27 1 11 17 -5 9 3 -10 -10 9<br/>
5<br/>
4 9<br/>
1 6<br/>
3 5<br/>
2 10<br/>
1 9<br/>


## 예제 출력
20<br/>
4<br/>
1<br/>
23<br/>
35<br/>


## 풀이
찾아야 하는 값은 [l, r] 구간에 있는 k중 |Sum(l, k) - Sum(k + 1, r)|의 최솟값을 찾아야 한다.<br/>
여기서 |a|는 절댓값 a를 의미하고 Sum(a, b)는 arr[i]를 i번째 병사의 전투력이라 할 때, Sum(a, b) = arr[a] + arr[a + 1] + ... + arr[b]를 뜻한다.<br/>


Sum(l, k) - Sum(k + 1, r)= Sum(0, k) - Sum(0, l -1) - Sum(0, r) + Sum(0, k)를 얻을 수 있다.<br/>
sum[a] = arr[0] + arr[1] + ... + arr[a]라 하자.<br/>
Sum(l, k) = sum[k] + sum[k] - sum[r] - sum[l - 1]로 된다.<br/>
여기서 r, l은 고정되어 있으므로 (sum[r] + sum[l - 1]) / 2 = C 상수로 볼 수 있다.<br/>
이는 C와 가장 가까운 sum[k]를 찾아야 한다.<br>


해당 구간에 sum이 정렬되어져 있으면 C <= sum[k] 조건으로 최소인 k를 찾는 이분 탐색으로 찾을 수 있다.<br/>
정렬되어 있으므로 sum[i] <= C인 최대 i는 k - 1임은 자명하다.<br/>
그래서 k를 찾고 k - 1도 확인했다.<br/>
그래서 누적 합 배열을 기준으로 머지 소트 트리를 만들어 풀었다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/25913