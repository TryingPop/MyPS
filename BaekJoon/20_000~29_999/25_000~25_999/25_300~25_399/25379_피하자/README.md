# C#

## 난이도 : 실버 4

## 알고리즘 분류
  - 그리디 알고리즘

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
음이 아닌 정수로 이루어진 길이 N의 배열 A = [A1, A2, · · · , AN]가 있다. 배열 A에서 인접한 두 수를 교환하는 시행을 원하는 만큼 할 수 있다. 이 때, 홀수와 짝수가 인접한 경우가 최대 1번 등장하도록 하는 시행의 최소 횟수를 구하여라. 단, 0 또한 짝수로 간주함에 유의하라.<br/>
예를 들어, 아래 그림과 같이 A = [4, 5, 1, 0]인 상황을 살펴보자. 이 경우, 마지막 두 원소를 교환하는 시행 과 가운데 두 원소를 교환하는 시행을 차례로 수행하면 A가 [4, 0, 5, 1]이 되어 홀수와 짝수가 인접한 경우가 최대 1번 등장하도록 할 수 있다.<br/>



|4|5|1|0|
|:---:|:---:|:---:|:---:|


1, 0을 교환한다.<br/>


|4|5|0|1|
|:---:|:---:|:---:|:---:|


5, 0을 교환한다.<br/>


|4|0|5|1|
|:---:|:---:|:---:|:---:|


그러면 짝수와 홀수가 인접한 경우가 1번이다.<br/>


## 입력
첫 번째 줄에 정수 N이 주어진다.<br/>
두 번째 줄에 배열의 원소 A1, A2, · · · , AN이 사이에 공백을 두고 주어진다.<br/>


## 출력
첫 번째 줄에 답을 출력한다.<br/>


## 제한
  - 1 ≤ N ≤ 1,000,000.
  - 0 ≤ Ai ≤ 2 × 10^9 (1 ≤ i ≤ N).
  - Ai는 정수이다.


## 예제 입력
4<br/>
4 5 1 0<br/>


## 예제 출력
2<br/>


## 풀이
짝수와 홀수가 인접한 칸이 최대 1개라 하자.<br/>
그러면 다음과 같은 경우 뿐이다.<br/>

  1. 모두 홀수인 경우
  2. 모두 짝수인 경우
  3. 짝수항들의 모임 + 홀수항들의 모임
  4. 홀수항들의 모임 + 짝수항들의 모임


모든 경우 1번째가 짝수인 경우 혹은 1번째가 홀수인 경우로 표현할 수 있고 서로 다르므로 전체 경우는 이로 분할 된다할 수 있다.<br/>


그래서 1번항부터 짝수를 최소한 이동하며 모아 놓는 경우와, 1번 항부터 홀수를 최소한으로 이동하며 모아놓은 경우의 값을 찾는다.<br/>
그리디로 각 경우의 최솟값이 보장되고 전체 경우는 위 두 경우로 분할되기에 둘 중 작은 값이 정답이 된다.<br/>


그래서 두 포인터 알고리즘을 이용해 최솟값을 찾았다.<br/>
만약 현재 값이 짝수면 짝수 끝을 나타내는 포인터로 현재 항을 옮긴다.<br/>
짝수 끝을 나타내는 포인터를 짝수 포인터라 줄여 표현한다.<br/>
이는 왼쪽으로 짝수를 이동하는 것과 같고 왼쪽 끝으로 옮겼기에 최소 이동횟수다.<br/>
최소 이동횟수는 짝수항의 포인터와 현재 항의 포인터가 가리키는 값의 차이가 최소 이동횟수가 된다.<br/>


짝수가 왼쪽 끝으로 이동했으므로 짝수 끝을 나타내는 포인터의 값을 1 증가 시킨다.<br/>
그러면 현재 경우는 끝났으므로 다음을 탐색한다는 의미로 현재 포인터를 다음 위치로 옮긴다.<br/>
반면 값이 홀수인 경우 왼쪽으로 이동시킬 필요 없고 다음 항을 탐색한다는 의미로 현재 포인터만 다음 위치로 옮긴다.<br/>


다음 경우를 보자.<br/>


|항|0|1|2|3|4|5|\.\.\.|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|값|2|5|4|3|5|6|\.\.\.|
|현재 포인터 위치|↑|||||||
|짝수 포인터 위치|↑|||||||


현재 0번항의 값은 짝수이다.<br/>
그래서 짝수 포인터의 위치와 현재 포인터의 위치차이 0이 이동횟수이다.<br/>
그래서 총 이동횟수는 0이고 짝수 포인터의 위치를 1 증가한다.<br/>


|항|0|1|2|3|4|5|\.\.\.|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|값|2|5|4|3|5|6|\.\.\.|
|현재 포인터 위치|↑|||||||
|짝수 포인터 위치||↑||||||



그리고 다음 항을 본다.<br/>


|항|0|1|2|3|4|5|\.\.\.|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|값|2|5|4|3|5|6|\.\.\.|
|현재 포인터 위치||↑||||||
|짝수 포인터 위치||↑||||||


현재 포인터가 가리키는 1항의 값이 5로 홀수이므로 현재 포인터만 다음 포인터로 이동한다.<br/>


|항|0|1|2|3|4|5|\.\.\.|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|값|2|5|4|3|5|6|\.\.\.|
|현재 포인터 위치|||↑|||||
|짝수 포인터 위치||↑||||||


현재 포인터가 가리키는 값이 4로 짝수이다.<br/>
현재 포인터와 짝수 포인터의 위치차이만큼 값 1을 총 이동횟수에 누적한다. 그러면 총 이동횟수는 1이다.<br/>
그리고 짝수 포인터의 위치를 1 증가 시킨다.<br/>


|항|0|1|2|3|4|5|\.\.\.|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|값|2|5|4|3|5|6|\.\.\.|
|현재 포인터 위치|||↑|||||
|짝수 포인터 위치|||↑|||||
|이동한 값|2|4|5|||||


그리고 현재 포인터의 위치를 다음 포인터의 위치로 가리킨다.<br/>


|항|0|1|2|3|4|5|\.\.\.|
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
|값|2|5|4|3|5|6|\.\.\.|
|현재 포인터 위치||||↑||||
|짝수 포인터 위치|||↑|||||


이렇게 진행해가며 짝수를 왼쪽으로 이동시킨 총 이동횟수를 찾으면 된다.<br/>
최소한으로 이동 시켰으므로 그리디로 짝수항을 모두 왼쪽으로 이동시킨 최솟값이 보장된다.<br/>
이와 마찬가지로 홀수를 왼쪽으로 이동시킨 총 이동횟수를 찾으면 된다.<br/>


그리고 이렇게 찾은 값 중 최솟값은 전체의 최솟값이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/25379