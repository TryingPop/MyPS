# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 배낭 문제

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
블루아카이브에 있는 아비도스 고등학교 학생, 스나오오카미 시로코는 은행 터는 것을 자주 시뮬레이션한다.<br/>
어느 날, 정말로 은행을 털어보고 싶다는 생각이 든 시로코는 은행을 털 준비를 하기 시작했다. 우선, 은행 터는 것을 함께 할 팀을 만들 것인데, 경쟁을 뚫고 마지막까지 살아남은 n명 중에서 최종적으로 k명을 팀원으로 선발할 계획이다. 지원자들은 각각 힘과 스피드 수치 a, b가 주어지는데, 쟁쟁한 경쟁을 뚫고 살아남은 자들답게 a+b가 모두 동일하다.<br/>
i번째 팀원으로 선발한 사람의 능력치가 각각 a_{i}, b_{i}라 할 때, 그 팀의 종합 능력치는 (∑_{i=1}^{k} a_{i}) x (∑_{i=1}^{k} b_{i})이다. 팀의 능력치를 최대화하게 지원자들을 선발하려 할 때 그때 그 팀의 능력치를 출력하라.<br/>


## 입력
첫 번째 줄에 사람의 수 n와 뽑을 인원 k, 그리고 힘과 스피드 수치의 합 x가 공백으로 구분되어 주어진다.<br/>
그 다음줄부터 n개의 줄에는 각 사람들이 지닌 힘과 스피드 능력치 a b가 주어진다.<br/>


## 출력
팀의 능력치를 최대화하게 인원을 선발할 때, 그 팀의 능력치를 출력하라.<br/>


## 제한
  - 1 ≤ n ≤ 80
  - 1 ≤ k ≤ n
  - 1 ≤ x ≤ 200
  - 0 ≤ a, b


## 예제 입력
4 2 4<br/>
0 4<br/>
1 3<br/>
3 1<br/>
2 2<br/>


## 예제 출력
16<br>


## 힌트
2번째와 3번째 사람으로 팀을 구성하면 팀의 능력치가 4 x 4=16이 되고, 이것이 최대이다.<br/>


## 풀이
aᵢ + bᵢ = x ≤ 200이고, n ≤ 80이므로 모든 사람을 선택한다고 해도 가능한 총 점수의 범위는 80 × 200 = 16,000 정도로 매우 작다.<br/>
따라서, 배낭 알고리즘으로 접근해도 k ≤ 80이기 때문에 시간 복잡도는 16,000 × 80 × 80 = 102,400,000으로, 괜찮지 않을까 생각했다.<br/>


k명을 선택했을 때 가능한 총합의 범위를 xk라고 하면, 1명당 점수 조합을 고려하는 경우는 16,000 × 80 = 15,800 + 15,600 + ... + 200 + 0 < 320,000으로 줄어든다.<br/>
이로 인해 전체 상태 수는 320,000 × 80 = 25,600,000으로 1억 미만이 되어 현실적인 범위에 들어온다.<br/>
그래서 효율적으로 조사하면 배낭 알고리즘이 유효함을 확인했다. 그래서 배낭 알고리즘으로 문제를 해결했다.<br/>


dp[i][j] = true는 i명을 선택했을 때 총합이 j가 되는 경우가 가능함을 의미한다.<br/>
즉, 어떤 dp[i - 1][j - aₖ]가 true이면, dp[i][j]도 true가 된다.<br/>
여기서 aₖ는 k번째 사람의 a 점수이다.<br/>


이때 aₖ가 중복 선택되지 않도록 i를 내림차순으로 순회하며 점화식을 계산해야 한다.<br/>
초기 조건은 dp[0][0] = true이다.<br/>


이렇게 dp 배열을 채운 후, dp[k][j]가 true인 모든 j에 대해 가능한 경우를 조사한다.<br/>
이때 k명을 선택했을 때 a의 총합이 j라면, b의 총합은 (kx - j)가 된다.<br/>
따라서 ∑a × ∑b = j × (kx - j)가 되고, 이 값들 중 최댓값을 구해 정답으로 삼는다.<br/>


ai + bi = x로 일정하다. 그래서 ∑ai + ∑bi = ∑(ai + bi) = kx이다.<br/>
산술기하 평균으로 ∑ai ∑bi 의 최댓값은 |∑ai - ∑bi|가 작을수록 커진다.<br/>
처음에 |∑ai - ∑bi|로 시도했으나 k명 선택에 막혔고 다른 방법을 떠올리다 배낭으로 접근했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/26607