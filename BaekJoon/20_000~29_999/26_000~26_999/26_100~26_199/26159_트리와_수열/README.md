# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 그래프 이론
  - 그리디 알고리즘
  - 그래프 탐색
  - 정렬
  - 트리
  - 깊이 우선 탐색
  - 트리에서의 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
N개의 정점으로 구성된 트리가 있다. 각 정점은 1번부터 N번까지 번호가 매겨져 있다. 또한 N-1개의 음이 아닌 정수로 이루어진 수열이 있다.<br/>
트리의 간선에 수열의 원소들을 하나씩 대응시켜 가중치를 매길 것이다. 이때 가능한 ∑dist(i,j) (1 ≤ i < j ≤ N)의 최솟값을 10^9+7로 나눈 나머지를 구하려고 한다.<br/>
dist(i,j)는 트리의 i번 정점과 j번 정점 사이의 단순 경로 상 가중치의 합을 의미한다.<br/>


## 입력
첫 번째 줄에 정점의 개수 N이 주어진다. (2 ≤ N ≤ 100,000)<br/>
이후 N-1개의 줄에 걸쳐 트리의 각 간선이 연결하는 두 정점 u, v가 공백으로 구분하여 주어진다.(1 ≤ u, v ≤ N)<br/>
다음 줄에 수열의 원소 a_1, ...,a_{N-1}이 공백으로 구분하여 주어진다. (1 ≤ a_i ≤ 10^9; 모든 a_i 는 정수)<br/>


## 출력
∑dist(i,j) (1 ≤ i < j ≤ N)의 최솟값을 10^9+7로 나눈 나머지를 출력하라.<br/>


## 예제 입력
5<br>
1 2<br>
2 4<br>
2 3<br>
1 5<br>
3 1 4 1<br>


## 예제 출력
38<br>


## 풀이
우리가 찾을 것은 1 ≤ i < j ≤ N에 대해 ∑dis(i, j)의 최솟값이다.<br/>
dis(i, j)는 i에서 j로 이동하는 최단 경로상의 간선들의 가중치 합이다.<br/>


∑dis(i, j)는 양 노드에 초점이 맞춰져 있다.<br/>
주어진 그래프는 트리이므로 i에서 j로 이동하는 최단 경로는 유일하므로 노드가 아닌 간선에 맞춰 보면 다음과 같다.<br/>


간선 k에 대해 f(k)를 (∑dis(i, j)에서 간선 k를 지나는 경우의 수) x (간선 k의 가중치)라 하면 ∑dis(i, j) = ∑f(k)임을 알 수 있다.<br/>
그리고 ∑dis(i, j)의 최솟값은 ∑f(k)의 최솟값과 같다.<br/>


우리가 설정할 수 있는 간선의 가중치 a_i가 주어진다.<br/>
많이 지나가는 간선에 대해 낮은 가중치를 순차적으로 부여하면 다른 값을 부여할 때보다 작음을 알 수 있다.<br/>
그래서 많이 지나가는 간선에 대해 낮은 가중치를 순차적으로 부여하는 것이 그리디로 최소가 된다.<br/>


그러면 간선 k에 대해 ∑dis(i, j)에서 지나가는 횟수를 찾을 수 있어야 한다.<br/>
이는 간선 k를 제거했을 때 기존 그래프는 두 그래프 A, B으로 나뉜다.<br/>
그러면 A그래프에 포함된 노드의 수 |A|, B 그래프에 포함된 노드의 수 |B|라 하면 k를 지나가는 |A| x |B|임을 확인할 수 있다.<br/>
이렇게 간선별로 지나가는 노드의 수를 찾을 수 있다.<br/>


그래서 해당 방법을 쓰기 위해 먼저 기존 그래프를 루트를 1로 변형한다. 그리고 각 노드 cur에 대해 cur을 루트로하는 서브 트리에 포함된 갯수 child[cur]를 DFS로 찾는다.<br/>
그러면 각 간선 k에 대해 k의 양 끝 노드 중 루트와 가까운 것을 f, 루트와 먼 것을 t라 하자.<br/>
기존 그래프는 트리이고 트리는 사이클이 없으므로, 두 노드 간의 최단 경로는 유일하다.<br/>
따라서 간선의 양 끝 중 하나는 항상 루트에 더 가깝다.<br/>


이때 t를 루트로 하는 서브트리의 노드들을 그룹 A라고 하자.<br/>
A그룹에 속한 노드 |A|는 child[t]가 됨을 알 수 있다.<br/>


그러면 B 그룹은 전체 노드 |B| = N - |A| = N - child[t]임을 알 수 있다.<br/>
그리고 간선 k를 지나는 경우는 |A| x |B| = child[t] x (N - child[t])이다.<br/>


이렇게 각 간선에 대해 지나는 경우의 수를 찾았다.<br/>


간선마다 지나는 경로 수를 기준으로 내림차순 정렬하고, 주어진 가중치들을 오름차순 정렬하여 가장 많이 쓰이는 간선에 가장 낮은 가중치를 순서대로 할당했다.<br/>
이렇게 그리디 알고리즘을 이용해 ∑f(k) = ∑dis(i, j)의 최소값을 구했다.<br/>


루트 1인 트리에서 각 노드 cur을 루트로하는 서브트리에 노드를 찾는데 DFS를 이용하면 노드의 개수 N에 찾을 수 있다.<br/>
그리고 서브트리를 이용해 각 간선에 대해 지나가는 노드의 개수를 찾는 것 역시 child 값을 이용하면 N에 찾을 수 있다.<br/>
마지막으로 가중치 값 정렬, 간선을 지나는 노드의 수 배열을 정렬하므로 N log N이 걸린다.<br/>
그래서 전체 시간 복잡도는 O(N log N)이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/26159