# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 문자열
  - 브루트포스 알고리즘
  - 정수론

## 제한조건
  - 시간 제한 : 1.5초
  - 메모리 제한 : 256 MB

## 문제
비즈네르 암호는 고전 암호의 일종으로, 대문자 알파벳으로만 이뤄진 평문에 키를 더하여 암호를 만드는 방법이다. 구체적인 과정은 다음과 같다.<br/>

  1. 평문과 동일한 길이가 될 때까지 키를 반복하여 문자열을 만든다. 이 문제에선 키를 단순 반복해 평문과 동일한 길이를 만들 수 있는 경우만 고려한다.
  2. 평문과 키의 각 알파벳을 1부터 26까지의 수에 순서대로 대응시켜 수열을 만든다. 즉, A=1, B=2, ..., Z=26가 된다.
  3. 평문과 키 수열에서 동일한 위치에 있는 수들을 더하여 암호문을 만든다. 단, 더했을 때 26이 넘는 수의 경우 26만큼 뺀 결과를 사용한다.
  4. 2와 마찬가지로, 암호문에서 수를 다시 알파벳에 대응시켜 문자열로 만들고 최종 결과로 반환한다.

예를 들어, 평문이 HELLOWORLD이고, 키가 SCUPC라고 하자. 1에서 키를 두 번 반복해 SCUPCSCUPC가 되며, 2에서 수에 대응시키면 키는 [19, 3, 21, 16, 3, 19, 3, 21, 16, 3], 평문인 HELLOWORLD는 [8, 5, 12, 12, 15, 23, 15, 18, 12, 4]가 된다. 이후 3에서 동일한 위치에 있는 수를 더하면 [27, 8, 33, 28, 18, 42, 18, 39, 28, 7]이며, 26 초과인 수에서 26을 빼면 [1, 8, 7, 2, 18, 16, 18, 13, 2, 7]이 된다. 이를 다시 알파벳에 대응시키면, 최종 결과는 AHGBRPRMBG가 된다.<br/>
평문과 임의의 키를 사용해 만든 비즈네르 암호문이 주어질 때, 가능한 키 중 가장 짧은 키를 찾아보자.<br/>


## 입력
첫 번째 줄에 평문이 주어진다. 평문은 알파벳 대문자로만 구성되어 있으며, 평문의 길이는 200,000을 넘지 않는다.<br/>
두 번째 줄에 평문에 대한 비즈네르 암호문이 주어진다. 암호문은 알파벳 대문자로만 구성되어 있으며, 주어진 평문과 동일한 길이를 가진다. 올바른 비즈네르 암호문이 주어지며, 답이 항상 존재함이 보장된다.<br/>


## 출력
첫 번째 줄에 가능한 키 중 가장 짧은 키를 출력한다.<br/>


## 예제 입력
BIGDATASECURITY<br>
UNVYMMFHZONWXOK<br>


## 예제 출력
SEOUL<br>


## 풀이
두 문자열의 차를 수열에 저장한다.<br/>
그리고 해당 배열의 가장 짧은 주기를 찾고, 문자열로 변환하면 된다.<br/>


문자열의 길이가 20만이하이고 약수의 갯수는 200_000 <  500_000 < 2 x 3 x 5 x 7 x 11 x 13이므로 2^7 = 128을 넘기지 못한다.<br/>
그래서 약수인 경우 문자열을 조사해 되는지 판별해도 된다고 생각했다. 즉, 브루트포스로 접근했다.<br/>


문자열의 길이를 len이라 하면, n을 1부터 len까지 1씩 증가시키며 두 문자열의 차 배열의 주기가 되는지 확인했다.<br/>
주기가 되는 경우 이를 문자열로 변환해 정답으로 출력하니 이상없이 통과한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/26266