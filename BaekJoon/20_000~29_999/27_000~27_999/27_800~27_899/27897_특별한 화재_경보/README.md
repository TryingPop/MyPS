# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 자료 구조
  - 세그먼트 트리

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
NLCS Jeju는 화재 경보가 자주 울리는 것으로 악명이 높다. 화재 경보가 울리는 이유는 여러 가지가 있는데, 그중 하나는 학생이 장난으로 경보를 울리는 경우이다. 오늘은 NLCS Jeju의 학생인 동호가 작정하고 화재 경보를 울렸다.<br/>
화재 경보가 울리면 교실에 있는 N명의 학생들은 모두 운동장으로 나가 한 줄로 서야 한다. 모든 학생은 키가 서로 다르고, 학생들에게는 키순으로 1번에서 N번까지의 번호가 붙어 있다. 학생들이 운동장으로 이동할 때 항상 질서를 잘 지키는 것은 아니기 때문에, 학생들은 초기에 키순으로 서 있지 않을 수도 있다.<br/>
학생들이 운동장에 모이면, 선생님은 1번부터 N번까지 학생들이 모두 모였는지 확인한다. 어떤 학생 i보다 키가 큰 학생이 i 앞에 없다면, i번 학생을 확인하는 데는 시간이 걸리지 않는다. 그러나, i보다 키가 큰 학생이 i 앞에 k명 있다면, 학생 i가 있다는 사실을 순서대로 앞으로 전달해 주어야 하기 때문에 시간이 k초 더 걸린다. 이렇게 모든 학생을 확인하는 데 걸린 시간의 합이 확인 절차에 걸리는 전체 시간이다.<br/>
그런데 동호는 화재 경보를 울릴 때부터 수업을 하는 시간을 최대한 줄이고 싶었기 때문에, 확인 절차에 걸리는 전체 시간을 최대한 늘리려고 한다. 이를 위해 동호는 최대 L번, 인접한 두 학생의 위치를 교환하려고 한다.<br/>
현재 N명의 학생들이 서 있는 순서와 정수 L이 주어질 때, 최대 L번의 행동을 수행한 후, 확인 절차에 걸리는 전체 시간의 최댓값을 구하는 프로그램을 작성하시오.<br/>


## 입력
첫 번째 줄에 두 개의 양의 정수 N과 L이 공백으로 구분되어 주어진다.<br/>
두 번째 줄에 N개의 양의 정수가 공백으로 구분되어 주어진다. i번째 정수는 줄의 i번째에 서 있는 학생의 번호를 의미한다. 모든 학생의 번호는 1 이상 N 이하이며, 모든 학생들은 번호가 서로 다르다.<br/>


## 출력
확인 절차에 걸리는 전체 시간의 최댓값을 나타내는 정수를 출력한다.<br/>


## 제한
  - 1 ≤ N ≤ 500,000
  - 1 ≤ L ≤ 10^18


## 예제 입력
5 3<br/>
1 3 5 2 4<br/>


## 예제 출력
6<br>


## 힌트
학생들의 순서를 세 번 바꿀 수 있기 때문에 다음과 같이 바꿔준다.<br/>
(1, 3, 5, 2, 4) → (3, 1, 5, 2, 4) → (3, 5, 1, 2, 4) → (3, 5, 2, 1, 4)<br/>
첫 번째와 두 번째 학생을 확인하는 데는 시간이 걸리지 않는다. 세 번째 학생을 확인하는 데는 2초, 네 번째 학생을 부르는 데 3초, 다섯 번째 학생을 부르는 데 1초가 걸리기 때문에 답이 6초가 된다.<br/>


## 요약

  - 목표 : 인접한 두 학생의 위치를 최대 L번 교환하면서 모든 학생을 확인하는데 걸린 시간의 최댓값 찾기

  - 정의:
    - arr[i] = i번째 학생의 번호
    - seg: 1 ~ N값을 저장하는 누적합 세그먼트 트리

  - 초기값:
    - seg[i] = 0
    - cur = 0

  - 방법:
    - 세그먼트 트리 seg에 arr[i]보다 큰 값의 개수를 cur에 누적
    - 세그먼트 트리 seg에 arr[i]의 값을 1개 저장

  - 정답: Min(cur + L, N x (N - 1) / 2)

  - 시간 복잡도: O(N log N)


## 풀이
인접한 두 학생의 위치를 최대 L번 교환하면서 모든 학생을 확인하는데 걸린 시간의 최댓값을 찾아야 한다.<br/>


먼저 모든 학생을 확인하는데 걸린 시간의 최댓값을 확인하자.<br/>
각 학생 i의 확인 시간은 자신보다 뒤 번호를 가진 학생 중 앞에 선 학생의 수에 따라 결정되므로, 각 학생별로 독립적으로 계산할 수 있다.<br/>


가장 확인 시간이 오래 걸리는 경우는 학생들이 번호 순서와 반대로 내림차순으로 서 있을 때이다.<br/>
즉, N, N - 1, ..., 2, 1 순서로 서 있을 경우, i번 학생은 앞에 N - i명의 큰 번호가 있어 총 시간은 (N - 1) + (N - 2) + ... + 1 = (N - 1) × N / 2가 된다.<br/>


이제 최소한의 이동으로 내림차순 수열이 되게 만들어야 한다.<br/>
인접한 두 수를 이동시키기에 모든 수는 서로 다르므로 (작은 수, 큰 수) 순으로 있거나 (큰 수, 작은 수) 순으로만 존재한다.<br/>
대소 관계만 중요하므로 편의상 작은 수를 1, 큰 수를 2로 해서 보자.<br/>


(1, 2) 순서를 바꾸면 (2, 1)이 되고 1의 기준으로 앞에 자기보다 큰 수 2가 새롭게 추가된다.<br/>
그래서 걸리는 시간이 1 증가한다.<br/>


반면 (2, 1) 순서를 바꾸면 (1, 2)가 되고 1을 기준으로 앞에 자기보다 큰 수 2가 1개 없어진다.<br/>
그래서 걸리는 시간이 1 감소한다.<br/>


그래서 변환은 (1, 2)를 (2, 1)로 변환 즉, (작은 수 , 큰 수)를 (큰 수 작은 수)로 변환한다.<br/>


즉, 내림차순 수열 자리를 1부터 이동해 간다고 생각하면 걸리는 시간이 (N - 1) x N / 2까지 이동당 1씩 늘어남을 알 수 있다.<br/>


그래서 우리가 찾는 L번을 교환하는데 걸리는 최대 시간을 찾으려면 현재 걸리는 시간 cur를 알아야 한다.<br/>
그러면 정답은 Min(cur + L, (N - 1) x N / 2)이다.<br/>


현재 걸리는 시간 cur는 단순 브루트포스로 하는 경우 i번째에 대해 i - 1개를 조사하므로 전체를 조사하는데 N x (N - 1) / 2의 연산을 한다.<br/>
그런데 N의 최댓값이 50만이므로 시간초과 난다.<br/>


반면 누적합 세그먼트 트리를 이용하면 전체를 확인하는데 아래 방법을 이용하면 N log N번 연산에 확인할 수 있다.<br/>


오름차순으로 다음과 같은 방법으로 탐색한다.<br/>
i번 자리 값 ai에 대해 세그먼트 트리에 ai보다 큰 값의 개수를 bi라 하자.<br/>
이는 세그먼트 트리를 구간 합 트리로 구성하면 ai + 1 ~ N 범위의 합을 O(log N)에 구할 수 있다.<br/>
그러면 우리가 찾는 결과 cur = ∑ bi임을 알 수 있다.<br/>


이후 Min(cur + L, (N - 1) x N / 2) 식을 이용해 결과를 찾았다.<br/>


각 자리에 대해 누적합 세그먼트 트리에 값 저장으로 O(log N) 연산을 하고, 자기보다 큰 수를 찾는 O(log N) 연산을 한다.<br/>
그리고 Min(cur + L, (N - 1) x N / 2)비교 연산은 O(1)에 찾을 수 있다.<br/>
그래서 전체 시간 복잡도는 O(N x 2 x log N) = O(N x log N)이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/27897