# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 자료 구조
  - 세그먼트 트리

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 512 MB

## 문제
Albert는 정수 덧셈을 연습하고 있다. 이를 지켜보던 Bobby는 연습을 좀 더 재미있게 해주려고 아래와 같은 게임을 제안했다.<br/>

  - 우선 Bobby는 N장의 종이 각각에 정수를 하나씩 적어 Albert에게 전해준다. 편의상 이 수들을 V_1, V_2, ..., V_N 이라하자.
  - 다음 총 M번에 걸쳐 Bobby는 Albert에게 아래 4가지 중 한 가지 요청을 한다. 편의상 j 번째 요청의 종류를 Q_j ∈ {1, 2, 3, 4}이라 하고 그에 동반되는 (후술될) 정수 값을 W_j로 나타내자 (j = 1, 2, ..., M).
    - Q_j = 1인 요청: 새 종이 한 장에 정수 W_j를 적어 Albert에게 전해준다.
    - Q_j = 2인 요청: Albert는 현재 자신이 갖고 있는 각각의 종이에 적힌 값에 W_j를 더해 새로운 값을 적는다.
    - Q_j = 3인 요청: Albert가 현재 갖고 있는 종이에 적힌 수 중 가장 큰 W_j개의 수를 더해 그 값을 Bobby에게 알려준다. 이 값을 A_j라 하자.
    - Q_j = 4인 요청: Albert가 현재 갖고 있는 종이에 적힌 수 중 가장 작은 W_j개의 수를 더해 그 값을 Bobby에게 알려준다. 이 값을 A_j라 하자.

예를 들어 N = 5, V = [2, 4, 6, 8, 10], M = 12, Q = [4, 3, 1, 1, 4, 3, 2, 4, 3, 1, 3, 4] 그리고 W = [3, 3, 3, 7, 3, 3, 5, 3, 3, 1, 4, 4] 라 하자. 이 경우 아래 표에서 각 요청 이후 Albert가 어떤 수들을 갖고 있는지 확인할 수 있다.<br/>

|시점|Albert의 종이에 적힌 수들|설명|
|:---:|:---:|:---:|
|게임 시작 직후|2, 4, 6, 8, 10||
|1번째 요청 직후|2, 4, 6, 8, 10|A_1 = 2 + 4 + 6 = 12|
|2번째 요청 직후|2, 4, 6, 8, 10|A_2 = 10 + 8 + 6 = 24|
|3번째 요청 직후|2, 3, 4, 6, 8, 10|3을 추가했다.|
|4번째 요청 직후|2, 3, 4, 6, 7, 8, 10|7을 추가했다.|
|5번째 요청 직후|2, 3, 4, 6, 7, 8, 10|A5 = 2 + 3 + 4 = 9|
|6번째 요청 직후|2, 3, 4, 6, 7, 8, 10|A6 = 10 + 8 + 7 = 25|
|7번째 요청 직후|7, 8, 9, 11, 12, 13, 15|모든 수에 5를 더했다.|
|8번째 요청 직후|7, 8, 9, 11, 12, 13, 15|A_8 = 7 + 8 + 9 = 24|
|9번째 요청 직후|7, 8, 9, 11, 12, 13, 15|A_9 = 15 + 13 + 12 = 40|
|10번째 요청 직후|1, 7, 8, 9, 11, 12, 13, 15|1을 추가했다.|
|11번째 요청 직후|1, 7, 8, 9, 11, 12, 13, 15|A_11 = 15 + 13 + 12 + 11 = 51|
|12번째 요청 직후|1, 7, 8, 9, 11, 12, 13, 15|A_12 = 1 + 7 + 8 + 9 = 25|

Albert는 신나서 이 게임을 하기로 했는데, 막상 Bobby는 게임을 제안했지만 준비가 되지 않았다. Bobby는 당신의 도움을 받아 Albert가 더해낸 값들이 맞는지(위 예제에서 A_1, A_2, ..., A_11, A_12 등의 값) 확인해 달라고 부탁했다. 즉, Q_j ∈ {3, 4}인 경우에 대해 올바른 A_j 값을 구해서 Bobby에게 알려주자.<br/>


## 입력
입력 첫 줄에 테스트 케이스의 수 T가 주어진다.<br/>
각 테스트 케이스의 첫 줄에는 두 정수 N, M이 공백으로 구분되어 주어진다. 둘째 줄에는 V_1, V_2, ..., V_N을 나타내는 N개의 정수가 공백으로 구분되어 주어진다. 다음 M줄에 걸쳐 각 줄에 Q_j, W_j 두 개의 정수가 공백으로 구분되어 주어진다.<br/>


## 출력
각 테스트 케이스의 정답이 되는 A_j 값을 각 줄에 공백으로 구분하여 출력한다. 단, 입력으로 주어진 Q_j 값이 3 혹은 4인 경우에만 A_j값을 구하면 된다.<br/>


## 제한
  - 1 ≤ T ≤ 20
  - 1 ≤ N, M ≤ 50,000
  - 1 ≤ i ≤ N인 i에 대하여: 1 ≤ V_i ≤ 500,000
  - 1 ≤ j ≤ M인 j에 대하여: Q_j ∈ {1, 2, 3, 4} 이고 1 ≤ W_j이다.
    - Q_j ∈ {1, 2}인 경우 1 ≤ W_j ≤ 500,000를 만족한다.
    - Q_j ∈ {3, 4}인 경우 W_j의 값은 Albert가 갖고 있는 수의 총 개수를 넘지 않는다. 즉, W_j ≤ N + \|{k<j:Q_k = 1}\| 이다.
  - 각 테스트 케이스 내에서 Q_j = 2인 경우의 W_j 총합은 500,000이하이다. 즉, ∑_j:Q_j=2 W_j ≤ 500,000.
 

## 예제 입력
2<br>
5 12<br>
2 4 6 8 10<br>
4 3<br>
3 3<br>
1 3<br>
1 7<br>
4 3<br>
3 3<br>
2 5<br>
4 3<br>
3 3<br>
1 1<br>
3 4<br>
4 4<br>
5 8<br>
1 1 1 1 500000<br>
4 5<br>
3 5<br>
2 100000<br>
4 3<br>
3 3<br>
2 400000<br>
4 3<br>
3 3<br>

## 예제 출력
12 24 9 25 24 40 51 25<br>
500004 500004 300003 800002 1500003 2000002<br>


## 힌트
예제 1: 본문에서 다루었다.<br/>
예제 2: 아래 표는 Alice의 각 요청 이후 게임 상태를 설명해준다. 참고로 6번째 요청 직후 더 이상 Alice는 2번 요청 (모든 수에 다른 수를 더하도록 하는 요청)을 할 수 없는데, 한 번 더 2번 요청을 하면 입력 제한 마지막 조건을 어기게 되기 때문이다.<br/>

|시점|Albert의 종이에 적힌 수들|설명|
|:---:|:---:|:---:|
|게임 시작 직후|1, 1, 1, 1, 500000||
|1번째 요청 직후|1, 1, 1, 1, 500000|A_1 = 1 + 1 + 1 + 1 + 500000 = 500004|
|2번째 요청 직후|1, 1, 1, 1, 500000|A_2 = 500000 + 1 + 1 + 1 + 1 = 500004|
|3번째 요청 직후|100001, 100001, 100001, 100001, 600000|모든 수에 100000을 더했다.|
|4번째 요청 직후|100001, 100001, 100001, 100001, 600000|A_4 = 100001 + 100001 + 100001 = 300003|
|5번째 요청 직후|100001, 100001, 100001, 100001, 600000|A_5 = 600000 + 100001 + 100001 = 800002|
|6번째 요청 직후|500001, 500001, 500001, 500001, 1000000|모든 수에 400000을 더했다.|
|7번째 요청 직후|500001, 500001, 500001, 500001, 1000000|A_7 = 500001 + 500001 + 500001 = 1500003|
|8번째 요청 직후|500001, 500001, 500001, 500001, 1000000|A_8 = 1000000 + 500001 + 500001 = 2000002|


## 풀이
중간에 원소를 추가하고, 구간합을 구해야 한다. 만약 원소를 변형시키지만 않는다면 세그먼트 트리로 풀 수 있다.<br/>
모든 보유하고 있는 원소에 w를 더한다는 것은 누적 값에 add 변수에 w를 누적해주고 값을 찾을 때 원소 갯수 x add를 더해주면 된다.<br/>


예를들어, 2, 4, 6, 8, 10에서 3씩 더하자.<br/>
5, 7, 9, 11, 13으로 변한다.<br/>
여기서 2를 추가하면 2, 5, 7, 9, 11, 13이 된다.<br/>


이는 2, 4, 6, 8, 10에 3을 더하는 것은 add = 0에서 add에 3을 누적해 add = 3으로 만든다.<br/>
그리고 2를 추가하는 것은 2에 add를 뺀 값을 저장한다.<br/>
그러면 -1, 2, 4, 6, 8, 10이 저장된다.<br/>
이는 각각에 add를 더해주면 2, 5, 7, 9, 11, 13과 같다.<br/>
이에 값을 찾을 때 각 원소에 add를 더해줘서 찾으면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/27929