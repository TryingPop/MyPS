# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 자료 구조
  - 그리디 알고리즘
  - 우선순위 큐

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
중간고사를 시원하게 망친 찬우는 오늘부터 1분도 쉬지 않고 기말고사 공부에 매진하기로 다짐했다.<br/>
기말고사는 정확히 24 x N시간 이후에 시작되며, 쉬는 시간 없이 하루에 모든 과목의 시험을 보기 때문에 찬우는 24 x N시간동안 공부할 수 있다. 기말고사를 보는 과목은 총 M개로, 시험 시간이 빠른 과목부터 각각 1부터 M까지의 번호가 매겨져 있다. 모든 과목의 최저점은 0점, 최고점은 100점이다.<br/>
찬우는 공부를 하나도 하지 않아도 i번 과목에서 a_i 점을 받을 수 있으며, i번 과목을 정확히 한 시간 공부할 때마다 그 과목의 성적을 b_i점 올릴 수 있다. 하지만 i번 과목을 30분 공부한다고 b_i / 2점이 오르지는 않으며, 아무리 공부하더라도 한 과목에서 최고점인 100점이 넘는 점수를 받을 수는 없다.<br/>
모든 과목의 점수의 합이 찬우의 최종 성적이 된다. 높은 성적을 받기 위한 최적의 전략으로 공부할 때, 찬우가 받을 수 있는 최종 성적의 최댓값을 출력하는 프로그램을 작성하시오.<br/>


## 입력
첫째 줄에 정수 N, M이 공백으로 구분되어 주어진다.<br/>
둘째 줄에는 정수 a_1, a_2, ..., a_M이 공백으로 구분되어 주어진다.<br/>
셋째 줄에는 정수 b_1, b_2, ..., b_M이 공백으로 구분되어 주어진다.<br/>


## 출력
첫째 줄에 찬우가 받을 수 있는 최종 성적의 최댓값을 출력한다.<br/>

## 제한
  - 1 ≤ N, M ≤ 200,000
  - 1 ≤ a_i, b_i ≤ 100


## 예제 입력
8 7<br/>
30 15 70 50 40 40 50<br/>
2 2 1 3 1 2 1<br/>


## 예제 출력
627<br/>


## 힌트
192시간 동안 1번 과목을 35시간, 2번 과목을 43시간, 3번 과목을 30시간, 4번 과목을 17시간, 5번 과목을 37시간, 6번 과목을 30시간동안 공부하면 1, 2, 3, 4, 6번 과목은 100점, 5번 과목은 77점, 7번 과목은 50점을 받게 된다. 이때 찬우의 최종 점수는 627점이 되며, 과목별 공부시간을 어떻게 조절해도 627점보다 높은 성적을 받을 수는 없다.<br/>


## 풀이
각 시간 별로 점수 상승이 높은 것을 공부하는 것이 이외 점수를 공부하는 것보다 최종 점수를 더 높일 수 있다.<br/>
그래서 가장 상승이 높은 것을 공부하는 것이 그리디로 최대임이 보장된다.<br/>
점수 상승값을 기준으로 정렬해, 가장 높은 것부터 차례로 공부하면 된다.<br/>


점수 상승값은 다음과 같이 구할 수 있다.<br/>
각 i에 대해 a_i를 기본 점수, b_i를 공부당 상승 점수라 하면 b_i만큼 오르는 횟수는 c_i = (100 - a_i) // b_i가 된다.<br/>
여기서 //는 몫 연산이다.<br/>


c_i + 1번에는 (100 - a_i) % b_i 점수가 오르고 이후 c_i + 2번 부터는 더 이상 점수가 오르지 않는다.<br/>
이러한 방식으로 각 시험별로 점수 상승 횟수를 계산할 수 있다.<br/>


예를들어 기본 점수 a_i가 1점이고 공부당 상승하는 점수 b_i가 2점인 경우 2점 상승이 49개, 1점 상승이 1개 나온다.<br/>


만약 오르는 점수들을 모두 배열에 넣는다면 시험은 최대 20만개이다.<br/>
모든 시험의 기존 점수가 1점이고 오르는 폭이 모두 1점인 경우 각각 99개씩 나온다.<br/>
그래서 배열에 점수들을 저장한다면 99 x 20만으로 약 1.98억개가 나오므로 메모리를 많이 쓰게된다.<br/>


오르는 점수 범위가 1 ~ 100이므로 개수를 기록해 찾아줬다.<br/>
그러면 단위 별로 개수를 기록한다면 100개의 배열로 해결이 된다.<br/>


앞의 예에서 기본 점수 a_i가 1점이고 공부당 상승하는 점수 b_i가 2점인 경우 2점 상승이 49개, 1점 상승이 1개 나온다.<br/>
이를 dp[2] += 49, dp[1] += 1로 기록해준다.<br/>


각 시험마다 점수 b_i는 c_i번 누적되고, 나머지 (100 - a_i) % b_i는 별도로 한 번 누적된다.<br/>
마지막으로 높은 점수부터 내림차순으로 시험 개수 x 24개를 선택해 누적하면 된다.<br/>
그래서 시간복잡도는 O(N + 100) = O(N)이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/23254