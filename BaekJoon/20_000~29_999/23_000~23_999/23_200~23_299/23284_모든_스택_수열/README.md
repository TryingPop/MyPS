# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 자료 구조
  - 브루트포스
  - 백트래킹
  - 스택

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다.<br/>
1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. n이 주어졌을 때, 만들 수 있는 모든 스택 수열을 구해보자.<br/>


## 입력
첫째 줄에 정수 n이 주어진다.<br/>


## 출력
나올 수 있는 모든 스택 수열을 한 줄에 하나씩 사전 순으로 출력한다.<br/>


## 제한
  - 1 ≤ n ≤ 10


## 예제 입력
3<br/>


## 예제 출력
1 2 3<br/>
1 3 2<br/>
2 1 3<br/>
2 3 1<br/>
3 2 1<br/>


## 풀이
스택으로 만들 수 있는 수열은 1부터 n까지의 숫자를 정확히 한 번씩 사용하여 생성된 수열이다.<br/>
즉, 가능한 수열의 총 개수는 n!보다 작다.<br/>


n의 최대값은 10이므로, n! ≤ 10! = 3_628_800이다.<br/>
따라서 가능한 모든 스택 수열을 생성하여 저장하고 정렬하는 방식도 시간 내에 충분히 수행 가능하다.<br/>


또한 각 수열에 대해 정렬을 수행할 경우, 전체 시간 복잡도는 n! x n + n! x log n! ≤ 10! x 10 + 10! log (10!) < 40_000_000 + 90_000_000 = 130_000_000정도로 제한 시간 2초 안에 문제없이 동작할 수 있다.<br/>


스택 수열은 DFS 방식으로 생성하였다.<br/>
현재 스택 상태와 결과 배열을 매 재귀 깊이마다 복사하지 않고, 깊이 별로 배열과 스택을 관리하며 직접 값을 갱신하는 방식으로 구현해 성능을 개선했다.<br/>
이를 통해 불필요한 객체 생성을 줄였다.<br/>


DFS 탐색이 깊이 n에 도달했을 때, 아직 스택에 값이 남아 있다면, 스택의 모든 값을 순차적으로 꺼내어 결과 수열에 추가한다.<br/>
이후 이 수열을 리스트에 저장하고, 모든 수열 생성이 끝난 뒤 정렬하여 출력했다.<br/>


실제로 n = 10인 경우 만들어보니 16_796개 밖에 없다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/23284