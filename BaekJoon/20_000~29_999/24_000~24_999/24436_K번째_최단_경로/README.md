# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 그래프 이론
  - 그래프 탐색
  - 너비 우선 탐색
  - 조합론

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
Bob와 Alice는 그래프에서 최단 경로를 찾는 게임을 즐겨한다.<br/>
동생 Bob은 아직 어려서 실수를 많이 하기 때문에 Alice는 Bob가 연습할 수 있도록 다음과 같은 문제를 제시했다.<br/>
먼저, 길이를 나타내는 정수 L을 정한 후, 0부터 10^L-1 까지의 총 10^L개의 양의 정수를 이용하여 아래 규칙에 따라 그래프를 만든다:<br/>

  - 노드: 0부터 10^L-1 까지의 각 정수는 그래프의 고유한 노드를 나타낸다. 이 때, 각 정수는 선행하는 0을 붙여 반드시 길이가 L이 되도록 만든다. 예를 들어 L = 2라면 00, 01, 02, ..., 98, 99로 총 100개의 노드를 만들게 된다.
  - 간선: 두 정점 (x, y) 사이에 간선이 있으려면 x와 y의 1의 자리, 10의 자리, ..., 10^L-1의 자리를 비교했을 때 딱 한 곳만 달라야 하고 그 차이가 정확히 1이 되어야 한다. 예를 들어 L = 2인 경우, 00과 01, 01과 11, 27과 37, 36과 46 사이에는 간선이 있고, 00과 02, 01과 10, 36과 47 혹은 46과 57사이에는 간선이 없다.

입력으로 L, K, x, y가 주어졌을 때 Bob을 도와 x와 y사이의 최단 경로 중 사전 순으로 K번째 최단 경로를 구해보자. 만약 x와 y사이의 최단 경로의 개수가 K보다 작다면 "NO"를 출력하도록 한다.<br/>


## 입력
첫 줄에 테스트 케이스의 수 T가 주어진다.<br/>
각 테스트 케이스의 입력은 한 줄에 L, K, x, y가 공백으로 구분되어 주어진다.<br/>


## 출력
각 테스트 케이스의 정답을 각 줄에 출력한다.<br/>
K번째 최단 경로가 존재하는 경우 해당 최단 경로를 출력하고, 그렇지 않은 경우 "NO"를 출력한다 (따옴표 제외).<br/>


## 제한
  - 1 ≤ T ≤ 15
  - 2 ≤ L ≤ 4
  - 1 ≤ K ≤ 10^18
  - 0 ≤ x, y < 10^L
  - x, y는 언제나 선행 0을 포함하여 길이가 L인 형태로 주어진다.


## 예제 입력
7<br/>
2 1 20 22<br/>
2 2 20 22<br/>
3 3 008 258<br/>
3 22 008 258<br/>
4 10 2022 3141<br/>
4 61 2022 3141<br/>
4 1000000000000000000 0000 9999<br/>

## 예제 출력
20 21 22<br/>
NO<br/>
008 018 028 038 048 148 248 258<br/>
NO<br/>
2022 2021 3021 3031 3041 3141<br/>
NO<br/>
0000 0001 0002 1002 1012 1022 1122 1123 1133 1143 1243 2243 3243 3244 4244 4254 4354 4364 5364 6364 6464 6474 6484 6584 6684 7684 7784 7785 7786 7787 7788 7888 7988 8988 8998 9998 9999<br/>


## 힌트
  - 예제 1-2: 20과 22사이의 최단 경로는 20 - 21 - 22 하나 뿐이다.
  - 예제 3-4: 008과 258사이의 최단 경로는 총 21개 존재한다.
  - 예제 5-6: 2022와 3141사이의 최단 경로는 총 60개 존재한다.


## 풀이
각 자리의 차가 해당 방향으로 이동해야 하는 횟수이다.<br/>
위 예제의 3 3 008 258로 가는 경우를 보자<br/>
백의 자리 +1로 2번, 십의 자리 +1로 5번 간다. 가능한 서로 다른 경우의 수는, 7! / (2! x 5!)가지가 있다.<br/>
천의자리로 a번, 백의 자리로 b번 십의자리로 c번, 일의 자리 d번, 인경우는 (a + b + c + d)! / (a! b! c! d!)이다.<br/>
이렇게 전체 경우의 수를 계산할 수 있다. 그래서 존재 유무를 확인할 수 있다.<br/>

그리고 현재 노드에서 다 찾는데 해당 노드로 갔을 때 이동한 경우의 수를 전부 알 수 있다.<br/>
사전순으로 k번째를 찾아야 하는데 이는 노드를 정렬해서 경우의 수로 확인하며 찾을 수 있다.<br/>
008에서 258로 가는 경우 3번째를 찾는다.<br/>
008에서 258로 가는 최단 경로의 다음 노드는 018, 108이다.<br/>
018에서 258로 가는 경우의 수는 (2 + 4)! / (2! 4!) = 15이다.<br/>
우리가 찾는 k번째는 3번째이므로 018의 방향으로 가야한다.<br/>
만약 k번째가 16이상이면 018은 갈 수 없는 노드가 된다.<br/>
108로 이동하고, 다음은 16 - 15가지 경우를 뺀 1번째 경우로 가야한다.<br/>
이렇게 진행하며 이동 경로를 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/24436