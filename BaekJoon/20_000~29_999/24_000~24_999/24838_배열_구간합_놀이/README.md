# C#

## 난이도 : 골드 4

## 알고리즘 분류
  - 수학
  - 그리디 알고리즘
  - 정렬
  - 누적합
  - 조합론

## 제한조건
  - 시간 제한 : 1.5초
  - 메모리 제한 : 512 MB

## 문제
Alice는 정수 배열을 이용한 구간합 놀이를 즐겨하는데, 아래와 같은 순서로 게임을 진행한다.<br/>

  - 먼저, 길이 n인 정수 배열 A를 만든다. A의 원소가 A[1], ..., A[n]이라 했을 때 이 n개의 값은 모두 달라야 한다.
  - 다음으로, 배열 A의 구간을 나타내는 m개의 정수 쌍 (x[1], y[1]), ..., (x[m], y[m])을 고른다. 이 때 1 ≤ x[i] ≤ y[i] ≤ n 을 만족해야한다.
  - 배열 A와 x, y를 이용하여 구간합 S(A, x, y)을 다음과 같이 정의한다: S(A, x, y) := ∑_{1 ≤ j ≤ m} ( ∑_{x[j] ≤ i ≤ y[j]} A[i] ) 
  - 이 게임의 목표는 배열 A의 원소를 임의로 재배열하여 S(A, x, y)값을 최대로 만드는 것이다. A의 원소가 n개이므로 총 n! 가지의 방법으로 A의 원소를 재배열할 수 있다.

예를 들어, n = 3, m = 2, A = [10, 100, 1000] 이고 x = [1, 2], y = [2, 2]라 하자. n = 3 이므로 A의 원소를 재배열하여 얻을 수 있는 배열은 총 여섯 종류가 있다. 원래의 배열 A와 구분하기 위해 이를 배열 B라 하자.<br/>

  - B = [10, 100, 1000] 일 때, S(B, x, y) = (10 + 100) + (100) = 210.
  - B = [10, 1000, 100] 일 때, S(B, x, y) = (10 + 1000) + (1000) = 2010.
  - B = [100, 10, 1000] 일 때, S(B, x, y) = (100 + 10) + (10) = 120.
  - B = [100, 1000, 10] 일 때, S(B, x, y) = (100 + 1000) + (1000) = 2100.
  - B = [1000, 10, 100] 일 때, S(B, x, y) = (1000 + 10) + (10) = 1020.
  - B = [1000, 100, 10] 일 때, S(B, x, y) = (1000 + 100) + (100) = 1200.

이 경우 S(A, x, y)의 최댓값은 2100이며, 네 번째 경우인 B = [100, 1000, 10]를 통해 얻을 수 있다.<br/>
다른 예로, n = 2, m = 1, A = [20, 22] 이고 x = [1], y = [2]라 하자. n = 2 이므로 A의 원소를 재배열하여 얻을 수 있는 배열은 총 두 종류가 있다. 원래의 배열 A와 구분하기 위해 이를 배열 B라 하자.<br/>

  - B = [20, 22] 일 때, S(B, x, y) = (20 + 22) = 42.
  - B = [22, 20] 일 때, S(B, x, y) = (22 + 20) = 42.

이 경우 S(A, x, y)의 최댓값은 42이며, 두 가지 다른 방법을 통해 얻을 수 있다.<br/>
A, x, y가 주어졌을 때 Alice가 A의 원소를 재배열하여 달성할 수 있는 S(A, x, y)의 최댓값을 구하고, 몇 가지 다른 방법으로 최댓값을 달성할 수 있는지 구해보자.<br/>


## 입력
첫 줄에 테스트 케이스의 수 T가 주어진다.<br/>
각 테스트 케이스의 입력 첫 줄에 n, m이 공백으로 구분되어 주어진다. 둘째 줄에는 배열 A의 원소 n개가 공백으로 구분되어 주어진다. 다음 m줄에 걸쳐 각 줄에 두 개의 정수 x[i]와 y[i]가 공백으로 구분되어 주어진다.<br/>


## 출력
각 테스트 케이스의 정답인 Alice가 달성할 수 있는 S(A, x, y)의 최댓값, 그리고 이를 달성할 수 있는 방법의 수를 공백으로 구분하여 출력한다. 단, 방법의 수가 매우 커질 수 있으므로 10^9+7로 나눈 나머지를 출력한다.


## 제한
  - 1 ≤ T ≤ 10
  - 1 ≤ n ≤ 50,000
  - 1 ≤ m ≤ 200,000
  - 1 ≤ A의 원소 ≤ 10^8
  - 배열 A의 원소는 고유하다.
  - 1 ≤ i ≤ m인 정수 i에 대하여 1 ≤ x[i] ≤ y[i] ≤ n

## 예제 입력
6<br/>
3 2<br/>
10 100 1000<br/>
1 2<br/>
2 2<br/>
2 1<br/>
20 22<br/>
1 2<br/>
5 3<br/>
1 3 5 7 9<br/>
1 2<br/>
2 3<br/>
3 4<br/>
6 1<br/>
1 2 3 100 200 300<br/>
1 2<br/>
7 7<br/>
100000000 99999999 99999998 99999997 99999996 99999995 99999994<br/>
1 7<br/>
2 7<br/>
3 7<br/>
4 7<br/>
5 7<br/>
6 7<br/>
7 7<br/>
13 1<br/>
1 2 3 4 5 6 7 8 9 10 11 12 13<br/>
1 13<br/>

## 예제 출력
2100 1<br/>
42 2<br/>
40 4<br/>
500 48<br/>
2799999944 1<br/>
91 227020758<br/>


## 풀이
대소관계의 추이성과 큰수에 큰수를 곱하는게 가장 큰수로 간다.<br/>
최대합은 가장 많이 사용되는 원소들에 최대값을 부여하면 최대가 된다.<br/>
그래서 원소의 사용횟수를 기록하고 많이 사용되는 원소에 큰 수를 부여하면 최대합을 찾을 수 있다.<br/>
최대 합의 경우의 수는 갯수에 몇 개의 원소가 포함되어 있는 수만큼 존재한다.<br/>
모든 수가 다르므로 팩토리얼개씩 곱해가면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/24838