# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 자료 구조
  - 정렬
  - 스위핑
  - 분리 집합

## 제한조건
  - 시간 제한 : 2.5초
  - 메모리 제한 : 1024 MB

## 문제
우주 정거장은 한 개의 선분으로 구성되어 있으며, 좌표 평면상에 N개의 우주 정거장이 있다. 각 우주 정거장은 1번부터 N번까지 번호가 붙어 있다.<br/>
비행선은 무조건 우주 정거장에서만 출발할 수 있으며 이동하면서 만나는 우주 정거장에서만 멈출 수 있다. 경계도 우주 정거장에 포함된다. 비행선이 움직이는 방법은 3가지다.<br/>

  - x축과 평행한 방향으로 이동.
  - y축과 평행한 방향으로 이동.
  - 우주 정거장 내에서 이동.


서로 다른 두 정거장이 주어졌을 때, 두 정거장 사이를 오갈 수 있는지에 대해서 알아보자.<br/>


## 입력
첫 번째 줄에는 우주 정거장 개수 N과 질문의 개수 Q가 주어진다. (2 ≤ N ≤ 200,000, 1 ≤ Q ≤ 200,000)<br/>
다음 N개의 줄에는 i번 우주 정거장의 양 끝점을 나타내는 x_i1, y_i1, x_i2, y_i2가 주어진다. 모든 좌표의 절댓값은 10^9 이하의 정수값이다.<br/>
다음 Q개의 줄에 서로 다른 우주 정거장의 번호 두 개가 주어진다.<br/>


## 출력
Q개의 줄을 출력한다. 각 줄에는 주어진 순서대로 질문에 대한 대답이 출력되어야 한다. 질문에 주어진 두 정거장 사이를 오갈 수 있는 경우 대답은 1, 그렇지 않은 경우 대답은 0이다.<br/>


## 예제 입력
3 3<br/>
5 5 1 1<br/>
4 7 6 7<br/>
7 2 9 0<br/>
1 2<br/>
1 3<br/>
2 3<br/>


## 예제 출력
1<br/>
1<br/>
1<br/>


## 풀이
두 정거장이 이어진 경우를 이동할 수 있는 경우라 하자.<br/>
그러면 모든 정거장에 유니온 파인드 알고리즘으로 이어진 상태를 관리하면 각 쿼리는 O(1)에 찾을 수 있다.<br/>
그래서 유니온 파인드로 이어주면 된다.<br/>


먼저 두 정거장이 이어진 경우를 보자.<br/>
이동 방향은 우주 정거장 내부나 x축과 평행하게 y축과 평행하게 이동 뿐이다.<br/>
정거장은 하나의 직선으로 표현이 가능하다.<br/>
그래서 두 직선을 이용해 이어진 경우를 확인한 결과 다음 두 가지 뿐이었다.<br/>

  - 두 직선의 x좌표 범위가 겹치는 점이 있을 때, y축과 평행한 이동으로 이어줄 수 있다.
  - 두 직선의 y좌표 범위가 겹치는 점이 있을 때, x축과 평행한 이동으로 이어줄 수 있다.


그래서 x 좌표 범위가 겹치는지 y 좌표 범위가 겹치는지 확인한다.<br/>
x 좌표의 값과 y 좌표의 값은 독립적이므로 x 좌표로 그룹을 짓고, y 좌표로 그룹을 지어 확인해주면 된다.<br/>
여기서 y 좌표로 그룹 짓고 x 좌표로 그룹지어도 상관없다. 여기서는 x 좌표부터 먼저 그룹지었다.<br/>


x 좌표 범위의 겹치는 것은 스위핑 방법을 이용해 찾았다.<br/>
x 좌표 범위의 시작지점으로 오름차순 정렬한다.<br/>


정렬된 경우 다음과 같이 찾는다.<br/>
끝지점 end을 첫 항의 끝지점으로 한다.<br/>
그리고 그룹 curIdx 역시 첫 항의 그룹으로 한다.<br/>


이제 정렬된 배열의 원소를 하나씩 확인한다.<br/>
현재 원소의 시작지점이 end보다 작거나 같은 경우 이어진 상태를 뜻한다.<br/>
그래서 curIdx와 현재 원소의 기존 인덱스를 같은 그룹으로 유니온 한다.<br/>
그리고 끝지점 end를 현재 끝지점과 비교해서 큰 값으로 갱신한다.<br/>


반면 현재 원소의 시작지점이 끝지점 end 보다 큰 경우 이어지지 않음을 뜻한다.<br/>
그러면 end를 현재 원소의 끝 지점으로 갱신하고, 그룹인 curIdx를 현재 원소의 기존 인덱스로 갱신한다.<br/>
이렇게 모든 원소를 조사하면 y축과 평행하게 이동해서 그룹을 이어주는 것과 같다.<br/>


다음 y 좌표도 x좌표로 이어진 그룹을 통해 x좌표와 같이 그룹을 짓는다.<br/>
이렇게 모든 좌표를 이어진 경우를 유니온 파인드로 찾아 group 배열에 저장했다.<br/>
f, t로 이루어진 쿼리에 대해 파인드 한 f 값과 파인드한 t 값을 비교해 같으면 1, 다르면 0으로 정답을 찾았다.<br/>


쿼리의 경우 O(1)에 해결되므로 Q ≤ 20만이므로 크게 신경쓸 필요 없다.<br/>
이제 그룹 짓는 경우를 보면 x 좌표, y 좌표로 각각 정렬한다.<br/>
그래서 N log N 연산을 2번한다.<br/>


그리고 유니온 파인드 알고리즘으로 O(a(N))인데, 여기서 a(N)은 아커만 함수다.<br/>
N ≤ 20만이므로 a(N) ≒ 1으로 봐도 무방하다.<br/>
정렬된 경우의 조사는 O(N)의 시간이 걸린다.<br/>


그래서 전체 시간 복잡도는 O(N log N + Q)로 유효한 방법이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20930