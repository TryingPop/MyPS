# C#

## 난이도 : 골드 3

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
타고난 농사꾼 비니는 최근 숫자 공부에 푹 빠졌다. 열심히 숫자 공부를 하던 비니는 놀라 자빠질 수밖에 없었다. 숫자 7이 비니가 가장 아끼는 낫과 비슷하게 생겼기 때문이다. 옛말에 낫 놓고 7자도 모른다고 하였다. 문득 비니는 수를 구성하는 모든 숫자의 합과 곱이 7의 배수인 수가 몇 개인지 궁금해졌다. 비니는 답을 구하기 위하여 열심히 농사를 짓기로 결심하였다.<br/>
N이 주어졌을 때, N자리 양의 정수 중 수를 구성하는 모든 숫자의 합과 곱이 7의 배수인 수의 개수를 구하는 프로그램을 작성하시오. 수는 0으로 시작할 수 없다.<br/>


## 입력
첫 번째 줄에 테스트 케이스의 수 T가 주어진다.<br/>
이후 T개의 줄에 걸쳐 정수 N이 한 줄에 하나씩 주어진다.<br/>


## 출력
각 테스트 케이스에 대한 답을 한 줄에 하나씩 출력한다. 답이 매우 커질 수 있으므로 10^9 + 7로 나눈 나머지를 출력한다.<br/>


## 제한
  - 1 ≤ T ≤ 10,000
  - 1 ≤ N ≤ 10,000


## 예제 입력
4<br/>
1<br/>
2<br/>
3<br/>
4<br/>


## 예제 출력
1<br/>
2<br/>
54<br/>
692<br/>


## 힌트
2자리 수 중 조건을 만족하는 수는 70과 77이 있다.<br/>
4자리 수 중 조건을 만족하는 수는 2237 등이 있다. 2237의 경우 숫자들의 합은 2+2+3+7=14, 숫자들의 곱은 2×2×3×7=84이며, 14와 84는 모두 7의 배수이다.<br/>


## 풀이
각 자리수의 합이랑 곱이 각각 7의 배수여야 한다.<br/>
곱의 기준으로 보면 7은 소수이므로 자릿수 중에 0또는 7이 있어야지만 7의 배수가 된다.<br/>


그래서 n 자릿수 중에 0 또는 7이 있는 7의 배수인 경우를 mul 배열에 관리했다.<br/>
7의 배수가 아닌 것은 not 배열에 관리했다.<br/>


그리고 합의 경우 나머지의 합이 0, 1, 2, 3, 4, 5, 6 인지 알아야 한다.<br/>
그래서 각 mul과 not의 인덱스를 나머지의 합으로 관리했다.<br/>


그리고 각 자릿수 중 맨 앞이 0인 경우는 카운팅하면 안된다.<br/>
이를 zero에 배열에 따로 관리했다.<br/>
zero에는 0이 있으므로 곱은 항상 7의 배수이다.<br/>


그래서 zero[i]는 가장 큰 단위의 값이 0이고 각 자릿수의 합을 7로 나눈 나머지가 i인 자리가 n인 수들의 갯수이다.<br/>
mul[i]는 가장 큰 단위의 값이 0이 아니고 각 자릿수의 곱이 7로 나눈 나머지가 0이고 각 자릿수의 합을 7로 나눈 나머지가 i인 자리가 n인 수들의 갯수이다.<br/>
not[i]는 가장 큰 단위의 값이 0이 아니고 각 자릿수 곱이 7로 나눈 나머지가 0이 아니고 각 자릿수 합을 7로 나눈 나머지가 i인 자리가 n인 수들의 갯수이다.<br/>
이렇게 설정하면 자릿수 n인 수들이 분할된다.<br/>


이제 n자리에서 n + 1자리가 만들어지는 것을 보면 앞에 0, 1, 2, ..., 9를 붙이면 된다.<br/>


zero, mul, not의 다음항은 서로가 연관을 준다.<br/>
nextZero, nextMul, nextNot을 동시에 찾아 임시 보관한다음 동시에 값을 넣는다.<br/>


그러면 다음과 같은 점화식을 얻는다.<br/>
각 자리의 앞에 0을 이어붙여 n + 1자리로 만든다.<br/>
그러면 0을 더했으므로 7로 나눈 나머지는 이상이 없고 nextZero[i] = zero[i] + mul[i] + not[i]를 얻는다.<br/>


이제 앞에 7을 이어붙이는 경우 모두 7의 배수가 되고 앞이 0이 아니다.<br/>
그러면 각 자릿수의 곱이 7의 배수이던 아니던 7이 추가로 포함되었으므로 7의 배수가 되고 7이 추가되어 7로 나눈 나머지는 그대로이다.<br/>
그래서 nextMul[i] = zero[i] + mul[i] + not[i]를 얻는다.<br/>


이제 나머지 1, 2, 3, 4, 5, 6, 8, 9를 앞에 붙이는 경우에 한해서는 다음 점화식을 얻는다.<br/>
not의 경우 각자리는 7의 배수가 하나도 포함 안되어 있다. 1, 2, 3, 4, 5, 6, 8, 9도 7의 배수가 아니므로 이어 붙여도 not에 포함되어야 한다.<br/>
j = 1, 2, 3, 4, 5, 6, 8, 9에 대해 nextNot[(i + j) % 7] += not[i]를 얻는다.<br/>


mul의 경우도 각 자리에 7이 적어도 하나 포함되어 있고 1, 2, 3, 4, 5, 6, 8, 9를 포함한다고 해서 7이 그대로 포함되어 있으므로 mul에 포함되어야 한다.<br/>
j = 1, 2, 3, 4, 5, 6, 8, 9에 대해 nextMul[(i + j) % 7] += mul[i]를 얻는다.<br/>


두 경우 모두 i = 0, 1, 2, 3, 4, 5, 6이다.<br/>


이렇게 mul, not, zero를 채워간다.<br/>
그러면 mul[0]이 합이 7의 배수이고, 곱이 7의 배수이므로 우리가 찾는 값이 된다.<br/>


각 자리 별로 이전 자리를 이용하면 O(N * 49)의 시간이 걸린다.<br/>
이렇게 각 n자리에 값을 dp[n]에 채워가면서 찾았다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20957