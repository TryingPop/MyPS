# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 트리
  - 트리에서의 다이나믹 프로그래밍

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
준원이(0/5/3)는 생존해있는 카이사(2/7/0)를 찾으러 소환사의 협곡을 수색하고 있다. 협곡은 정점이 N개 있는 트리 모양이고, 정점은 1번 정점에서 N번 정점까지 번호 붙여져 있다. 준원이는 모든 정점 쌍 x, y에 대해 x번 정점과 y번 정점의 LCA를 방문해보고, 방문한 정점의 번호들을 모두 배열에 적어두었다. 여러 번 방문하면 여러 번 적었다.<br/>
하지만, 카이사는 없었다.<br/>
준원이는 탈주하고, 이 배열을 정렬한 뒤, 배열의 짝수번째 원소들의 합과 홀수번째 원소들의 합을 구하려 한다.<br/>
참가자 - 생존<br/>
참가자 - 생존<br/>


## 입력
첫째 줄에는 트리의 정점의 개수 N이 주어진다.<br/>
둘째 줄에는, 1번부터 N번까지 각 정점의 부모 정점의 번호를 나타내는 N개의 정수가 차례대로 주어진다. 루트 정점은 부모가 없으므로, 루트 정점의 차례에는 0이 주어진다.<br/>


## 출력
준원이가 정렬한 배열의 짝수번째 원소들의 합과 홀수번째 원소들의 합을 차례대로 공백을 사이에 두고 출력한다. 출력하는 수가 32비트 정수 자료형의 범위를 넘을 수 있다는 점에 유의하라.<br/>


## 제한
  - 1 ≤ N ≤ 200,000


## 예제 입력
5<br/>
0 1 1 2 2<br/>


## 예제 출력
19 22<br/>


## 풀이
LCA가 되는 정렬된 수열의 길이는 N^2이고 N 이 20만까지 오므로 int 범위를 벗어난다.<br/>
그래서 갯수를 이용해 확인하자. 1번 노드를 LCA로 하는 노드의 갯수가 몇 개 있는지 말이다.<br/>


그러면 1번 노드부터 방문 횟수를 확인하면 된다. 이제부터 방문 횟수를 갯수라 한다.<br/>
만약 1번 노드부터 확인하는데 갯수가 짝수인 경우 (노드 번호) x (갯수의 절반)을 각각 홀수와 짝수에 누적하면 된다.<br/>
반면 갯수가 홀수인 경우 (노드 번호) x └(개수 / 2)┘를 홀수와 짝수에 누적한다.<br/>
그리고 처음에 홀수인 경우 홀수이므로 홀수에 노드 번호를 1번 누적한다.<br/>
여기서 └N┘은 N을 넘지 않는 가장 큰 정수이다.<br/>


이제 2번 노드를 확인하는데 갯수가 짝수인 경우 홀수와 짝수에 (노드 번호) x (갯수의 절반)을 각각 홀수와 짝수에 누적한다.<br/>
반면 갯수가 홀수인 경우 홀수와 짝수에 각각 (노드 번호) x └(개수 / 2)┘를 누적한다.<br/>
앞에서 홀수로 끝난경우면 이번에는 짝수에 노드 번호를 누적하고 앞에서 짝수로 끝났다면 홀수에 노드 번호를 누적한다.<br/>
이렇게 N번까지 누적해가면 된다.<br/>


이제 LCA로 각 노드 A의 방문 횟수를 찾아줘야 한다.<br/>
A를 루트로하는 서브 트리의 노드가 아닌 비교 대상이 있을 때 LCA는 A가 될 수 없다.<br/>
그래서 A의 서브 트리 노드에 한해서만 비교하면 된다.<br/>


먼저 A와 A의 서브트리 노드안에 있는 모든 원소들은 LCA로 A를 갖음을 알 수 있다.<br/>
그래서 A의 자식의 수가 기본적으로 더해진다.<br/>


이외는 A의 자식 중 아무거나 하나를 B라 하자.<br/>
K를 루트로하는 서브트리의 원소의 수를 |K|라 하자.<br/>
그러면 B를 루트로하는 서브 트리와 B서브트리에는 포함되지 않지만 A서브트리에 포함되는 노드와 LCA를 하면 A가 됨을 알 수 있다.<br/>
그래서 LCA가 A인 노드 쌍의 갯수는 |A| + ∑|B| x (|A| - |B|)임을 알 수 있다.<br/>
이를 DFS로 구현했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20506