# C#

## 난이도 : 골드 2

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 이분 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 512 MB

## 문제
문자열 A가 문자열 B의 줄임말이라는 것은 B의 순서를 바꾸지 않고 0 또는 그 이상 개수의 문자를 지워 A를 만들 수 있다는 뜻이다. 정의에 의해서 B는 자기 자신의 줄임말임에 유의하라. 예를 들어, ac, ab, aa, aabc는 aabc의 줄임말이고, d, aaa, ba는 aabc의 줄임말이 아니다.<br/>
영문 알파벳 소문자로만 이루어진 두 문자열 S와 T가 주어진다. T를 자연수 n번 반복해서 이어쓴 문자열을 T n이라고 하자. S가 T n의 줄임말이 되는 최소의 n을 구하라.<br/>
예를 들어, T = ac, S = caa라고 하면, T1 = T = ac, T2 = acac, T3 = acacac이고 n = 3일 때 처음으로 S가 Tn의 줄임말이 된다.<br/>


## 입력
첫째 줄에 문자열 S가 주어진다.<br/>
둘째 줄에 문자열 T가 주어진다.<br/>


## 출력
S가 Tn의 줄임말이 되는 최소의 n을 출력한다. 단, 어떤 n에 대해서도 Tn이 S의 줄임말이 되지 못할 때에는, -1을 출력한다.<br/>


## 제한
  - S와 T는 영문 알파벳 소문자(‘a’ - ‘z’)만으로 이루어진 문자열이다.
  - S의 길이는 1 이상 1 000 000 이하이다.
  - T의 길이는 1 이상 100 000 이하이다.


## 예제 입력
caa<br/>
ac<br/>


## 예제 출력
3<br/>


## 풀이
먼저 불가능한 경우를 찾아본다.<br/>
이는 S에 포함된 알파벳 중 T에 포함되지 않는 알파벳이 포함되는 경우다.<br/>


예를 들어 s = cab이고, t = acca인 경우 s에는 b가 포함되어 있지만 t에는 b가 포함되어있지 않다.<br/>
그래서 t를 얼마나 이어붙이던 b를 찾을 수 없으므로 존재하지 않는다.<br/>


이외의 경우는 t를 s의 길이만큼 이어붙이는 경우 언제나 부분수열이 존재함을 알 수 있다.<br/>
이제 최소 갯수를 찾아야 한다.<br/>
이는 그리디로 찾았다.<br/>


부분 수열이 존재한다면 가장 앞선 애들을 선택하면서 부분수열을 만들어 나갈 경우 해당 부분수열을 포함하는 가장 작은 갯수는 가장 적게 이어붙인 갯수가 될 것이다.<br/>
그래서 앞에서부터 가능한 선택해야 한다.<br/>


이를 찾기 위해 이분 탐색을 이용할 것이다.<br/>
그래서 알파벳 alphabet에 대해 T[i] = alphabet인 경우 dp[alphabet]에 i의 값을 오름차순으로 담는다.<Br/>
그리고 아래 연산을 위해 dp[alphabet]의 마지막에 i들 중 가장 큰값중 하나를 넣는다. T의 길이값을 넣었다.<br/>


이제 S[i]의 값을 조사하는데 이전 위치를 prev라 하자.<br/>
그러면 dp[S[i]]에서 prev 초과인 가장 작은 값 j를 찾는다.<br/>
j가 만약 T의 길이값이라면 뒷쪽에는 없음을 뜻하고 맨 처음 원소를 가져와야 한다.<br/>
이는 이어 붙이는 경우고 이전 위치를 이번에 선택한 위치로 한다.<br/>


반면 j가 T의 길이값이 아닌 dp[S[i]]의 값이라면 해당 값으로 위치를 옮긴다.<br/>
마지막으로 j가 존재하지 않는다면 이는 S에 포함안된다는 뜻이고 불가능한 경우다.<br/>


이렇게 S[i]의 값을 앞에서부터 하나씩 조사해가면서 가장 적게 이어붙인 길이를 제출했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20191