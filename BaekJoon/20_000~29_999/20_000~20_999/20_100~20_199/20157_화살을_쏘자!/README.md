# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 자료 구조
  - 기하학
  - 해시를 사용한 집합과 맵
  - 집합과 맵

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
호준이는 요즘 활 쏘기에 푹 빠져 있다. 열심히 활 쏘기를 연습하던 호준이는 쏠 때 마다 10점이 나오는 경지에 이르렀다. 이렇다 보니 한 방향으로 있는 과녁에 쏘는 것에 실증을 느낀 호준이는 새로운 방식의 활 쏘기를 시도해 보기로 하였다.<br/>
화살이 꽂힌 위치에 따라 점수를 얻는 기존의 방식과 다르게 2차원의 넓은 공터에 풍선을 (x, y)지점에 설치해 두고 지정된 위치 (0, 0) 에서 원하는 방향으로 화살을 쏜다. 화살은 진행 방향으로 무한히 뻗어 나갈 수 있으며, 이 화살이 날아가며 터트린 풍선의 수만큼 점수를 얻기로 했다. 풍선 한 개당 점수는 1점으로 동일하고 같은 위치에 2개 이상의 풍선을 둘 수 없다. 또한 호준이가 서있는 (0, 0)에도 풍선을 둘 수 없다.<br/>
호준이는 신중하게 방향을 설정해 한발을 쐈고, 자신이 선택하여 쏜 방향이 최선의 방향인지 궁금해진 호준이는 화살 하나로 얻을 수 있는 최대 점수가 궁금해졌다. 활쏘기 연습하느라 바쁜 호준이를 대신해서 풍선의 위치가 주어진다면 화살 한 개를 쏘아 얻을 수 있는 가장 높은 점수를 알려주자.<br/>


## 입력
첫번째 줄에 풍선의 개수 정수 N(1 ≤ N  ≤ 100,000)이 주어진다.<br/>
다음 N개의 줄에는 풍선의 위치인 두 정수 x, y (-1,000,000 ≤ x, y ≤ 1,000,000)가 주어진다.<br/>


## 출력
첫번째 줄에 화살 한 개를 쏘아 얻을 수 있는 최대 점수를 구해 출력한다.<br/>


## 예제 입력
5<br/>
8 16<br/>
10 -3<br/>
2 4<br/>
7 10<br/>
1 2<br/>


## 예제 출력
3<br/>


## 풀이
(0, 0)에서 화살을 한 발 쏘아 가장 많은 풍선을 터뜨릴 수 있는 수를 구하는 문제다.<br/>
화살은 (a, b) 방향으로 쏘며, 이때 k > 0인 실수 k에 대해 (ka, kb)에 있는 풍선이 터진다.<br/>
즉, 방향이 같은 좌표에 있는 풍선은 모두 같은 화살로 처리할 수 있다.<br/>


정수 좌표 (x, y)에 풍선이 있을 때, 이 좌표와 같은 방향의 벡터를 정규화해서 Dictionary에 방향별 풍선 수를 세면 된다.<br/>


이를 위해 (x, y)를 가장 작은 정수 단위 벡터로 변환해야 한다.<br/>
(x, y) ≠ (0, 0)일 때, gcd(|x|, |y|)를 g라 하면, (x/g, y/g)가 해당 방향의 최소 정수 벡터다.<br/>


단, 정규화를 할 때 방향을 고정하기 위해 다음과 같이 부호를 정리한다:<br/>

  - y < 0 이면 x와 y 모두 부호를 반전<br/>
  - y == 0이고 x < 0 이면 x 부호만 반전<br/>


즉, 항상 위쪽 또는 오른쪽 방향으로 향하게끔 기준을 고정한다.<br/>
이렇게 정규화한 (a, b)에 대해 Dictionary<(a, b), int>에 값을 누적한다.<br/>


(0, 0)에 풍선이 있는 경우는 문제에서 명시적으로 주어지지 않는 한 제외한다.<br/>


또한 실수 단위벡터로 방향을 정규화하는 방법도 있을 수 있지만, 이 경우:<br/>

  - 실수 오차로 인해 방향 중복 체크가 불안정해질 수 있고<br/>
  - double 또는 float의 근사 표현 오차가 생겨 Dictionary 키 비교가 애매해질 수 있다.<br/>


따라서 정수 기반 정규화 + 부호 고정 방식이 정확하고 효율적인 접근이다.<br/>


입력 개수 N ≤ 100,000, 좌표 범위 M ≤ 1,000,000 이다.<br/>
각 경우 gcd 연산으로 log M의 연산을 하며, N개에 대해 진행한다.<br/>
시간 복잡도는 O(N log M)이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20157