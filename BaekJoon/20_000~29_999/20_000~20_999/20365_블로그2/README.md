# C#

## 난이도 : 실버 3

## 알고리즘 분류
  - 그리디 알고리즘
  - 문자열

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
neighbor 블로그를 운영하는 일우는 매일 아침 풀고 싶은 문제를 미리 정해놓고 글을 올린다. 그리고 매일 밤 각각의 문제에 대하여, 해결한 경우 파란색, 해결하지 못한 경우 빨간색으로 칠한다. 일우는 각 문제를 칠할 때 아래와 같은 과정을 한 번의 작업으로 수행한다.<br/>

  1. 연속된 임의의 문제들을 선택한다.
  2. 선택된 문제들을 전부 원하는 같은 색으로 칠한다.

예를 들어, 각 문제를 위와 같은 색으로 칠하려고 할 때, 1~2번 문제를 파란색, 3번을 빨간색, 4번을 파란색, 5번을 빨간색, 6~7번을 파란색, 8번을 빨간색으로 칠하는 작업을 순서대로 수행하면 6번의 작업을 거쳐야 한다. 하지만, 1~7번 문제를 파란색, 3번을 빨간색, 5번을 빨간색, 8번을 빨간색으로 순서대로 칠한다면 작업 횟수는 4번으로 가장 적다.<br/>
일우는 매일 500,000문제까지 시도하기 때문에, 이 작업이 꽤나 귀찮아지기 시작했다. 그래서 가장 효율적인 방법으로 위 작업을 수행하기를 원한다. 일우를 도와 각 문제를 주어진 색으로 칠할 때 필요한 최소한의 작업 횟수를 구하는 프로그램을 작성하라.<br/>

## 입력
첫째 줄에 색을 칠해야 하는 문제의 수 N (1 ≤ N ≤ 500,000)이 주어진다.<br/>
둘째 줄에 N개의 문자가 공백 없이 순서대로 주어진다. 각 문자는 i번째 문제를 어떤 색으로 칠해야 하는지를 의미하며, R은 빨간색, B는 파란색을 나타낸다. 그 외에 다른 문자는 주어지지 않는다.<br/>

## 출력
첫째 줄에 일우가 주어진 모든 문제를 원하는 색으로 칠할 때까지 필요한 작업 횟수의 최솟값을 출력하라.<br/>

## 예제 입력
8<br/>
BBRBRBBR<br/>

## 예제 출력
4<br/>

## 풀이
구간을 연속된 색 블록으로 문자열을 나눴다고 가정하자.<br/>
그러면 구간이 많은걸 먼저 칠하고 이후에 부분 구간들을 칠하는게 최소 경우라 추론했다.<br/>
그래서 구간을 세고 전체 구간의 값을 반으로 나눈 뒤 + 1 하면 추론하는 값과 같아짐을 얻었다.<br/>
그래서 문자열을 하나씩 읽으면 구간을 찾고 구간의 개수로 정답을 구했다.<br/>

## 문제 링크
https://www.acmicpc.net/problem/20365