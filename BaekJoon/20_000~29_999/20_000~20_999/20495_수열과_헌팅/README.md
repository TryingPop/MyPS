# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 정렬
  - 이분 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
준원이는 여자친구를 만들 시나리오를 진지하게 세우고 있다.<br/>
먼저, 지나가던 아름다운 여성 분이 준원이에게 길이가 N인 수열 arr을 정렬해달라고 부탁한다. 그리고 준원이는 #include <algorithm>을 선언한 뒤 std::sort(arr, arr+N);을 사용해 시간복잡도 O(N log N)으로 멋지게 정렬해준다. 그리고, 사랑에 빠진다.<br/>
준원이는 실제로 이 상황에 마주친다. 하지만 그가 받은 수열은... 수열의 원소가 정해져 있지 않았다!<br/>
314 ± 25, 255 ± 140, ...<br/>
실제 수열의 각 원소는 받은 수열의 오차범위 내의 어떤 실수든 될 수 있다. 예를 들어, 첫번째 수인 314 ± 25는 314 - 25 = 289 이상 314 + 25 = 339 이하의 임의의 실수가 될 수 있다.<br/>
그녀는 길이 N의 수열 a1 ± b1, ..., aN ± bN을 준원이에게 주고, 수열을 정렬한 이후 각각의 수가 몇 번째에 가 있을지를 알고 싶다. 물론, 수열이 범위 안에서 어느 수로 결정되는가에 따라 답이 바뀔 수 있기 때문에, 각각의 수가 있을 수 있는 인덱스의 범위를 구하고 싶다. 만약 같은 수가 여러 개 있다면, 그 수들은 어떤 순서로 있든 무관하다. 준원이가 연애를 할 수 있도록, 여러분이 대신 그녀의 문제를 해결해 주자.<br/>


## 입력
첫째 줄에는 준원이가 받은 수열의 길이 N이 주어진다.<br/>
둘째 줄부터 N개의 줄에 걸쳐 준원이가 받은 수열이 주어진다. i번째 줄에는 준원이가 받은 수열의 i번째 원소 ai ± bi를 나타내는 두 정수 ai와 bi가 공백을 사이에 두고 주어진다.<br/>


## 출력
총 N개의 줄에 걸쳐서 출력한다. i번째 줄에는 수열을 정렬한 후, 수열의 i번째 원소가 있을 수 있는 인덱스의 최솟값과 최댓값을 공백을 사이에 두고 출력한다.<br/>
수열의 인덱스는 1부터 시작한다.<br/>


## 제한
  - 2 ≤ N ≤ 500,000
  - 각 1 ≤ i ≤ N에 대해, ai, bi는 정수이고, -10^9 ≤ ai ≤ 10^9, 0 ≤ bi ≤ 10^9.


## 예제 입력
3<br/>
10 20<br/>
40 15<br/>
70 15<br/>


## 예제 출력
1 2<br/>
1 3<br/>
2 3<br/>


## 힌트
예제에서, 수열의 수들을 차례로 x1, x2, x3이라 하자. -10 ≤ x1 ≤ 30, 25 ≤ x2 ≤ 55, 55 ≤ x3 ≤ 85이다. 만약 (x1, x2, x3) = (28, 25, 70)이라면, x2가 첫번째, x1이 두번째, x3이 세 번째 수가 된다. 또, (x1, x2, x3) = (15, 55, 55)라면 x1이 첫번째 수이고, x2, x3은 차례대로 두번째, 세번째 수이거나 차례대로 세번째, 두번째 수가 된다. 이밖의 어떤 경우에도, x1은 1, 2번째 수이고, x2는 1, 2, 3번째 수이고, x3은 2, 3번째 수이다.<br/>


## 풀이
i번째 숫자가 가장 왼쪽에 가는 경우를 생각해본다.<br/>
i번을 제외한 숫자들을 가장 큰 수로 해서 정렬한다.<br/>
그리고 i번째의 숫자의 최솟값보다 작은 숫자들의 갯수가 정렬 했을 때 해당 i번째의 가장 왼쪽에 있는 위치가 된다.<br/>
그래서 최댓값 경우의 숫자들을 모두 모아놓고 집합을 정렬한다.<br/>


i번째를 탐색하는데 i번째가 있어도 된다.<br/>
작은 것들만 세기 때문에 최댓값은 카운팅 안되기 때문이다.<br/>
그러면 정렬된 집합이므로 이분 탐색으로 자기보다 작은 숫자의 갯수를 찾고 해당 위치 + 1이 가장 왼쪽에 있는 지점이 된다.<br/>


이와 비슷하게 가장 오른쪽에 있는 것은 최소로해서 정렬한 뒤 자기 자신은 최대로 해서 이분 탐색으로 작거나 같은 원소들의 갯수가 있는 위치가 된다.<br/>
이 때 자기자신을 무조건 카운팅하므로 +1을 할 필요가 없다.<br/>
다만 구현한 이분 탐색은 갯수가 아닌 유효 인덱스 범위이므로 +1을 해준다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20495