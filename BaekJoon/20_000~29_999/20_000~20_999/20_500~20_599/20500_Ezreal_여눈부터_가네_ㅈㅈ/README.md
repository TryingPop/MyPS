# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 정수론

## 제한조건
  - 시간 제한 : 1.515초
  - 메모리 제한 : 1515 MB

## 문제
욱제는 15라는 수를 굉장히 싫어한다. 그래서 0으로 시작하지 않고 1과 5로만 구성된 N자리 양의 정수 중에서, 15의 배수가 몇 개인지 궁금해졌다.<br/>
참가자 여러분도 궁금하지요?<br/>
안 궁금함? 15ㄱ<br/>


## 입력
N이 주어진다.<br/>


## 출력
문제의 답을 1,000,000,007로 나눈 나머지를 출력한다.<br/>


## 제한
  - 1 ≤ N ≤ 1,515


## 예제 입력
1515<br/>


## 예제 출력
939178250<br/>


## 요약
  - 목표: 1과 5로만 이루어진 N자리 자연수 중 15의 배수 개수

  - 조건:
    - 끝자리는 반드시 5 (1, 5만 사용 가능이므로 0 불가능 → 일의 자리가 5만 가능)
    - 자리수 합 % 3 == 0 (3의 배수 조건)

  - 정의:
    - dp[i][j][k] = i자리 수, 끝자리 j(0:1, 1:5), 자리수합%3==k일 때 경우의 수

  - 초기값:
    - dp[1][0][1] = 1 (1)
    - dp[1][1][2] = 1 (5)

  - 점화식:
    - dp[i+1][0][(k+1)%3] += dp[i][j][k] (1 추가)
    - dp[i+1][1][(k+5)%3] += dp[i][j][k] (5 추가)

  - 최적화:
    - j=1만 필요 (끝자리 5만 유효)
    - 1차원 dp 가능 → cur[k]만 유지

  - 정답: cur[0]
  - 시간복잡도: O(N)


## 풀이
1과 5로만 구성된 N자리 자연수 중에서, 15의 배수의 개수를 찾아야 한다.<br/>


먼저 1과 5로만 구성된 N자리 자연수의 모든 경우의 수를 찾는 방법이다.<br/>
0으로 시작하지 않고 1, 5로만 구성된 i자리 자연수를 모두 알고 있다고하자.<br/>
가장 왼쪽(즉, 상위 자리)에 1 또는 5를 추가해 0으로 시작하지 않고 1, 5로만 구성된 i + 1자리 서로 다른 자연수를 모두 찾을 수 있다.<br/>

  - 예를들어 a = 11이라 하면 10^2자리에 1을 추가해 111, 5를 추가해 511을 만들 수 있다.

그리고 이렇게 만들어지는 수는 모두 다르다.<br/>
예를들어 1, 5로만 이루어진 i자리 자연수 a ≠ b가 존재한다고 가정하자.<br/>
그러면 적당한 10^j 자리에서 a, b의 값이 다르다.<br/>
앞에 1 또는 5를 추가해도 10^j 자리에 있는 수가 다르므로 같을 수 없다.<br/>
그래서 만들어지는 i + 1번째 자리수는 모두 다른게 보장된다.<br/>


  - 예를들어 a = 15, b = 11이라 하면 a와 b의 10^0 자리(일의 자리) 값이 1 ≠ 5로 다르다. 앞에 10^2자리에 a, b에 1, 5를 추가해도 a는 115, 515이고 b는 111, 511이고 여전히 일의 자리 숫자는 1 ≠ 5 다르다.


다음으로 15의 배수를 찾는 방법이다.<br/>
15의 배수는 3과 5의 배수인 것과 같다.<br/>
10진법에서 3, 5 배수 판별은 아래와 같다.<br/>

  - 3의 배수 : 각 자리수의 합이 3으로 나누어 떨어지는 경우
    - 114 : 1 + 1 + 4 = 6이고, 6 % 3 = 0이므로 114는 3의 배수이다.

  - 5의 배수 : 일의 자리의 수가 0 또는 5
    - 1234124 : 일의 자리 숫자가 4이고 0 또는 5가 아니므로 5의 배수가 아니다.


여기서 1과 5로만 이루어져 있으므로 일의 자리는 5이고, 각 자리수의 합이 3으로 나누어떨어지는 개수를 찾아야 한다.<br/>


해당 조건으로 dp 방법이 유효하다 생각했다.<br/>
dp[i][j][k] = val를 다음과 같이 정의 했다.<br/>

  - i : 현재 자리수
  - j : 10^0 자리(일의 자리) 수
    - j = 0 : 일의 자리 수가 1
    - j = 1 : 일의 자리 수가 5

  - k를 각자리수의 합을 3으로 나눈 나머지
  - val : 경우의 수


각 자리에 1과 5를 붙이며 i + 1 자리의 경우의 수를 찾을 수 있다.<br/>
가장 큰 자리에 1을 추가하면 각자리 수 합은 1이 증가한다. 그리고 일의 자리는 변경되지 않는다.<br/>
마찬가지로 가장 큰 자리에 5를 추가하면 각 자리수의 합은 5 증가하고 일의 자리는 변경되지 않는다.<br/>
그래서 다음과 같은 점화식을 얻는다.<br/>

  - 가장 큰 자리에 1을 추가하는 경우 : dp[i + 1][j][(k + 1) % 3] += dp[i][j][k]
  - 가장 큰 자리에 5를 추가하는 경우 : dp[i + 1][j][(k + 5) % 3] += dp[i][j][k]


dp 정의에 따라 초기 1자리 값은 dp[1][0][1] = 1, dp[1][1][2] = 1로 해주고 나머지는 0으로 한 뒤 for문을 이용해 해당 점화식을 채워갔다.<br/>


1과 5로만 구성된 N자리 자연수 중에서, 15의 배수의 개수는 10^0 자리가 5이어야 하고 각 자리수의 합이 3으로 나누어 떨어져야 한다.<br/>
그래서 dp[N][1][0]의 값과 일치한다.<br/>


dp[i][j][k] 의 모두 채우기만 하면 정답을 찾을 수 있으므로 시간 복잡도는 dp 배열의 크기와 같다.<br/>
dp 배열의 크기는 (가능한 i의 개수) x (가능한 j의 개수) x (가능한 k의 개수)= (N + 1) x 2 x 3이다.<br/>
그래서 시간 복잡도는 O(6N + 6) = O(N)이다.<br/>


dp의 점화식을 보면 바로 앞 자리만 다음 자리에 영향을 준다.<br/>
그래서 모든 자리를 저장할 필요가 없다.<br/>


dp[i][j][k]를 현재 자리를 나타내는 cur[j][k]를 만들고 다음 자리를 나타내는 배열 next[j][k]를 만들면 된다.<br/>

  - cur : cur[j][k] = dp[i][j][k]
  - next  : next[j][k] = dp[i + 1][j][k]


이렇게 푸는 경우 사용하는 메모리를 많이 줄일 수 있다.<br/>
그리고 찾을 값은 끝이 5이므로 j = 0 인경우를 저장할 필요가 없다.<br/>


cur, next 배열을 1차원 배열로 줄일 수 있고 다음과 같은 의미로 정의하면 된다.<br/>

  - cur : cur[k] = dp[i][1][k]
  - next : next[k] = dp[i + 1][1][k]

로 정의한다. 그리고 N자리까지 진행한다. 그러면 우리가 찾는 값은 cur[0]이 정답이 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/20500