# C#

## 난이도 : 실버 1

## 알고리즘 분류
  - 수학
  - 그리디 알고리즘
  - 이분 탐색

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
3023년 PPC가 성공적으로 종료되었다! 대회 운영자인 포닉스는 대회에 참가한 모든 사람에게 상품을 하나씩 나눠주려고 한다. 하지만 너무 많은 사람이 대회에 참가해서 구매해야 할 상품 수량을 도저히 정리할 수 없었다!<br/>
포닉스는 상품을 구매하기 위한 자금 X와, 구매할 수 있는 M개의 상품이 적힌 리스트를 가지고 있다. 리스트에 적힌 각 상품의 가격은 각각 a_1, a_2, ..., a_M이다. 포닉스는 등수가 높은 참가자들에게 더 비싼 가격의 상품을 주기 위해 다음의 규칙으로 각 상품의 수량을 결정하려고 한다.<br/>

  - 먼저, 1등을 한 참가자의 상품은 남은 N-1명의 참가자들 모두의 상품을 구매할 수 있는 한도 내에서 가능한 비싼 상품으로 결정한다.
  - 다음으로, 2등을 한 참가자의 상품은 남은 N-2명의 참가자들 모두의 상품을 구매할 수 있는 한도 내에서 가능한 비싼 상품으로 결정한다.
  - 같은 방식으로, i등을 한 참가자의 상품은 남은 N-i명의 참가자들 모두의 상품을 구매할 수 있는 한도 내에서 가능한 비싼 상품으로 결정한다.

포닉스를 위해 포닉스가 각 상품을 몇 개나 구매해야 하는지 구해 주자!<br/>


## 입력
첫 번째 줄에 참가자 수 N, 상품 목록의 개수 M, 그리고 자금을 나타내는 정수 X가 공백으로 구분되어 주어진다. (1 ≤ N ≤ 10^12; 1 ≤ M ≤ 10^6; 1 ≤ X ≤ 10^18)<br/>
두 번째 줄에 각 상품의 가격을 나타내는 M개의 정수 a_1, a_2, ..., a_M가 공백으로 구분되어 주어진다. (10^6 ≥ a_1 > a_2 > ... > a_M ≥ 1)<br/>
X ≥ N x a_M이 성립한다.<br/>


## 출력
각 상품에 대해 필요한 개수를 공백으로 구분해 순서대로 출력한다.<br/>


## 예제 입력
10 3 20<br/>
3 2 1<br/>


## 예제 출력
5 0 5<br/>


## 힌트
1등부터 5등까지는 가장 비싼 1번째 상품을 구매하여도 5의 자금이 남는다. 따라서 5등까지는 1번째 상품을 고르게 된다.<br/>
반면 6등이 1번째 상품을 고르면 2의 자금이 남고, 2번째 상품을 고르면 3의 자금이 남으므로 남은 4명의 참가자들의 상품을 모두 살 만큼의 상금이 남지 않는다. 따라서 6등부터는 3번째 상품을 고르게 된다.<br/>


## 풀이
각 i번 사람이 구매하는 경우를 확인해 규칙성을 찾았다.<br/>


먼저 i = 1인 경우 2, 3, 4, ..., N번이 물건을 a_M번 물건을 샀고, 남은 돈으로 살 수 있는 것 중 가장 비싼것을 사는 것이다.<br/>
그래서 (N - 1) x a_M을 뺀 남은 가격에서 가장 비싼 물건을 사는 것이다. 산 물건을 b_1이라 하자.<br/>

i = 2인 경우는 3, 4, 5, ..., N번이 a_M번 물건을 샀고 1번은 b_1을 샀다.<br/>
그래서 남은 돈 중 가장 비싼 것 b_2를 산다.<br/>


a_1 > a_2 > ... > a_M이므로 남은 돈 중 가장 비싼 것은 이분 탐색으로 찾을 수 있다.<br/>
이 경우 N log M의 시간이 걸린다.<br/>
N이 10^12로 해당 방법은 시간 초과가 자명하다.<br/>


해당 방법을 보면 k번 사람이 사는 물건의 각격을 b_k라 할 때 i < j인 경우 b_i ≥ b_j를 알 수 있다.<br/>
또한 a_1 > a_2 > ... > a_M이므로 가장 비싼 물건부터 최대한 사야함을 알 수 있다.<br/>
그래서 물건에 대해 최대한 사는 것을 확인했다.<br/>


각 a_i에 대해 남은 인원을 n_i, 남은 돈을 m_i라 하자.<br/>
사는 인원을 c라 하면 (a_i x c) + (a_M x (n_i - c)) ≤ m_i가 되는 c의 최댓값을 찾아야 한다.<br/>
a_i ≥ a_M이므로 c가 커지면 (a_i x c_i) + (a_M x (n_i - c_i))커짐을 확인할 수 있다.<br/>
즉, 정렬된 집합으로 볼 수 있다.<br/>


이분 탐색으로 (a_i x c) + (a_M x (n_i - c)) ≤ m_i가 되는 c의 최댓값 c_i을 찾았다.<br/>
그리고 남은 인원은 n_(i+1) = n_i - c_i이고, m_(i+1) = m_i - c_i x a_i가 된다.<br/>
이렇게 각 물건에대해 최대 갯수를 찾아가면, M log N으로 유효한 방법이라 판단했다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/28103