# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 구현
  - 자료 구조
  - 많은 조건 분기
  - 덱

## 제한조건
  - 시간 제한 : 0.5초
  - 메모리 제한 : 1024 MB

## 문제
처음에 왼쪽이 큐의 뒤, 오른쪽이 큐의 앞인 가로 방향의 빈 큐가 존재한다. 이 큐에서 공이나 가림막을 하나씩 큐의 뒤에 삽입하거나, 큐의 가장 앞에 있는 공이나 가림막을 꺼낼 수 있으며, 큐를 시계방향이나 반시계방향으로 90도 회전시킬 수 있다.<br/>
큐 안의 가림막은 중력의 영향을 받지 않지만, 큐 안의 공은 중력의 영향을 받는다. 따라서 큐를 세로 방향으로 회전시켰을 때, 큐의 가장 아래에 있는 가림막보다 아래에 있는 공들은 모두 떨어져 큐에서 꺼내지게 된다.<br/>
또한, 큐가 세로 방향이면 공을 새로 넣더라도 넣은 공 아래에 가림막이 존재하지 않는 경우 곧바로 큐에서 꺼내지게 된다.<br/>
Q개의 쿼리가 주어질 때, 처음 빈 상태의 큐에 주어진 쿼리들을 순서대로 수행하는 프로그램을 작성하시오.<br/>


## 입력
첫 번째 줄에 쿼리의 개수 Q가 주어진다.<br/>
두 번째 줄부터 Q개의 줄에 걸쳐 첫 번째 쿼리부터 순서대로 각 쿼리의 정보가 순서대로 주어진다.<br/>

  - push b: 큐의 뒤에 공 하나를 삽입한다.
  - push w: 큐의 뒤에 가림막 하나를 삽입한다.
  - pop: 큐에서 가장 앞쪽에 있는 공이나 가림막을 하나 꺼낸다. 큐가 빈 상태면 아무 일도 일어나지 않는다.
  - rotate l: 큐를 반시계 방향으로 90도 회전시킨다.
  - rotate r: 큐를 시계 방향으로 90도 회전시킨다.
  - count b: 현재 큐에 들어있는 공의 개수를 출력한다.
  - count w: 현재 큐에 들어있는 가림막의 개수를 출력한다.


## 출력
count b 쿼리와 count w 쿼리의 정답을 한 줄에 하나씩 순서대로 출력한다.<br/>


## 제한
  - 1 ≤ Q ≤ 500,000
  - 마지막 쿼리는 count b 이다.


## 예제 입력
9<br/>
push b<br/>
push w<br/>
push b<br/>
push b<br/>
count b<br/>
count w<br/>
pop<br/>
rotate r<br/>
count b<br/>


## 예제 출력
3<br/>
1<br/>
2<br/>


## 풀이
쿼리당 중력 큐에 추가할 수 있는 갯수는 많아야 1개이다.<br/>
그래서 중력 큐의 크기는 쿼리의 갯수만큼 잡으면 해당 범위 안에서는 이상없이 작동한다.<br/>
쿼리의 최대 갯수는 50만이므로 50만 배열로 관리가 가능하다.<br/>


중력 큐의 회전의 상태에 의해 중력 큐는 맨 앞에서부터 가림막이 나올 때까지 공이 계속해서 빠질 수 있다.<br/>
마찬가지로 회전 상태에 의해 중력 큐는 맨 뒤에서부터 가림막이 나올 때까지 공이 계속해서 빠질 수 있다.<br/>
이외의 중앙의 값을 빼는 것은 불가능하다.<br/>


중력 큐를 앞과 뒤의 원소를 넣고 뺄 수 있는 덱(Deque) 자료구조를 응용한 형태로 구현한다.<br/>
그리고 값이 빠지는 것은 중력 큐의 크기를 넘지 않고, 이는 다시 들어가지 않는다.<br/>
그래서 쿼리의 갯수 Q라 하면 시뮬레이션 돌려도 2Q를 넘지 않으므로 시뮬레이션 방법이 유효하다.<br/>


시뮬레이션 돌리기 위해 각 쿼리별 함수를 만들었다.<br/>

  - push : 뒤에 원소를 넣는 덱의 함수를 이용하면 된다.
  - pop : 앞의 원소를 빼는 덱의 함수를 이용하면 된다.
  - count : b와 w의 갯수를 관리하는 변수를 할당한 뒤 원소를 넣을 때와 빠질 때 어떤 종류가 빠졌는지 확인해서 관리했다.
  - rotate의 경우인데, 이는 회전 상태를 다루는 변수를 할당 했다. 그리고 입력과 출력이 끝나면 회전 상태에 맞춰 앞 있는 공들을 빼거나 뒤에 있는 공들을 계속해서 빼줬다.<br/>


각 쿼리당 처리 시간은 O(1)이며, rotate 이후 공을 최대 Q번 제거할 수 있지만, 전체적으로 모든 공은 한 번만 삽입되고 최대 한 번만 제거되므로 총 연산 수는 O(2Q) = O(Q)에 수렴한다.<br/>
그리고 사용하는 메모리는 Q에 가까워진다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/28078