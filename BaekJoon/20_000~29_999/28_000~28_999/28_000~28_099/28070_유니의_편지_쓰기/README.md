# C#

## 난이도 : 골드 5

## 알고리즘 분류
  - 문자열
  - 누적 합
  - 스위핑
  - 파싱

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
남중 남고를 나온 유니는 주변에 군인인 친구들이 많다. 그런 유니는 군대에 있는 친구들에게 편지를 써 주려 한다.<br/>
하지만 편지를 써 줄 친구들이 많아 귀찮은 유니는 오직 한 달 동안만 편지를 쓰기로 한다.<br/>
한 달 동안만 편지를 쓰면 군대 안에서 편지를 받지 못하는 친구들도 있으므로, 가장 많은 친구가 군대에 있는 한 달을 찾으려 한다.<br/>
머리가 좋지 않아 그 한 달이 언제인지 모르는 유니를 위해 언제 편지를 써야 하는지 구해주자.<br/>


## 입력
첫 번째 줄에 군대에 가는 유니의 친구 수 N이 주어진다.(1 ≤ N ≤ 100,000)<br/>
두 번째 줄부터 N개의 줄에는 유니의 친구의 입대 시기와 전역 시기가 YYYY-MM 형식으로 주어진다.<br/>
YYYY는 연도를 뜻하며 2000 이상 9999 이하의 정수를 나타낸다.<br/>
MM는 월을 뜻하며 1 이상 12 이하의 정수로 한 자리 수는 앞에 0을 붙여 나타낸다.<br/>
단, 입대 월과 전역 월에는 유니의 친구가 군대에 있으며, 전역 월은 입대 월보다 항상 같거나 더 뒤이다.<br/>


## 출력
유니가 편지를 써야 할 시기를 YYYY-MM 형식으로 출력한다. 편지를 써야 할 시기가 여러 개일 경우, 가장 앞선 시기를 출력한다.<br/>


## 예제 입력
4<br/>
2023-02 2023-04<br/>
2023-03 2025-03<br/>
2023-04 2025-02<br/>
2024-02 2026-02<br/>


## 예제 출력
2023-04<br/>


## 풀이
기간별로 군대에 있는 인원을 기록해야 한다.<br/>
그럴러면 먼저 년도와 월을 숫자로 바꿔야 한다.<br/>
1년당 12월을 곱해 표현할 수 있지만 여기서는 2차원 배열을 이용해 단순히 구분해서 사용했다.<br/>
년도는 2000부터 시작하므로 2000을 빼는 연산을 취하고 월은 1월부터 시작이므로 1을 빼는 연산을 취했다.<br/>


그래서 dp[i, j] = val는 i는 i + 2000년이고, j는 j + 1 월을 나타낸다. 그리고 val는 군대에 있는 인원을 나타낸다.<br/>
그리고 전역 월은 해당 달까지 군대에 있다고 봐야한다.<br/>
만약 매번 1월씩 올려가며 전역월까지 1을 추가한다고하면 최악의 경우 한 명당 8000년하고 12월 즉 9만이 넘는 배열에 1을 추가해야할 것이다.<br/>
인원은 10만명까지 들어오므로 10만 x 9만 = 90억 연산을하고 시간초과날 것이다.<br/>


다만 누적 합 아이디어를 이용하면 10만 + 8000 x 12 < 20만 연산 이내에 해결 가능하다.<br/>
입대하는 달에 + 1을, 전역하는 다음 달에 -1을 누적해 간다.<br/>
그리고 모든 인원에 대해 확인을 다했다면 이제 시작지점 2000년 2월부터 1달씩 늘려가며 누적한다.<br/>
즉 j > 1인 경우 dp[i, j] += dp[i, j - 1], j == 0인 경우 dp[i, 0] += dp[i - 1, 11]이다.<br/>
이렇게 10000년 1월까지 누적해가면 우리가 얻는 결과와 같다.<br/>
입력은 9999년 12월까지 들어오지만, 전역하는 달까지 군대에 있다고 봐야하기에 + 1달을 더 해줘야 한다.<br/>


이제 만들어진 dp배열을 다시 처음부터 읽어가면서 가장 많은 인원이 군대에 있는 지점을 찾으면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/28070