# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 다이나믹 프로그래밍
  - 그래프 이론
  - 정렬
  - 정수론
  - 조합론
  - 분할 정복을 이용한 거듭제곱
  - 페르마 소정리

## 제한조건
  - 시간 제한 : 2초
  - 메모리 제한 : 1024 MB

## 문제
Albert와 Bob은 "과자 줍기" 보드 게임을 즐겨한다.<br/>
이 게임은 크기가 R x C 인 격자 보드를 사용하여 진행하는데, 먼저 Bob이 N개의 칸을 골라 과자를 올려둔다. 단, 각 칸에는 최대 1개의 과자만 올려둘 수 있고 좌측상단 (1, 1) 혹은 우측하단 (R, C)에는 과자를 올려둘 수 없다. 이후 Albert는 게임 말을 (1, 1)칸에 올려둔 후 우측 혹은 아래로만 이동하여 (R, C) 칸에 도달하여야 하고 이동한 경로를 따라 최대한 많은 과자를 주워야 한다. 예를 들어 아래 그림의 경우 R = 3, C = 5 그리고 N = 3인 경우를 나타낸다. 편의상 과자의 위치는 크기가 N인 두 배열 X, Y로 행/열을 나타내기로 하며 아래 예제의 경우 X = [1, 1, 2] 그리고 Y = [3, 4, 3]이 된다.<br/>

||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|S||[1]|[2]||
|2|||[3]|||
|3|||||E|

S로 표시된 (1, 1) 에서 출발하여 E로 표시된 (3, 5) 칸으로 가는 방법은 여럿 존재하는데, 아래 그림과 같은 방법으로 (1, 1) → (2, 1) → (2, 2) → (2, 3) → (2, 4) → (3, 4) → (3, 5) 로 이동한다면 1개의 과자만 줍게 된다.<br/>


||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅||[1]|[2]||
|2|✅|✅|✅|✅||
|3||||✅|✅|


하지만 아래와 같이 여섯 가지 다른 방법으로 총 2개의 과자를 주울 수도 있다.<br/>

||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅|✅|✅|[2]||
|2|||✅|||
|3|||✅|✅|✅|


||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅|✅|✅|[2]||
|2|||✅|✅||
|3||||✅|✅|


||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅|✅|✅|[2]||
|2|||✅|✅|✅|
|3|||||✅|


||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅|✅|✅|✅||
|2|||[3]|✅||
|3||||✅|✅|


||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅|✅|✅|✅||
|2|||[3]|✅|✅|
|3|||||✅|


||1|2|3|4|5|
|:---:|:---:|:---:|:---:|:---:|:---:|
|1|✅|✅|✅|✅|✅|
|2|||[3]||✅|
|3|||||✅|


이 예제에서 과자를 3개 주우면서 S칸에서 E칸으로 도달하는 방법은 없다.<br/>
Albert는 입력으로 주어진 보드에서 최대한 많은 과자를 줍는 서로 다른 방법의 수가 몇 가지나 되는지 궁금해졌다 - Albert를 도와 이 값을 구해보자. 위 예제의 정답은 6이다.<br/>


## 입력
입력 첫 줄에 테스트 케이스의 수 T가 주어진다.<br/>
각 테스트 케이스의 첫 줄에는 R, C, N 값이 공백으로 구분되어 주어진다. 다음 N줄에 걸쳐 각 줄에 i번째 과자가 놓인 칸의 행 위치 (X_i)와 열 위치 (Y_i) 가 공백으로 구분되어 주어진다.<br/>


## 출력
각 테스트 케이스에서 시작 칸 (1, 1)에서 도착 칸 (R, C)까지 이동하며 최대한 많은 과자를 줍는 방법의 수를 각 줄에 출력한다. 단, 이 수가 매우 클 수 있으므로 1000003으로 나눈 나머지를 출력한다.<br/>


## 제한
  - 1 ≤ T ≤ 20
  - 1 ≤ R, C ≤ 10^6
  - 1 ≤ N ≤ 100
  - 1 ≤ i ≤ N인 i에 대하여:
    - 1 ≤ X_i ≤ R
    - 1 ≤ Y_i ≤ C
    - (X_i, Y_i) ≠ (1, 1)
    - (X_i, Y_i) ≠ (R, C)
  - 1 ≤ i, j ≤ N인 i ≠ j에 대하여: (X_i, Y_i) ≠ (X_j, Y_j)


## 예제 입력
4<br/>
3 5 3<br/>
1 3<br/>
1 4<br/>
2 3<br/>
3 5 2<br/>
2 2<br/>
3 3<br/>
4 4 1<br/>
1 4<br/>
4 4 2<br/>
4 1<br/>
2 4<br/>


## 예제 출력
6<br/>
4<br/>
1<br/>
5<br/>


## 풀이
과자에 초점을 맞춰 문제에 적힌 예제를 살펴보자.<br/>
가장 많이 먹는 경로에 포함된 과자만 고려하여, 각 경로에서 이동 가능한 경우의 수를 누적해가면 된다.<br/>
이를 위해 두 점 사이를 이동하는 경우의 수를 알아야 한다.<br/>


(a, b)에서 오른쪽(→), 아래쪽(↓)으로만 이동해 (c, d)로 가는 경우의 수를 구하자.<br/>
여기서 a ≤ c, b ≤ d라고 가정하고, right = d - b, down = c - a라고 하자.<br/>


이동 경로의 수는 (right + down)! / (right! × down!)이 된다.<br/>
이는 → 방향 right번, ↓ 방향 down번을 나열하는 조합의 수와 같다.<br/>


이 값을 1_000_003으로 나눈 나머지를 구해야 한다.<br/>
에라토스테네스의 체를 이용해 1_000_003이 소수임을 확인할 수 있고, 따라서 페르마의 소정리에 의해 (right!)^-1 ≡ (right!)^(1_000_003 - 2) mod 1_000_003이 성립한다.<br/>
이를 바탕으로 분할 정복을 이용한 거듭제곱을 통해 O(log 1_000_003)에 역수를 구할 수 있다.<br/>
down!에 대해서도 같은 방식으로 역수를 구한다.<br/>


결과적으로, 두 점 사이를 →, ↓ 방향으로만 이동하는 경우의 수는 O(log MOD)에 구할 수 있다.<br/>


이제 가장 많은 과자를 먹는 경우에 해당하는 지점들을 찾아야 한다.<br/>
과자의 개수가 100 이하이므로, 벨만-포드의 코드 아이디어를 빌려 O(N^3)에 계산할 수 있다.<br/>


구체적으로는, 각 과자가 놓인 i 지점에 대해 cnt[i]에 해당 위치까지 먹은 과자의 최대 개수를 저장한다.<br/>
그리고 i에서 →, ↓ 방향으로 이동 가능한 j에 대해, cnt[j] = max(cnt[j], cnt[i] + 1)을 수행한다.<br/>
cnt[i] + 1은 i에서까지의 최댓값에 j 위치의 과자를 먹는 것을 포함한 결과다.<br/>
이 과정을 과자의 개수만큼 반복하면, 모든 위치에서의 최대 과자 수를 계산할 수 있다.<br/>
역추적 연산의 편의를 위해 도착지에도 과자를 하나 놓는 것으로 가정한다.<br/>


다음으로 경우의 수를 구하자.<br/>
이를 위해 ret[i]를 i 위치에서의 경로 수로 정의하고, 도착지 e에 대해 ret[e] = 1로 초기화한다.<br/>
도착지에는 과자가 가장 많이 놓이는 것이 자명하므로, 이 값을 시작점으로 삼는다.<br/>


이제 다음과 같은 방식으로 시작점까지 역추적하며 경우의 수를 누적한다.<br/>


먼저, c = cnt[e]라고 하자.<br/>
cnt[dst] = c인 지점 dst에 대해, 모든 과자 위치 src를 확인한다.<br/>
cnt[src] = cnt[dst] - 1이고, src에서 →, ↓ 방향으로 이동해 dst에 도달할 수 있는 경우, ret[src] += ret[dst] × (src → dst 경로 수)를 수행한다.<br/>


이 연산을 cnt = c인 모든 지점에 대해 수행한 뒤, c를 1 줄여가며 반복한다.<br/>
c = 0이 되면 시작점에 도달한 것이며, 이때의 ret[start]가 정답이다.<br/>


이러한 역추적 과정은 일반적으로 O(N^3)이지만, BFS를 활용하면 O(N^2)까지도 줄일 수 있다.<br/>


이와 같이 과자를 가장 많이 먹는 경로의 경우의 수를 효율적으로 계산할 수 있다.<br/>
전체 시간 복잡도는 O(T × N^3 × log MOD)이며, 여기서 T는 테스트 케이스 수, N은 과자 위치의 개수, MOD는 나눌 소수이다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/28309