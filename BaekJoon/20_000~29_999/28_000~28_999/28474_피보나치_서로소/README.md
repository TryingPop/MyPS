# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 수학
  - 정수론
  - 오일러 함수

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
피보나치 수열은 F_n = F_{n-1} + F_{n-2} (n > 2), F_1 = F_2 = 1을 만족하는 수열이다. F_n을 n번째 피보나치 수라고 한다.<br/>
또한 어떤 두 자연수 a, b가 서로소일 조건은 gcd(a,b)=1과 같다. (gcd는 최대공약수를 뜻한다.)<br/>
승은이는 피보나치 수를 매우 좋아한다. 피보나치 수를 너무 좋아한 나머지 자신의 주변 사람들에게도 피보나치 수의 아름다움을 알리려 노력한다.<br/>
그런 승은이의 뻔선 이주도 예외는 아니었다. 학교에 다니면서 승은이와 매일 마주쳐야 하는 이주는 승은이의 설교를 더 이상 들을 수 없었다.<br/>
승은이의 설교를 피하기 위해 조사를 하던 중 승은이의 약점을 하나 알아냈다. 그것은 바로 승은이가 서로소인 숫자 쌍을 보면 기겁을 하며 피한다는 것이었다.<br/>
이주는 이 사실을 알자마자 아무 서로소인 숫자 쌍을 가지고 학교에 달려가 승은이에게 보여줬지만 피보나치 수만 취급하던 승은이에게는 별 타격이 없었다.<br/>
이 사실에 낙담한 이주를 위해서 우리가 서로소인 피보나치 수의 쌍을 찾아주고자 한다. 하지만 모든 쌍을 찾기에는 무리가 있기에 1번째부터 n-1번째까지 피보나치 수 중에서 n번째 피보나치 수와 서로소인 것이 몇 개 있는지 세어주려고 한다.<br/>
이주가 승은이의 설교를 피할 수 있도록 도와주자.<br/>


## 입력
첫 줄에 테스트 케이스의 수 T가 주어진다. (1 ≤ T ≤ 1,000)<br/>
그 다음 줄마다 n번째 피보나치 수를 뜻하는 n이 주어진다. (1 ≤ n ≤ 1,000,000,000)<br/>


## 출력
T개의 줄마다 각각 n번째 피보나치 수와 서로소인 i(<n)번째 피보나치 수의 개수를 출력해라.<br/>


## 예제 입력
4<br/>
1<br/>
2<br/>
3<br/>
1000000000<br/>


## 예제 출력
0<br/>
1<br/>
2<br/>
600000000<br/>


## 풀이
gcd(F(n), F(m)) = F(gcd(n, m))을 이용하면 된다.<br/>
그리고 gcd(i, j) = 1일 때 서로 소라고 정의했다.<br/>


그래서 이 사실을 이용하면 F(gcd(n, m)) = 1인 m의 갯수를 세어주면 된다.<br/>
F(1) = F(2) = 1이므로 gcd(n, m) = 1인 경우와 gcd(n, m) = 2인 값들을 모두 찾아야 한다.<br/>


먼저 gcd(n, m) = 1인 경우 찾는 법을 보자<br/>
i와 j < i이면서 i와 서로소인 갯수를 오일러 피함수 φ(i)라고 정수론 시간에 정의했다.<br/>


그리고 서로 소인 p, q에 대해 φ(pq) = φ(p) * φ(q)가 성립한다.<br/>
그리고 소수 p에 대해 φ(p^k) = p^(k - 1) * (p - 1)이 된다.<br/>


이 사실을 이용해 φ(n)을 소인수분해해서 구하면 된다.<br/>
소인수 분해에서는 소수로 계속해서 나눠간다.<br/>
케이스가 많을거 같아 소수를 알아두면 좋을거 같아 제곱해서 10억 미만인 소수들을 모두 에라토스테네스 체로 먼저 찾았다.<br/>
이제 i에 대해 i 이하인 소수를 나눠 가면서 φ의 값을 찾아갔다.<br/>
그래서 gcd(n, m) = 1인 경우를 모두 찾는다.<br/>


이제 gcd(n, m) = 2인 경우를 찾아보자.<br/>
n이 홀수면 gcd(n, m) = 2가 될 수 없으므로 0개임이 자명하다.<br/>


이제 n이 짝수인 경우를 보자.<br/>
p, q가 서로 소 인 경우 gcd(cp, cq)와 gcd(p, q)의 해집합 원소의 갯수가 같다.<br/>
그래서 이를 이용하면 gcd(n, m) = 2인 경우, gcd(n / 2, m / 2) = 1인 m / 2의 갯수를 세어주면 된다.<br/>


마지막으로 이 둘을 더하면 정답이 된다.<br/>
더해도 되는 이유는 다음과 같다.<br/>
gcd(n, m) = 1인 수들의 집합을 X, gcd(n, m) = 2인 수들의 집합을 Y라 하자.<br/>
만약 n이 홀수인 경우 gcd(n, m) = 2는 불가능하다.<br/>
그래서 Y는 공집합이 된다. 이 경우 X, Y는 교집합이 공집합이다.<br/>


이제 n이 짝수인 경우를 보자.<br/>
이 때 X에는 짝수가 들어올 수 없다.<br/>
그래서 X는 홀수의 부분집합이 된다.<br/>
반면 Y는 2로 나눠떨어져야 하기에 짝수 집합이 된다.<br/>
자연수는 홀수와 짝수로 분할되므로 역시 X, Y는 교집합이 공집합이다.<br/>


이에 gcd(n, m) = 1인 경우 + gcd(n, m) = 2인 경우의 수를 더해주면 된다.<br/>



## 증명
F(n)을 피보나치 n번째 피보나치 수라 하자.<br/>
F(n + 2) = F(n + 1) + F(n)이 성립하고, F(1) = F(2) = 1이다.<br/>
gcd(F(n), F(m)) = F(gcd(n, m))임을 보이자.<br/>


#### 보조 정리 1
피보나치 점화식과 1, 2항이 1인 것을 이용하면 다음과 같은 식을 얻는다.<br/>

F(n) = F(n - 1) + F(n - 2) = F(2) * F(n - 1) + F(1) * F(n - 2)<br/>
= 2 * F(n - 2) + 1 * F(n - 3) = F(3) * F(n - 2) + F(2) * F(n - 3)<br/> 
= ... = F(k + 1) * F(n - k) + F(k) * F(n - k - 1)를 얻는다.<br/>


#### 보조정리 2
gcd(n, m)을 n, m의 최대공약수라 하자.<br/>
유클리드 호제법으로 gcd(a + b, a) = gcd(b, a)가 성립한다.<br/>


#### 보조정리 3
gcd(a + b, a) = gcd(b, a)[보조 정리 2](#보조정리-2)라는 사실과 피보나치 점화식으로 다음을 얻는다.<br/>
gcd(F(n), F(n + 1)) = gcd(F(n), F(n) + F(n - 1)) = gcd(F(n), F(n - 1)) = ... = gcd(F(2), F(1)) = 1<br/>
즉 gcd(F(n), F(n + 1)) = 1이다.<br/>


#### 보조정리 4
gcd(a, b) = 1일 때, gcd(a, bc) = gcd(a, c)이다.<br/>
gcd(a, bc) = d라할 때, d는 a와 bc의 공약수이므로 a = kd이고, bc = ld가 되는 k, l이 존재한다.<br/>
그런데 d가 b를 나누는 경우 gcd(a, b) = 1이므로 모순이된다.<br/>
그래서 그래서 d는 c를 나눠야 한다.<br/>
d가 c를 나누고 a를 나누므로 d가 gcd(a, c)를 나눠서 d ≤ gcd(a, c)임은 자명하다.<br/>
그런데 gcd(a, c)는 a를 나누는건 자명하다. 그리고 bc를 나눠야 한다.<br/>
그래서 gcd(a, c) ≤ gcd(a, bc) = d이므로 gcd(a, c) = d가된다.<br/>


#### 보조정리 5
[보조정리 4](#보조정리-4)로 F(nk) 는 F(n)으로 나눠떨어짐을 보일 수 있다.<br/>
k = 1일 때는 자명하다.<br/>
k > 2인 경우를 보자.<br/>
[보조정리 1](#보조정리-1)으로 다음을 얻는다.<br/>
gcd(F(nk), F(n)) = gcd(F(n + 1) * F(nk - n) + F(n) * F(nk - n - 1), F(n))<br/>
gcd(a + b, a) = gcd(a, b)이므로([보조정리 2](#보조정리-2))<br/>
gcd(F(nk), F(n)) = gcd(F(n + 1) * F(nk - n), F(n))<br/>
그리고 gcd(F(n), F(n + 1)) = 1[보조정리 3](#보조정리-3)이고 gcd(a, b) = 1이면 gcd(a, bc) = gcd(a, c)[보조정리 4](#보조정리-4)이므로<br/>
gcd(F(nk), F(n)) = gcd(F(nk - n), F(n))이 된다.<br/>
귀납적으로 계속해가면 결국 gcd(F(nk), F(n)) = gcd(F(n), F(n)) = F(n)을 얻는다.<br/>
그래서 gcd의 정의로 F(nk)는 F(n)에 나눠떨어진다.<br/>


#### 보조정리 6
그리고 gcd(F(nk + 1), F(n)) = 1임을 보일 수 있다.<br/>
gcd(F(nk + 1), F(n)) = 1이다. F(nk)는 F(n)([보조정리 5](#보조정리-5))에 나눠떨어지므로 gcd(F(nk + 1), F(n)) = 1이된다.<br/>



이제 이들을 이용해 gcd(F(n), F(m)) = F(gcd(n, m))이 성립함을 보이자.<br/>
편의상 n ≤ m이라 하자.<br/>
나눗셈 알고리즘으로 m = nk + r, 0 ≤ r < n인 정수 k와 r이 존재 한다.<br/>
그리고 [보조정리 1](#보조정리-1)으로 아래 식이 성립한다.<br/>
gcd(F(n), F(m)) = gcd(F(n), F(nk + 1) * F(r) + F(nk) * F(r - 1))<br/>
여기서 F(nk) 는 F(n)에 나눠떨어지므로[보조정리 5](#보조정리-5)<br/>
gcd(F(n), F(m)) = gcd(F(n), F(nk + 1) * F(r))<br/>
그리고 gcd(F(n), F(nk + 1)) = 1[보조 정리 6](#보조정리-6)이고 gcd(a, b) = 1일 때, gcd(a, bc) = gcd(a, c)[보조정리 4](#보조정리-4)이므로<br/>
gcd(F(n), F(m)) = gcd(F(n), F(r))이 된다.<br/>
이를 계속해가면 유클리드 호제법으로 gcd(F(n), F(m)) = F(gcd(n, m))이 성립한다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/28474