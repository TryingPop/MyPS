# C#

## 난이도 : 플레티넘 5

## 알고리즘 분류
  - 다이나믹 프로그래밍
  - 애드 혹

## 제한조건
  - 시간 제한 : 1초
  - 메모리 제한 : 1024 MB

## 문제
민찬이는 KSA 학생들을 위해 1번부터 N번까지의 문제들로 구성된 문제 목록을 준비했다. i번 문제의 레벨은 A_i이다.<br/>
학생들로부터 문제가 너무 많다는 불평을 들은 민찬이는 문제 목록을 한 개 이상의 연속된 구간으로 분할해, 구간마다 그 구간에 속한 문제들을 하나의 새로운 문제로 대체하려고 한다. 단, 각 구간에는 적어도 하나의 문제가 포함되어 있어야 하며, KSA 학생들을 더 헷갈리게 하기 위해 인접한 두 구간의 문제 수는 서로 다르도록 분할해야 한다.<br/>
새로운 문제의 레벨은 해당하는 구간에 속한 문제의 레벨을 모두 bitwise XOR한 값이다. 민찬이는 KSA 학생들의 실력 향상을 위해 새로운 문제들의 레벨 합을 최대로 하려고 한다. 문제 목록을 적절한 구간들로 분할했을 때, 새로운 문제들의 레벨 합의 최댓값을 구해보자.<br/>


## 입력
첫 번째 줄에 정수 N이 주어진다.<br/>
두 번째 줄에 N개의 정수 A_1, A_2, ..., A_N이 공백으로 구분되어 주어진다.<br/>


## 출력
새로운 문제들의 레벨 합의 최댓값을 출력한다.<br/>


## 제한
  - 1 ≤ N ≤ 2 x 10^5
  - 0 ≤ A_i ≤ 10^9 (1 ≤ i ≤ N)


## 예제 입력
3<br/>
5 3 2<br/>


## 예제 출력
8<br/>


## 힌트
[1, 2], [3, 3] 두 구간으로 분할하면 레벨 합을 8로 만들 수 있다.<br/>
(5 ^ 3) + (2) = 8<br/>


## 노트
음이 아닌 두 정수 A와 B의 bitwise XOR, 즉 A ^ B는 다음과 같이 정의된다:<br/>
 
  - A ^ B를 이진수로 나타냈을때 2^k의 자리 숫자(k ≥ 0)는 A와 B에서 그 자리에 있는 숫자 중 정확히 하나가 1이면 1이고, 그렇지 않다면 0이다.

예를 들어, 3 ^ 5 = 6이다. (이진수로 나타내면: 011 ^ 101 = 110).<br/>


## 풀이
따로 아이디어가 떠오르지 않아 풀이를 봤다.<br/>
그러니 4개 이하의 구간합에서 최댓값이 나온다고 한다.<br/>
이후 다른 사람의 풀이를 보고나니 a + b ≥ a ^ b가 성립하기에 4개 이하의 구간합에서 최댓값이 나옴을 확인했다.<br/>


최대 구간을 4개로 잡으면 dp[i][j] = val를 다음과 같이 잡으면 된다.<br/>
i 번째까지 원소를 선택했고, 이전 구간의 길이를 j라 할 때 최대 합을 val가되게 dp에 담는다.<br/>
그러면 dp[i][j]는 이전 구간에 넣을지 혹은 이전 구간과 더할지 택하면서 나아가면 된다.<br/>


## 문제 링크
https://www.acmicpc.net/problem/29200